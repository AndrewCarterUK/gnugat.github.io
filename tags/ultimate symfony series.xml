<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[Loïc Faugeron]]></title>
    <link href="https://gnugat.github.io/feed/atom.xml" rel="self"/>
    <link href="https://gnugat.github.io/"/>
    <updated>2016-03-15T22:56:02+00:00</updated>
    <id>http://gnugat.github.com</id>
            <author>
            <name><![CDATA[Loïc Faugeron]]></name>            <email><![CDATA[faugeron.loic@gmail.com]]></email>        </author>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[The Ultimate Developer Guide to Symfony - Skeleton]]></title>
            <link href="https://gnugat.github.io/2016/03/16/ultimate-symfony-skeleton.html"/>
            <updated>2016-03-16T00:00:00+00:00</updated>
            <id>https://gnugat.github.io/2016/03/16/ultimate-symfony-skeleton.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Reference</strong>: This article is intended to be as complete as possible and is
  kept up to date.</p>
  
  <p><strong>TL;DR</strong>: Start by putting everything in <code>AppBundle</code> until we have a better
  idea of what the project looks like and how to organize it.</p>
</blockquote>

<p>In this guide we've explored the main standalone libraries (also known as "Components")
provided by <a href="http://symfony.com">Symfony</a> to help us build applications:</p>

<ul>
<li><a href="/2016/02/03/ultimate-symfony-http-kernel.html">HTTP Kernel and HTTP Foundation</a></li>
<li><a href="/2016/02/10/ultimate-symfony-event-dispatcher.html">Event Dispatcher</a></li>
<li><a href="/2016/02/17/ultimate-symfony-routing.html">Routing and YAML</a></li>
<li><a href="/2016/02/24/ultimate-symfony-dependency-injection.html">Dependency Injection</a></li>
<li><a href="/2016/03/02/ultimate-symfony-console.html">Console</a></li>
</ul>

<p>We've also seen how HttpKernel enabled reusable code with <a href="/2016/03/09/ultimate-symfony-bundle.html">Bundles</a>.</p>

<p>In this article, we're going to have a closer look at how to organise our applications
directory tree.</p>

<h2 id="editions">Editions</h2>

<p>Deciding how our project directory is organized is up to us, but for consistency
and convenience we usually use "Editions" to bootstrap new projects:</p>

<pre><code>composer create-project gnugat/symfony-empty-edition our-project
cd our-project
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Here we've decided to use the <a href="https://github.com/gnugat/symfony-empty-edition">Symfony Empty Edition</a>
  which follows the "add what you need" philosophy (it only contains the strict minimum).</p>
  
  <p>If we're rather fond of the "solve 80% of use cases" philosophy we can go for
  <a href="https://github.com/symfony/symfony-standard">Standard Edition</a>
  which includes many tools commonly used to build full-stack websites.</p>
  
  <p>To find more distributions, <a href="http://symfony.com/distributions">check the official website</a>.</p>
</blockquote>

<p>The directory tree looks like this:</p>

<pre><code>.
├── app
│   ├── AppKernel.php
│   ├── autoload.php
│   └── config
│       ├── config_dev.yml
│       ├── config_prod.yml
│       ├── config_test.yml
│       ├── config.yml
│       └── parameters.yml.dist
├── bin
│   └── console
├── composer.json
├── src
│   └── AppBundle
│       └── AppBundle.php
├── var
│   ├── cache
│   └── logs
└── web
    ├── app.php
    ├── favicon.ico
    └── robots.txt
</code></pre>

<p>Each folder in the root directory has a purpose:</p>

<ul>
<li><code>app</code>: configuration</li>
<li><code>bin</code>: scripts, binaries</li>
<li><code>src</code>: our code</li>
<li><code>var</code>: temporary files</li>
<li><code>web</code>: public directory exposed via the web server (<code>app.php</code> is the front controller)</li>
</ul>

<blockquote>
  <p><strong>Note</strong>: Classes that wouldn't be used in production can be put outside of
  <code>src</code> (e.g. tests could be put in <code>tests</code>, fixtures in <code>fixtures</code>, etc). They
  should be configured in <code>composer.json</code> as follow:</p>

<pre><code>{
    "autoload-dev": {
        "psr-4": {
            "Gnugat\\Toasty\\Fixtures\\": "fixtures",
            "Gnugat\\Toasty\\Tests\\": "tests"
        }
    }
}
</code></pre>
  
  <p>This way, when running Composer's <code>install</code> command in development we get our
  tests/fixtures classes autoloaded, and when running the same command with <code>--no-dev</code>
  option in production we don't.</p>
</blockquote>

<h2 id="appbundle">AppBundle</h2>

<p>Once we have an empty skeleton, we can start organizing our code by puting all
new classes in <code>src/AppBundle</code>, as advised by the <a href="http://symfony.com/doc/current/best_practices/business-logic.html">official best practice</a>.</p>

<p>Symfony specific classes can be put in the following directories:</p>

<ul>
<li><code>src/AppBundle/Command</code>, for Console Commands</li>
<li><code>src/AppBundle/Controller</code> for HttpKernel Controllers</li>
<li><code>src/AppBundle/DependencyInjection</code>, for <code>CompilerPassInterface</code> and <code>ExtensionInterface</code> implementations</li>
<li><code>src/AppBundle/EventListener</code>, for EventDispatcher Listeners</li>
</ul>

<p>Our project specific classes can be put the <code>src/AppBundle/Service</code> directory.</p>

<p>The number of classes in will grow overtime, at some point we'll have an itch to
organize them in a better way: we can group them by entity.</p>

<p>Regarding configuration, we can organize it this way:</p>

<ul>
<li><code>app/config/routings/</code>, contains Router configuration</li>
<li><code>app/config/services/</code>, contains Dependency Injection configuration</li>
</ul>

<p>The directory tree looks like this:</p>

<pre><code>.
├── app
│   ├── AppKernel.php
│   ├── autoload.php
│   └── config
│       ├── config_dev.yml
│       ├── config_prod.yml
│       ├── config_test.yml
│       ├── config.yml
│       ├── parameters.yml.dist
│       ├── routings
│       └── services
├── bin
│   └── console
├── composer.json
├── composer.lock
├── src
│   └── AppBundle
│       ├── AppBundle.php
│       ├── Command
│       ├── Controller
│       ├── DependencyInjection
│       │   └── CompilerPass
│       ├── EventListener
│       └── Service
├── var
│   ├── cache
│   └── logs
└── web
    ├── app.php
    ├── favicon.ico
    └── robots.txt
</code></pre>

<h2 id="decoupling-from-framework">Decoupling from framework</h2>

<p>Starting by putting everything in <code>AppBundle</code> is fine until we have a better idea
of what the project looks like and how to organize it.</p>

<p>As suggested in the <a href="http://symfony.com/doc/current/best_practices/business-logic.html">official best practice</a>,
we can move our "business logic" (everything in <code>src/AppBundle/Service</code>) to a new
<code>src/&lt;vendor&gt;/&lt;project&gt;</code> directory.</p>

<blockquote>
  <p><strong>Note</strong>: Replace <code>&lt;vendor&gt;</code> by the organization/author (e.g. <code>Gnugat</code>)
  and <code>&lt;project&gt;</code> by the project name (e.g. <code>Toasty</code>).</p>
</blockquote>

<p>The directory tree looks like this:</p>

<pre><code>.
├── app
│   ├── AppKernel.php
│   ├── autoload.php
│   └── config
│       ├── config_dev.yml
│       ├── config_prod.yml
│       ├── config_test.yml
│       ├── config.yml
│       ├── parameters.yml.dist
│       ├── routings
│       └── services
├── bin
│   └── console
├── composer.json
├── composer.lock
├── src
│   ├── AppBundle
│   │   ├── AppBundle.php
│   │   ├── Command
│   │   ├── Controller
│   │   ├── DependencyInjection
│   │   │   └── CompilerPass
│   │   └── EventListener
│   └── &lt;vendor&gt;
│       └── &lt;project&gt;
├── var
│   ├── cache
│   └── logs
└── web
    ├── app.php
    ├── favicon.ico
    └── robots.txt
</code></pre>

<p>By leaving Symfony related classes in <code>src/AppBundle</code> and our "business logic"
in <code>src/&lt;vendor&gt;/&lt;project&gt;</code>, it becomes easier to <a href="/2015/09/30/decouple-from-frameworks.html">decouple from the framework</a>.</p>

<h2 id="decouple-from-libraries">Decouple from libraries</h2>

<p>Building on "decoupling from frameworks", we might also want to <a href="http://localhost:8000/2015/10/12/decouple-from-libraries.html">decouple from libraires</a>.
To do so our "business logic" classes should rely on interfaces, and their implementation
would use libraries.</p>

<p>At this point we can get three different categories of classes:</p>

<ul>
<li><code>Domain</code> ones, classes that reflect our business logic</li>
<li><code>Component</code> ones, classes that don't have a direct link to our project and could be reused as libraries</li>
<li><code>Bridge</code> ones, classes that map our Domain to Component (or third party libraries)</li>
</ul>

<p>By organizing our directory tree with those categories, it could looks like this:</p>

<pre><code>.
├── app
│   ├── AppKernel.php
│   ├── autoload.php
│   └── config
│       ├── config_dev.yml
│       ├── config_prod.yml
│       ├── config_test.yml
│       ├── config.yml
│       ├── parameters.yml.dist
│       ├── routings
│       └── services
├── bin
│   └── console
├── composer.json
├── composer.lock
├── src
│   ├── AppBundle
│   │   ├── AppBundle.php
│   │   ├── Command
│   │   ├── Controller
│   │   ├── DependencyInjection
│   │   │   └── CompilerPass
│   │   └── EventListener
│   └── &lt;vendor&gt;
│       └── &lt;project&gt;
│           ├── Bridge
│           ├── Component
│           └── Domain
├── var
│   ├── cache
│   └── logs
└── web
    ├── app.php
    ├── favicon.ico
    └── robots.txt
</code></pre>

<p>The issue with the previous organization is that classes in <code>Bridge</code> are now away
from their interface. Wouldn't it better to keep related classes close?</p>

<p>Here's an alternative organization, where we move <code>Bridge</code> to be in <code>Domain</code>:</p>

<pre><code>.
├── app
│   ├── AppKernel.php
│   ├── autoload.php
│   └── config
│       ├── config_dev.yml
│       ├── config_prod.yml
│       ├── config_test.yml
│       ├── config.yml
│       ├── parameters.yml.dist
│       ├── routings
│       └── services
├── bin
│   └── console
├── composer.json
├── composer.lock
├── src
│   ├── AppBundle
│   │   ├── AppBundle.php
│   │   ├── Command
│   │   ├── Controller
│   │   ├── DependencyInjection
│   │   │   └── CompilerPass
│   │   └── EventListener
│   └── &lt;vendor&gt;
│       └── &lt;project&gt;
│           ├── Component
│           └── Domain
│               └── Bridge
├── var
│   ├── cache
│   └── logs
└── web
    ├── app.php
    ├── favicon.ico
    └── robots.txt
</code></pre>

<blockquote>
  <p><strong>Note</strong>: <code>Components</code> could also need their own bridges. Also, a "Bundle" is
  a kind of bridge: it maps a library to Symfony.</p>
</blockquote>

<h2 id="monolithic-repository">Monolithic Repository</h2>

<p>There's a possibility that our application grows out of proportion and we decide
it'd be better to split it into smaller applications.</p>

<p>For example if we have an application that creates resources through a backend
and then provides them through an API for other applications, we could split it
in two: <code>backend</code> (note that <code>backend</code> could also be split in two:
<code>backend-api</code> and <code>backend-ui</code>) and <code>api</code>.</p>

<p>The problem is that those two applications would share a lot of logic, so splitting
them in different repositories could become cumbersome to maintain. A good indicator
to know if they need to be in the same repository: when we create a new version,
do we need to release them together?</p>

<p>In that case it might be worth keeping those two applications in the same repository,
this practice being called "Monolithic Repository".</p>

<p>For our project, it would mean:</p>

<ul>
<li>creating an <code>apps</code> directory where we would put small symfony applications,
similar to the first directory tree we've seen</li>
<li>creating a <code>packages</code> directory where we would put the previous content of <code>src/&lt;vendor&gt;/&lt;project&gt;</code>,
with each component in their own directory (to enable us to use them selectively in each apps)</li>
</ul>

<p>Here's an overview:</p>

<pre><code>.
├── apps
│   └── &lt;app&gt;
│       ├── app
│       │   ├── AppKernel.php
│       │   ├── autoload.php
│       │   └── config
│       │       ├── config_dev.yml
│       │       ├── config_prod.yml
│       │       ├── config_test.yml
│       │       ├── config.yml
│       │       ├── parameters.yml.dist
│       │       ├── routings
│       │       └── services
│       ├── bin
│       │   └── console
│       ├── composer.json
│       ├── composer.lock
│       ├── src
│       │   └── AppBundle
│       │       ├── AppBundle.php
│       │       ├── Command
│       │       ├── Controller
│       │       ├── DependencyInjection
│       │       │   └── CompilerPass
│       │       └── EventListener
│       ├── var
│       │   ├── cache
│       │   └── logs
│       └── web
│           ├── app.php
│           ├── favicon.ico
│           └── robots.txt
└── packages
    └── &lt;package&gt;
        ├── composer.json
        └── src
</code></pre>

<blockquote>
  <p><strong>Note</strong>: More information about Monolithic Repository:</p>
  
  <ul>
  <li><a href="http://gregoryszorc.com/blog/2014/09/09/on-monolithic-repositories/">On monolithic repositories</a></li>
  <li><a href="http://danluu.com/monorepo/">Advantages of monolithic version control</a></li>
  <li><a href="http://sroze.io/2015/09/14/managing-monolith-repositories-with-composers-path-repository/">Managing monolithic repositories with composer’s path repository</a></li>
  <li><a href="https://qafoo.com/talks/15_10_symfony_live_berlin_monorepos.pdf">Working with a single, big, scary version control repository</a></li>
  <li><a href="http://www.whitewashing.de/2015/04/11/monolithic_repositories_with_php_and_composer.html">Monolithic Repositories with PHP and Composer</a></li>
  <li><a href="http://tech.mybuilder.com/why-we-created-conductor/">Conductor: A return to monolith</a></li>
  </ul>
</blockquote>

<h2 id="conclusion">Conclusion</h2>

<p>There are many ways to organize our application directory tree, and it's difficult
to pick one when we don't have a clear idea on their impact or on what our project
should look like.</p>

<p>The best way to tackle this is to first start small (everything in <code>src/AppBundle</code>),
and then move gradually files around. It's also important to make ure that change
is possible.</p>

<p>Here are some alternative ways of organizing the project directory tree:</p>

<ul>
<li><a href="http://programmingarehard.com/2015/03/04/structing-my-application.html/">Structuring my application</a>
by <a href="http://twitter.com/dadamssg">David Adams</a></li>
<li><a href="http://verraes.net/2011/10/code-folder-structure/">Code Folder Structure</a>
by <a href="http://twitter.com/mathiasverraes">Mathias Verraes</a></li>
<li><a href="http://williamdurand.fr/2013/08/07/ddd-with-symfony2-folder-structure-and-code-first/">DDD with Symfony2: Folder Structure And Code First</a>
by <a href="http://williamdurand.fr/">William Durand</a></li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[The Ultimate Developer Guide to Symfony - Bundle]]></title>
            <link href="https://gnugat.github.io/2016/03/09/ultimate-symfony-bundle.html"/>
            <updated>2016-03-09T00:00:00+00:00</updated>
            <id>https://gnugat.github.io/2016/03/09/ultimate-symfony-bundle.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Reference</strong>: This article is intended to be as complete as possible and is
  kept up to date.</p>
  
  <p><strong>TL;DR</strong>: Configure services from a third party library in a Bundle.</p>
</blockquote>

<p>In this guide we've explored the main standalone libraries (also known as "Components")
provided by <a href="http://symfony.com">Symfony</a> to help us build applications:</p>

<ul>
<li><a href="/2016/02/03/ultimate-symfony-http-kernel.html">HTTP Kernel and HTTP Foundation</a></li>
<li><a href="/2016/02/10/ultimate-symfony-event-dispatcher.html">Event Dispatcher</a></li>
<li><a href="/2016/02/17/ultimate-symfony-routing.html">Routing and YAML</a></li>
<li><a href="/2016/02/24/ultimate-symfony-dependency-injection.html">Dependency Injection</a></li>
<li><a href="/2016/03/02/ultimate-symfony-console.html">Console</a></li>
</ul>

<p>In this article, we're going to have a closer look at how HttpKernel enables reusable code.</p>

<h2 id="httpkernel-vs-kernel">HttpKernel vs Kernel</h2>

<p>The HttpKernel component provides two implementations for <code>HttpKernelInterface</code>.</p>

<p>The first one, <code>HttpKernel</code>, relies on Event Dispatcher and Routing to execute
the appropriate controller for the given Request.</p>

<p>And the second one, <code>Kernel</code>, relies on Dependency Injection and <code>HttpKernel</code>:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\HttpKernel;

use Symfony\Component\HttpFoundation\Request;

class Kernel implements HttpKernelInterface
{
    public function handle(Request $request, $type = HttpKernelInterface::MASTER_REQUEST, $catch = true)
    {
        if (false === $this-&gt;booted) {
            $this-&gt;boot();
        }

        return $this-&gt;container-&gt;get('http_kernel')-&gt;handle($request, $type, $catch);
    }

    public function boot()
    {
        // Initializes the container
    }

    abstract public function registerBundles();
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: For brevity's sake, <code>Kernel</code> has been heavily truncated.</p>
</blockquote>

<p>Initialization of the container includes:</p>

<ol>
<li>retrieving all "bundles"</li>
<li>creating a <code>ContainerBuilder</code></li>
<li>for each bundles:

<ol>
<li>registering its <code>ExtensionInterface</code> implementations in the container</li>
<li>registering its <code>CompilerPassInterface</code> implementations in the container</li>
</ol></li>
<li>dumping the container in an optimized implementation</li>
</ol>

<p>Once the container is initialized, <code>Kernel</code> expects it to contain a <code>http_kernel</code>
service to which it will delegate the actual HTTP work.</p>

<h2 id="bundle">Bundle</h2>

<p>A bundle is a package that contains <code>ExtensionInterface</code> and <code>CompilerPassInterface</code>
implementations, to configure a Dependency Injection container. It can be summed
up by this interface:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\HttpKernel\Bundle;

use Symfony\Component\DependencyInjection\ContainerBuilder;

interface BundleInterface
{
    // Adds CompilerPassInterface implementations to the container
    public function build(ContainerBuilder $container);

    // Returs an ExtensionInterface implementation, which will be registered in the container
    public function getContainerExtension();
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Once again, this interface has been truncated for brevity's sake.</p>
</blockquote>

<p>Bundles are usually created for one of the following purposes:</p>

<ul>
<li>define a third party library's classes as Dependency Injection services (e.g.
<a href="https://github.com/thephpleague/tactician-bundle">TacticianBundle</a>
for <a href="https://tactician.thephpleague.com/">Tactician</a>
which provides a <a href="http://shawnmc.cool/command-bus">CommandBus</a>,
<a href="https://github.com/symfony/monolog-bundle">MonologBundle</a>
for <a href="https://github.com/Seldaek/monolog">Monolog</a>
which provies a <a href="http://www.php-fig.org/psr/psr-3/">PSR-3</a> compliant logger,
etc)</li>
<li>define an application's classes as Dependency Injection services (usually named AppBundle)</li>
<li>create a framework (e.g.
user management with <a href="https://github.com/FriendsOfSymfony/FOSUserBundle">FOSUserBundle</a>,
admin generator with <a href="https://sonata-project.org/bundles/admin/2-3/doc/index.html">SonataAdminBundle</a>,
etc)</li>
</ul>

<blockquote>
  <p><strong>Note</strong>: the last category is considered bad practice, as explained in the
  following, articles:</p>
  
  <ul>
  <li><a href="http://jolicode.com/blog/do-not-use-fosuserbundle">composer require technical-debt-bundle</a>.</li>
  <li><a href="http://elnur.pro/use-only-infrastructural-bundles-in-symfony/">Use only infrastructural bundles in Symfony2, by Elnur Abdurrakhimov</a></li>
  <li><a href="http://stackoverflow.com/questions/9999433/should-everything-really-be-a-bundle-in-symfony-2-x/10001019#10001019">Should everything really be a bundle in Symfony2?</a></li>
  <li><a href="http://danielribeiro.org/blog/yes-you-can-have-low-coupling-in-a-symfony-standard-edition-application/">Yes, you can have low coupling in a Symfony2 application</a></li>
  <li><a href="http://elnur.pro/symfony-without-bundles/">Symfony2 without bundles, by Elnur Abdurrakhimov, by Daniel Ribeiro</a></li>
  <li><a href="http://php-and-symfony.matthiasnoback.nl/2013/10/symfony2-some-things-i-dont-like-about-bundles/">Symfony2 some things I dont like about bundles, by Matthias Noback</a></li>
  <li><a href="http://php-and-symfony.matthiasnoback.nl/2013/10/symfony2-console-commands-as-services-why/">Symfony2 console commands as services why, by Matthias Noback</a></li>
  <li><a href="http://www.slideshare.net/matthiasnoback/high-quality-symfony-bundles-tutorial-dutch-php-conference-2014">Naked bundles, slides by Matthias Noback</a></li>
  </ul>
</blockquote>

<p>Bundles follow <a href="http://symfony.com/doc/current/cookbook/bundles/best_practices.html">by convention</a>
the following directory tree:</p>

<pre><code>.
├── Command
├── Controller
├── DependencyInjection
│   └── CompilerPass
├── EventListener
├── Resources
│   └── config
│       └── services
│           └── some_definitions.yml
├── Tests
└── VendorProjectBundle.php
</code></pre>

<h2 id="nanoframeworkbundle-example">NanoFrameworkBundle example</h2>

<p>Since HttpKernel component is a third party library, we're going to create a
bundle to provide its classes as Dependency Injection services. This is also a
good opportunity to have a look at how a Symfony application works behind the hood.</p>

<p>NanoFrameworkBundle's purpose is to provides a <code>http_kernel</code> service that can be
used by <code>Kernel</code>. First let's create a directory:</p>

<pre><code>mkdir nano-framework-bundle
cd nano-framework-bundle
</code></pre>

<p>Then we can create an implementation of <code>BundleInterface</code>:</p>

<pre><code class="php">&lt;?php
// VendorNanoFrameworkBundle.php

namespace Vendor\NanoFrameworkBundle;

use Symfony\Component\HttpKernel\Bundle\Bundle;

class VendorNanoFrameworkBundle extends Bundle
{
}
</code></pre>

<h3 id="bundle-extension">Bundle extension</h3>

<p>To be able to load Dependency Injection configuration, we'll create an
implementation of <code>ExtensionInterface</code>:</p>

<pre><code class="php">&lt;?php
// DependencyInjection/VendorNanoFrameworkExtension.php

namespace Vendor\NanoFrameworkBundle\DependencyInjection;

use Symfony\Component\Config\FileLocator;
use Symfony\Component\Config\Loader\LoaderResolver;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\DirectoryLoader;
use Symfony\Component\DependencyInjection\Loader\YamlFileLoader;
use Symfony\Component\HttpKernel\DependencyInjection\Extension;

class VendorNanoFrameworkExtension extends Extension
{
    public function load(array $configs, ContainerBuilder $container)
    {
        $fileLocator = new FileLocator(__DIR__.'/../Resources/config');
        $loader = new DirectoryLoader($container, $fileLocator);
        $loader-&gt;setResolver(new LoaderResolver(array(
            new YamlFileLoader($container, $fileLocator),
            $loader,
        )));
        $loader-&gt;load('services/');
    }
}
</code></pre>

<p>Once done, we can create the configuration:</p>

<pre><code># Resources/config/services/http_kernel.yml
services:
    http_kernel:
        class: Symfony\Component\HttpKernel\HttpKernel
        arguments:
            - "@event_dispatcher"
            - "@controller_resolver"
            - "@request_stack"

    event_dispatcher:
        class: Symfony\Component\EventDispatcher\EventDispatcher

    controller_resolver:
        class: Symfony\Component\HttpKernel\Controller\ControllerResolver
        public: false

    request_stack:
        class: Symfony\Component\HttpFoundation\RequestStack
</code></pre>

<h3 id="bundle-compiler-pass">Bundle compiler pass</h3>

<p>In order to register event listeners in EventDispatcher in a way that doesn't
require us to edit <code>Resources/config/services/http_kernel.yml</code>, we're going to
create an implementation of <code>CompilerInterface</code>:</p>

<pre><code class="php">&lt;?php
// DependencyInjection/CompilerPass/AddListenersPass.php

namespace Vendor\NanoFrameworkBundle\DependencyInjection;

use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Compiler\CompilerPassInterface;
use Symfony\Component\DependencyInjection\Reference;

class AddListenersPass implements CompilerPassInterface
{
    public function process(ContainerBuilder $container)
    {
        $eventDispatcher = $container-&gt;findDefinition('event_dispatcher');
        $eventListeners = $container-&gt;findTaggedServiceIds('kernel.event_listener');
        foreach ($eventListeners as $id =&gt; $events) {
            foreach ($events as $event) {
                $eventDispatcher-&gt;addMethodCall('addListener', array(
                    $event['event'],
                    array(new Reference($id), $event['method']),
                    isset($event['priority']) ? $event['priority'] : 0;
                ));
            }
        }
    }
}
</code></pre>

<p>With this, we only need to add a tag with:</p>

<ul>
<li>a <code>kernel.event_listener</code> name</li>
<li>an event to listen to (e.g. <code>kernel.request</code>)</li>
<li>a method to call (e.g. <code>onKernelRequest</code>)</li>
<li>optionally a priority (default to <code>0</code>, the greater the sooner it will be executed)</li>
</ul>

<p>To complete the step, we need to register it in our bundle:</p>

<pre><code class="php">&lt;?php
// VendorNanoFrameworkBundle.php

namespace Vendor\NanoFrameworkBundle;

use Symfony\Component\HttpKernel\Bundle\Bundle;
use Vendor\NanoFrameworkBundle\DependencyInjection\CompilerPass\AddListenersPass;

class VendorNanoFrameworkBundle extends Bundle
{
    public function build(ContainerBuilder $container)
    {
        parent::build($container);

        $container-&gt;addCompilerPass(new AddListenersPass());
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: While <code>CompilerPassInterface</code> implementations need to be registered
  explicitly, there is no need to do anything for <code>ExtensionInterface</code> implementations
  as <code>Bundle</code> contains a method able to locate it, based on the following conventions:</p>
  
  <ul>
  <li>it needs to be in <code>DependencyInjection</code> directory</li>
  <li>it needs to be named after the bundle name (replace <code>Bundle</code> suffix by <code>Extension</code>)</li>
  <li>it needs to implement <code>ExtensionInterface</code></li>
  </ul>
</blockquote>

<h3 id="more-configuration">More configuration</h3>

<p>HttpKernel relies on event listeners for the routing, in order to enable it we
need to add the following configuration:</p>

<pre><code># Resources/config/services/routing.yml
services:
    router_listener:
        class: Symfony\Component\HttpKernel\EventListener\RouterListener
        arguments:
            - "@router"
            - "@request_stack"
            - "@router.request_context"
        tags:
            - { name: kernel.event_listener, event: kernel.request, method: onKernelRequest, priority: 32 }

    router:
        class: Symfony\Component\Routing\Router
        public: false
        arguments:
            - "@routing.loader"
            - "%kernel.root_dir%/config/routings"
            - "%router.options%"
            - "@router.request_context"
        calls:
            - [setConfigCacheFactory, ["@config_cache_factory"]]

    routing.loader:
        class: Symfony\Component\Config\Loader\DelegatingLoader
        public: false
        arguments:
            - "@routing.resolver"

    routing.resolver:
        class: Symfony\Component\Config\Loader\LoaderResolver
        public: false
        calls:
            - [addLoader, ["@routing.loader.yml"]]

    router.request_context:
        class: Symfony\Component\Routing\RequestContext
        public: false

    config_cache_factory:
        class: Symfony\Component\Config\ResourceCheckerConfigCacheFactory
        public: false

    routing.loader.yml:
        class: Symfony\Component\Routing\Loader\YamlFileLoader
        public: false
        arguments:
            - "@file_locator"
</code></pre>

<h2 id="usage">Usage</h2>

<p>Since <code>Kernel</code> is an abstract class, we need to create an implementation (usually
called AppKernel):</p>

<pre><code class="php">&lt;?php
// Tests/app/AppKernel.php

use Symfony\Component\HttpKernel\Kernel;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        return array(
            new Vendor\NanoFrameworkBundle\VendorNanoFrameworkBundle(),
        );
    }

    public function getRootDir()
    {
        return __DIR__;
    }

    public function getCacheDir()
    {
        return dirname(__DIR__).'/var/cache/'.$this-&gt;getEnvironment();
    }

    public function getLogDir()
    {
        return dirname(__DIR__).'/var/logs';
    }
}
</code></pre>

<p>Finally we need to create a "Front Controller" (a fancy name for <code>index.php</code>):</p>

<pre><code class="php">&lt;?php
// Tests/web/index.php

&lt;?php

use Symfony\Component\HttpFoundation\Request;

$kernel = new AppKernel('prod', false);
$request = Request::createFromGlobals();
$response = $kernel-&gt;handle($request);
$response-&gt;send();
$kernel-&gt;terminate($request, $response);
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Bundles enable us to define classes as Dependency Injection services, for our
applications and third part libraries in a reusable way.</p>

<p>In the example above we've created a bundle that provides a <code>http_kernel</code> service,
which can then be used to create Symfony applications. Here are some existing
bundles that do it for us:</p>

<ul>
<li><a href="https://github.com/symfony/framework-bundle">FrameworkBundle</a>, the official one
provided by Symfony. It comes with many services out of the box, mainly targeted
at full stack applications (it follows a "solve 80% of use cases" philosohpy)</li>
<li><a href="http://gnugat.github.io/micro-framework-bundle/">MicroFrameworkBundle</a>, an unofficial
one. It comes with the bare minimum (it follows a "add what you need" philosohpy)</li>
</ul>

<p>There are many bundles available, you can find them by checking
<a href="https://packagist.org/search/?q=symfony-bundle">symfony-bundle in Packagist</a>.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[The Ultimate Developer Guide to Symfony - Console]]></title>
            <link href="https://gnugat.github.io/2016/03/02/ultimate-symfony-console.html"/>
            <updated>2016-03-02T00:00:00+00:00</updated>
            <id>https://gnugat.github.io/2016/03/02/ultimate-symfony-console.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Reference</strong>: This article is intended to be as complete as possible and is
  kept up to date.</p>
  
  <p><strong>TL;DR</strong>: <code>$statusCode = $application-&gt;run($input);</code></p>
</blockquote>

<p>In this guide we explore the standalone libraries (also known as "Components")
provided by <a href="http://symfony.com">Symfony</a> to help us build applications.</p>

<p>We've already seen:</p>

<ul>
<li><a href="/2016/02/03/ultimate-symfony-http-kernel.html">HTTP Kernel and HTTP Foundation</a></li>
<li><a href="/2016/02/10/ultimate-symfony-event-dispatcher.html">Event Dispatcher</a></li>
<li><a href="/2016/02/17/ultimate-symfony-routing.html">Routing and YAML</a></li>
<li><a href="/2016/02/24/ultimate-symfony-dependency-injection.html">Dependency Injection</a></li>
</ul>

<p>We're now about to check the last one: Console.</p>

<h2 id="application">Application</h2>

<p>Symfony provides a <a href="http://symfony.com/doc/current/components/console/introduction.html">Console component</a>
which allows us to create CLI commands. Its main class is <code>Application</code>:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\Console;

use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Command\Command;

class Application
{
    public function __construct($name = 'UNKNOWN', $version = 'UNKNOWN');

    public function add(Command $command);
    public function setDefaultCommand($commandName);
    public function run(InputInterface $input = null, OutputInterface $output = null);

    public function setAutoExit($boolean);
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: This snippet is a truncated version. Please note that <code>Application</code>
  is (unfortunately) not an interface.</p>
</blockquote>

<p>We can create it as follow:</p>

<pre><code class="php">&lt;?php
// /tmp/console.php

use Symfony\Component\Console\Application;
use Symfony\Component\Console\Input\ArgvInput;

$application = new Application('My Application', 'v4.2.3');
$application-&gt;add($command);
$application-&gt;setDefaultCommand($command-&gt;getName());

$application-&gt;run(new ArgvInput());
</code></pre>

<p>Which can then be used as follow:</p>

<pre><code>php /tmp/console.php
</code></pre>

<blockquote>
  <p><strong>Note</strong>: After running the command, <code>Application</code> will automatically stop
  using <code>exit</code>.
  As it can sometimes be inconvenient (for example in tests), we can disable it
  with this line: <code>$application-&gt;setAutoExit(false);</code></p>
</blockquote>

<p>Out of the box, <code>Application</code> has two commands:</p>

<ul>
<li><code>list</code>, list all available commands (it's the default command if <code>setDefaultCommand</code> hasn't been used)</li>
<li><code>help</code>, displays a description with available arguments and options for the current command</li>
</ul>

<h2 id="command">Command</h2>

<p>In order for <code>Application</code> to be useful, we need to create commands. This can be
done by extending <code>Command</code>:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\Console\Command;

use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;

class Command
{
    public function run(InputInterface $input, OutputInterface $output);
    // Called by run
    protected function execute(InputInterface $input, OutputInterface $output);
    protected function interact(InputInterface $input, OutputInterface $output);

    protected function configure();
    // To be called in configure
    public function setName($name);
    public function addArgument($name, $mode = null, $description = '', $default = null);
    public function addOption($name, $shortcut = null, $mode = null, $description = '', $default = null);
    public function setDescription($description);
    public function setHelp($help);
    public function setAliases($aliases);
}
</code></pre>

<p>We can configure the command (name, arguments, options, description, etc) in the
<code>configure</code> method, we can define more options to be asked interractively in
the <code>interact</code> method (e.g. <code>Are you sure? (Y/n)</code>) and finally we can write the
command logic in the <code>execute</code> method.</p>

<p>Commands are to Console what Controllers are to HttpKernel: their responsibility
is to extract input parameters, pass them to a service and then put the service's
returned value in the output.</p>

<h2 id="input">Input</h2>

<p>Input parameters are wrapped in the following interface:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\Console\Input;

interface InputInterface
{
    public function getArgument($name);
    public function getOption($name);
}
</code></pre>

<p>Out of the box we have the following implementations:</p>

<ul>
<li><code>ArgvInput</code>: wraps CLI arguments comming from <code>$_SERVER['argv']</code></li>
<li><code>ArrayInput</code>: define arguments using an array, which is useful for tests</li>
</ul>

<p><code>Application</code> will take care of validating <code>InputInterface</code> parameters against
the <code>Command</code> configuration (e.g. if required arguments present).</p>

<h2 id="output">Output</h2>

<p>While <code>InputInterface</code> can be seen as a value object, <code>OutputInterface</code> should
be seen as a service able to send informations to a stream:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\Console\Output;

abstract class Output implements OutputInterface
{
    public function writeln($messages, $type = self::OUTPUT_NORMAL);
}
</code></pre>

<p>The <code>writeln</code> method allows us to write a new line (with a newline character at
the end). If the given message is an array, it will print each elements on a new
line.</p>

<p>The given message can contain tags (e.g. <code>Arthur &lt;info&gt;Dent&lt;/info&gt;</code>), which can
be used to format it. Out of the box it will color the followings:</p>

<ul>
<li>green text for informative messages (usage example: <code>&lt;info&gt;Arthur Dent&lt;/info&gt;</code>)</li>
<li>yellow text for comments (usage example: <code>&lt;comment&gt;Tricia McMillan&lt;/comment&gt;</code>)</li>
<li>black text on a cyan background for questions (usage example: <code>&lt;question&gt;Ford Prefect&lt;/question&gt;</code>)</li>
<li>white text on a red background for errors (usage example: <code>&lt;error&gt;Marvin&lt;/error&gt;</code>)</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>The Console component allows us to create CLI applications. Its Commands are a
thin layer which gathers the input and call services. Those services can then
output messages to the user.</p>

<blockquote>
  <p><strong>Note</strong>: Since Symfony follows a <a href="https://github.com/symfony/symfony-docs/issues/4265">Console Output Formating Style Guide</a>,
  the Console component provides the following helper class:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\Console\Style;

use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Question\Question;

class SymfonyStyle
{
    public function __construct(InputInterface $input, OutputInterface $output);

    public function block($messages, $type = null, $style = null, $prefix = ' ', $padding = false);
    public function title($message);
    public function section($message);
    public function listing(array $elements);
    public function text($message);

    public function comment($message);
    public function success($message);
    public function error($message);
    public function warning($message);
    public function note($message);
    public function caution($message);

    public function table(array $headers, array $rows);

    public function ask($question, $default = null, $validator = null);
    public function askHidden($question, $validator = null);
    public function confirm($question, $default = true);
    public function choice($question, array $choices, $default = null);
    public function askQuestion(Question $question);

    public function progressStart($max = 0);
    public function progressAdvance($step = 1);
    public function progressFinish();
    public function createProgressBar($max = 0);

    public function writeln($messages, $type = self::OUTPUT_NORMAL);
    public function write($messages, $newline = false, $type = self::OUTPUT_NORMAL);
    public function newLine($count = 1);
}
</code></pre>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[The Ultimate Developer Guide to Symfony - Dependency Injection]]></title>
            <link href="https://gnugat.github.io/2016/02/24/ultimate-symfony-dependency-injection.html"/>
            <updated>2016-02-24T00:00:00+00:00</updated>
            <id>https://gnugat.github.io/2016/02/24/ultimate-symfony-dependency-injection.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Reference</strong>: This article is intended to be as complete as possible and is
  kept up to date.</p>
  
  <p><strong>TL;DR</strong>: Make Dependency Injection easy by moving class construction in
  configuration files.</p>
</blockquote>

<p>In this guide we explore the standalone libraries (also known as "Components")
provided by <a href="http://symfony.com">Symfony</a> to help us build applications.</p>

<p>We've already seen:</p>

<ul>
<li><a href="/2016/02/03/ultimate-symfony-http-kernel.html">HTTP Kernel and HTTP Foundation</a></li>
<li><a href="/2016/02/10/ultimate-symfony-event-dispatcher.html">Event Dispatcher</a></li>
<li><a href="/2016/02/17/ultimate-symfony-routing.html">Routing and YAML</a></li>
</ul>

<p>We're now about to check Dependency Injection, and finally in the next article
we'll have a look at <a href="/2016/03/02/ultimate-symfony-console.html">Console</a>.</p>

<h2 id="introduction-to-the-design-pattern">Introduction to the design pattern</h2>

<p>When first creating a class, we tend to keep it small and tidy. Then overtime it
can grow out of control and the next thing we know it became this multi thousand
line monster:</p>

<pre><code class="php">&lt;?php

class CheckApiStatus
{
    public function check($url)
    {
        $curl = curl_init();
        curl_setopt_array($curl, array(
            CUROPT_RETURNTRANSFER =&gt; true,
            CURLOPT_HEADER =&gt; true,
            CUROPT_URL =&gt; $url,
        ));
        $response = curl_exec($curl);
        $headerSize = curl_getinfo($curl, CURLINFO_HEADER_SIZE);
        $statusCode = curl_getinfo($curl, CURLINFO_HTTP_CODE);
        curl_close($curl);
        $headers = array_map(function($line) {
            return explode(': ', trim($line));
        }, explode("\n", substr($response, 0, $size)));
        array_pop($headers);array_pop($headers);array_shift($headers);
        $body = substr($response, $headerSize);

        return 200 &gt;= $statusCode &amp;&amp; $statusCode &lt; 400;
    }
}
</code></pre>

<p>A nice way to shrink it back to an acceptable level is to identify the many
"responsibilities" it bears and split those in sub classes. This process is called
refactoring:</p>

<pre><code class="php">&lt;?php

class Request
{
    private $uri;

    public function __construct($uri)
    {
        $this-&gt;uri;
    }

    public function getUri()
    {
        return $this-&gt;uri;
    }
}

class Response
{
    private $statusCode;
    private $headers;
    private $body;

    public function __construct($statusCode, $headers, $body)
    {
        $this-&gt;statusCode = $statusCode;
        $this-&gt;headers = $headers;
        $this-&gt;body = $body;
    }

    public function getStatusCode()
    {
        return $this-&gt;statusCode;
    }

    public function getHeaders()
    {
        return $this-&gt;headers;
    }

    public function getBody()
    {
        return $this-&gt;body;
    }
}

interface HttpClient
{
    /**
     * @return Response
     */
    public function sendRequest(Request $request);
}

class CurlHttpClient implements HttpClient
{
    public function sendRequest(Request $request)
    {
        $curl = curl_init();
        curl_setopt_array($curl, array(
            CUROPT_RETURNTRANSFER =&gt; true,
            CURLOPT_HEADER =&gt; true,
            CUROPT_URL =&gt; $request-&gt;getUri(),
        ));
        $response = curl_exec($curl);
        $headerSize = curl_getinfo($curl, CURLINFO_HEADER_SIZE);
        $statusCode = curl_getinfo($curl, CURLINFO_HTTP_CODE);
        curl_close($curl);
        $headers = array_map(function($line) {
            return explode(': ', trim($line));
        }, explode("\n", substr($response, 0, $size)));
        array_pop($headers);array_pop($headers);array_shift($headers);
        $body = substr($response, $headerSize);
        $body = substr($response, $headerSize);

        return new Response($statusCode, $headers, $body);
    }
}

class CheckApiStatus
{
    public function check($url)
    {
        $httpClient = new CurlHttpClient();
        $statusCode = $httpClient-&gt;sendRequest(new Request($url))-&gt;getStatusCode();

        return 200 &gt;= $statusCode &amp;&amp; $statusCode &lt; 400;
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: for more refactoring examples, check:</p>
  
  <ul>
  <li><a href="http://martinfowler.com/articles/refactoring-external-service.html">Refactoring external service</a> by Martin Fowler</li>
  <li><a href="http://verraes.net/2013/09/extract-till-you-drop/">Extract till you drop</a> by Mathias Verreas</li>
  <li>Refactoring the cat API
  <a href="http://php-and-symfony.matthiasnoback.nl/2015/07/refactoring-the-cat-api-client-part-1/">part 1</a>
  <a href="http://php-and-symfony.matthiasnoback.nl/2015/07/refactoring-the-cat-api-client-part-2/">part 2</a>
  <a href="http://php-and-symfony.matthiasnoback.nl/2015/07/refactoring-the-cat-api-client-part-3/">part 3</a>
  by Matthias Noback</li>
  </ul>
</blockquote>

<p>Our original class then has to call those sub classes to "delegate" the work. But
how does it access those sub classes? Should it instantiate them in its methods?
A better place could be the constructor, where the instances are stored in the class
properties so it can be shared between two calls.</p>

<p>Or even better we can instantiate them out of the class, and then pass them as
arguments to the original class constructor, so we can share it with other classes:</p>

<pre><code class="php">&lt;?php

class CheckApiStatus
{
    private $httpClient;

    public function __construct(HttpClient $httpClient)
    {
        $this-&gt;httpClient = $httpClient;
    }

    public function check($url)
    {
        $statusCode = $this-&gt;httpClient-&gt;sendRequest(new Request($url))-&gt;getStatusCode();

        return 200 &gt;= $statusCode &amp;&amp; $statusCode &lt; 400;
    }
}

$httpClient = new CurlHttpClient();
$checkApiStatus = new CheckApiStatus($httpClient);
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Now <code>CheckApiStatus</code> is decoupled from the remote request logic.</p>
  
  <p>The refactoring steps might seem like producing more code just for the "beauty"
  of principles, but it actually enables us to completly remove it: by using <a href="http://www.php-fig.org/psr/psr-7/">PSR-7</a>
  interfaces instead of our own we can easily switch to <a href="http://docs.guzzlephp.org/en/latest/">Guzzle</a>
  or any HTTP client library.</p>
</blockquote>

<p>And that's what <a href="http://www.martinfowler.com/articles/injection.html">Dependency Injection</a>
is all about: taking parameters (also known as dependencies) our class (also known as service)
needs and pass them as arguments (also known as injection), to allow more decoupling.</p>

<p>The downside of this design pattern is that we now have a cascade of instantiations.</p>

<blockquote>
  <p><strong>Note</strong>: Classes can be shared if they are stateless which means calling a method
  shouldn't change their attributes.</p>
</blockquote>

<h2 id="the-component">The component</h2>

<p>Symfony provides a <a href="http://symfony.com/doc/current/components/dependency-injection/introduction.html">Dependency Injection component</a>
which allows us to set up how our classes are constructed:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Reference;

$container = new ContainerBuilder();

$container
    -&gt;register('http_client','CurlHttpClient')
;
$container
    -&gt;register('check_api_status', 'CheckApiStatus')
    -&gt;addArgument(new Reference('http_client'))
;

$checkApiStatus = $container-&gt;get('check_api_status');
</code></pre>

<p>It can even be set up using configuration:</p>

<pre><code># /tmp/services/api.yml
services:
    http_client:
        class: CurlHttpClient

    check_api_status:
        class: CheckApiStatus
        arguments:
            - '@http_client'
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Some string values must be escaped using single quotes because YAML
  has a list of <a href="http://stackoverflow.com/a/22235064">reserved characters</a>, including:
  <code>@</code>, <code>%</code>, <code>\</code>, <code>-</code>, <code>:</code> <code>[</code>, <code>]</code>, <code>{</code> and <code>}</code>.</p>
</blockquote>

<p>Here's how we can load this configuration:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\Config\FileLocator;
use Symfony\Component\Config\Loader\LoaderResolver;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\DirectoryLoader;
use Symfony\Component\DependencyInjection\Loader\YamlFileLoader;

$container = new ContainerBuilder();

// Load recursively all YAML configuration files in services directories
$fileLocator = new FileLocator(__DIR__);
$loader = new DirectoryLoader($container, $fileLocator);
$loader-&gt;setResolver(new LoaderResolver(array(
    new YamlFileLoader($container, $fileLocator),
    $loader,
)));
$loader-&gt;load('/services/');

$checkApiStatus = $container-&gt;get('check_api_status');
</code></pre>

<p>Calling methods on a created service to complete its initialization is possible:</p>

<pre><code>services:
    my_event_listener:
        class: MyEventListener

    event_dispatcher:
        class: 'Symfony\Component\EventDispatcher\EventDispatcher'
        calls:
            - [ addListener, [ kernel.request, '@my_event_listener', 42 ] ]
</code></pre>

<blockquote>
  <p><strong>Note</strong>: There's a better way to add listeners to the EventDispatcher, keep
  reading to find out how.</p>
</blockquote>

<p>Finally it might be useful to create aliases:</p>

<pre><code>services:
    http_client:
        alias: curl_http_client

    curl_http_client:
        class: CurlHttpClient

    check_api_status:
        class: checkApiStatus
        arguments:
            - "@http_client"
</code></pre>

<p>In the example above <code>http_client</code> is set to be <code>curl_http_client</code>, it could be
changed later to use another implementation of <code>HttpClient</code>.</p>

<h2 id="parameters">Parameters</h2>

<p>In addition to class instances, we can also inject parameters:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Parameter;
use Symfony\Component\DependencyInjection\Reference;

$container = new ContainerBuilder();

$container-&gt;setParameter('username', 'arthur.dent@example.com');
$container-&gt;setParameter('password', 42);

$container
    -&gt;register('http_client','CurlHttpClient')
;
$container
    -&gt;register('check_api_status', 'CheckApiStatus')
    -&gt;addArgument(new Reference('http_client'))
    -&gt;addArgument(new Parameter('username'))
    -&gt;addArgument(new Parameter('password'))
;

$checkApiStatus = $container-&gt;get('check_api_status');
</code></pre>

<blockquote>
  <p><strong>Note</strong>: For the example's sake we're pretending that <code>CheckApiStatus</code>'s constructor
  now takes 3 arguments.</p>
</blockquote>

<p>Here's the equivalent in YAML:</p>

<pre><code># /tmp/services/api.yml
parameters:
    username: 'arthur.dent@example.com'
    password: 42

services:
    http_client:
        class: CurlHttpClient

    check_api_status:
        class: CheckApiStatus
        arguments:
            - '@http_client'
            - '%username%'
            - '%password%'
</code></pre>

<blockquote>
  <p><strong>Note</strong>: services are prefixed with <code>@</code>, and parameters are surrounded with <code>%</code>.</p>
</blockquote>

<p>The value of a parameter can be anything:</p>

<ul>
<li>null (<code>~</code>)</li>
<li>a boolean (<code>true</code> or <code>false</code>)</li>
<li>an integer (e.g. <code>42</code>)</li>
<li>a float (e.g. <code>44.23</code>)</li>
<li>a string (e.g. <code>hello world</code>, or escaped <code>'arthur.dent@example.com'</code>)</li>
<li>an array (e.g. <code>[ apples, oranges ]</code>)</li>
<li>an associative array (e.g. <code>{ first_name: Arthur, last_name: Dent }</code>)</li>
</ul>

<blockquote>
  <p><strong>Note</strong>: The examples above for arrays are inline ones. They could also be on many lines:</p>

<pre><code>parameters:
    fruits:
        - apples
        - oranges

    identity:
        first_name: Arthur
        last_name: Dent

    # We can even have multi dimension arrays:
    five_a_day:
        -
            - apples
            - oranges
        -
            - carrots
</code></pre>
</blockquote>

<h2 id="extension">Extension</h2>

<p>By creating a class that extends <code>Extension</code>, we can provide reusable Dependency
Injection configuration:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\Config\FileLocator;
use Symfony\Component\Config\Loader\LoaderResolver;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\DirectoryLoader;
use Symfony\Component\DependencyInjection\Loader\YamlFileLoader;
use Symfony\Component\HttpKernel\DependencyInjection\Extension;

class AppExtension extends Extension
{
    public function load(array $configs, ContainerBuilder $container)
    {
        $fileLocator = new FileLocator(__DIR__);
        $loader = new DirectoryLoader($container, $fileLocator);
        $loader-&gt;setResolver(new LoaderResolver(array(
            new YamlFileLoader($container, $fileLocator),
            $loader,
        )));
        $loader-&gt;load('/services/');
    }
}

$container = new ContainerBuilder();
$appExtension = new AppExtension();
$appExtension-&gt;load(array(), $container);

$checkApiStatus = $container-&gt;get('check_api_status');
</code></pre>

<h2 id="compilerpass-and-tags">CompilerPass and tags</h2>

<p>The <code>Container</code> implementation provides a <code>compile</code> method that resolves parameters
(replace <code>%parameter%</code> placeholders by the parameter value) and freezes them
(calling <code>setParameter</code> will result in an exception).</p>

<p>The <code>ContainerBuilder</code> implementations also has a <code>compile</code> method which is going
to execute all registered <code>CompilerPassInterface</code> implementations.</p>

<p>For example, we can retrieve all services "tagged" <code>kernel.event_listener</code> and
add them to the <code>EventDispatcher</code> with the following one:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Compiler\CompilerPassInterface;
use Symfony\Component\DependencyInjection\Reference;

class EventListenerCompilerPass implements CompilerPassInterface
{
    public function process(ContainerBuilder $container)
    {
        if (false === $container-&gt;hasDefinition('event_dispatcher')) {
            return;
        }
        $eventDispatcher = $container-&gt;getDefinition('event_dispatcher');
        $taggedServices = $container-&gt;findTaggedServiceIds('kernel.event_listener');
        foreach ($taggedServices as $id =&gt; $attributes) {
            $eventDispatcher-&gt;addMethodCall('addListener', array(
                $attributes['event'],
                array(new Reference($id), $attributes['method']),
                $attributes['priority'],
            ));
        }
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: The EventDispatcher component already provides a <code>RegisterListenersPass</code>.</p>
</blockquote>

<p>The configuration for a "tagged" service looks like this:</p>

<pre><code>services:
    my_event_listener:
        class MyEventListener
        tags:
            - { name: kernel.event_listener, event: kernel.request, method: onKernelRequest, priority: 42 }
</code></pre>

<blockquote>
  <p><strong>Note</strong>: With this, it is no longer required to call <code>addListener</code> in <code>event_dispatcher</code>'s
  configuration.</p>
</blockquote>

<h2 id="conclusion">Conclusion</h2>

<p>By providing a configurable way to define service construction, the DependencyInjection
component allows us to use the design pattern of the same name in our projects.</p>

<p>The HttpKernel component provides two <code>HttpKernelInterface</code> implementations:</p>

<ul>
<li><code>HttpKernel</code> which does the HTTP logic</li>
<li><code>Kernel</code> which sets up a DependencyInjection container and then use <code>HttpKernel</code></li>
</ul>

<p>Just like for the Routing component, there's a <code>PhpDumper</code> which can generate an
implementation of <code>ContainerInterface</code> with all configuration in an optimized way.
It might look like this:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\DependencyInjection\ContainerInterface;
use Symfony\Component\DependencyInjection\Container;
use Symfony\Component\DependencyInjection\Exception\InvalidArgumentException;
use Symfony\Component\DependencyInjection\Exception\LogicException;
use Symfony\Component\DependencyInjection\Exception\RuntimeException;
use Symfony\Component\DependencyInjection\ParameterBag\FrozenParameterBag;

class appDevDebugProjectContainer extends Container
{
    private $parameters;
    private $targetDirs = array();

    public function __construct()
    {
        $dir = __DIR__;
        for ($i = 1; $i &lt;= 5; ++$i) {
            $this-&gt;targetDirs[$i] = $dir = dirname($dir);
        }
        $this-&gt;parameters = $this-&gt;getDefaultParameters();

        $this-&gt;services = array();
        $this-&gt;methodMap = array(
            'http_client' =&gt; 'getHttpClientService',
            'check_api_status' =&gt; 'getCheckApiStatusService',
        );
        $this-&gt;aliases = array(
        );
    }

    public function compile()
    {
        throw new LogicException('You cannot compile a dumped frozen container.');
    }

    protected function getHttpClientService()
    {
        return $this-&gt;services['http_client'] = new \CurlHttpClient();
    }

    protected function getCheckApiStatusService()
    {
        return $this-&gt;services['check_api_status'] = new \CheckApiStatus($this-&gt;get('http_client'), 'arthur.dent@example.com', 42);
    }

    public function getParameter($name)
    {
        $name = strtolower($name);
        if (!(isset($this-&gt;parameters[$name]) || array_key_exists($name, $this-&gt;parameters))) {
            throw new InvalidArgumentException(sprintf('The parameter "%s" must be defined.', $name));
        }

        return $this-&gt;parameters[$name];
    }

    public function hasParameter($name)
    {
        $name = strtolower($name);

        return isset($this-&gt;parameters[$name]) || array_key_exists($name, $this-&gt;parameters);
    }

    public function setParameter($name, $value)
    {
        throw new LogicException('Impossible to call set() on a frozen ParameterBag.');
    }

    public function getParameterBag()
    {
        if (null === $this-&gt;parameterBag) {
            $this-&gt;parameterBag = new FrozenParameterBag($this-&gt;parameters);
        }

        return $this-&gt;parameterBag;
    }

    protected function getDefaultParameters()
    {
        return array(
            'username' =&gt; 'arthur.dent@example.com',
            'password' =&gt; 42,
        );
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Dependencies that are used by only one service can be marked as "private"
  they'll be hard coded in the service instantiation (but they won't be available
  anymore from <code>$container-&gt;get()</code>).</p>
  
  <p>In our example we could mark <code>http_client</code> as private, so the dumped Container
  wouldn't have a <code>getHttpClientService</code> method:</p>

<pre><code>service:
    http_client:
        class: CurlHttpClient
        public: false
</code></pre>
</blockquote>

<p>It is also worth noting that services are by default only initialized once and on demand,
so the number of services doesn't impact the performances of the application.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[The Ultimate Developer Guide to Symfony - Routing]]></title>
            <link href="https://gnugat.github.io/2016/02/17/ultimate-symfony-routing.html"/>
            <updated>2016-02-17T00:00:00+00:00</updated>
            <id>https://gnugat.github.io/2016/02/17/ultimate-symfony-routing.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Reference</strong>: This article is intended to be as complete as possible and is
  kept up to date.</p>
  
  <p><strong>TL;DR</strong>:</p>

<pre><code class="php">$parameters = $urlMatcher-&gt;match($request-&gt;getPathInfo());

$request-&gt;attributes-&gt;add(array('_controller' =&gt; $parameters['_controller']);
$request-&gt;attributes-&gt;add(array('_route' =&gt; $parameters['_route']);
unset($parameters['_controller'], $parameters['_route']);
$request-&gt;attributes-&gt;add(array('_route_params' =&gt; $parameters);
</code></pre>
</blockquote>

<p>In this guide we explore the standalone libraries (also known as "Components")
provided by <a href="http://symfony.com">Symfony</a> to help us build applications.</p>

<p>We've already seen:</p>

<ul>
<li><a href="/2016/02/03/ultimate-symfony-http-kernel.html">HTTP Kernel and HTTP Foundation</a></li>
<li><a href="/2016/02/10/ultimate-symfony-event-dispatcher.html">Event Dispatcher</a></li>
</ul>

<p>We're now about to check Routing and YAML, then in the next articles we'll have a look at:</p>

<ul>
<li><a href="/2016/02/24/ultimate-symfony-dependency-injection.html">Dependency Injection</a></li>
<li><a href="/2016/03/02/ultimate-symfony-console.html">Console</a></li>
</ul>

<h2 id="routing">Routing</h2>

<p>Symfony provides a <a href="http://symfony.com/doc/current/components/routing/introduction.html">Routing component</a>
which allows us, for a HTTP request/URL, to execute a specific function (also known as "Controller").</p>

<blockquote>
  <p><strong>Note</strong>: Controllers must be a <a href="http://php.net/manual/en/language.types.callable.php">callable</a>,
  for example:</p>
  
  <ul>
  <li>an anonymous function: <code>$controller = function (Request $request) { return new Response() };</code>.</li>
  <li>an array with an instance of a class and a method name:
  <code>$controller = array($controller, 'searchArticles');</code>.</li>
  <li>a fully qualified classname with a static method name:
  <code>$controller = 'Vendor\Project\Controller\ArticleController::searchArticles'</code>.</li>
  </ul>
  
  <p>Controllers can take a Request argument and should return a Response instance.</p>
</blockquote>

<p>It revolves around the following interface:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\Routing\Matcher;

use Symfony\Component\Routing\Exception\ResourceNotFoundException;
use Symfony\Component\Routing\Exception\MethodNotAllowedException;

interface UrlMatcherInterface
{
    /**
     * @param string $pathinfo
     *
     * @return array Route parameters (also contains `_route`)
     *
     * @throws ResourceNotFoundException
     * @throws MethodNotAllowedException
     */
    public function match($pathinfo);
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: For brevity the interface has been stripped from <code>RequestContextAwareInterface</code>.</p>
</blockquote>

<p>In actual applications we don't need to implement it as the component provides
a nice implementation that works with <code>RouteCollection</code>:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\Routing\RouteCollection;
use Symfony\Component\Routing\Route;

$collection = new RouteCollection();
$collection-&gt;add('search_articles', new Route('/v1/articles', array(
    '_controller' =&gt; 'Vendor\Project\Controller\ArticleController::search',
), array(), array(), '', array(), array('GET', 'HEAD')));

$collection-&gt;add('edit_article', new Route('/v1/articles/{id}', array(
    '_controller' =&gt; 'Vendor\Project\Controller\ArticleController::edit',
), array(), array(), '', array(), array('PUT')));
</code></pre>

<p><code>RouteCollection</code> allows us to configure which Request will match our controllers:
via URL patterns and Request method. It also allows us to specify parts of the URLs
as URI parameters (e.g. <code>id</code> in the above snippet).</p>

<p>Building route configuration by interacting with PHP code can be tedious, so the
Routing component supports alternative configuration formats: annotations, XML, YAML, etc.</p>

<blockquote>
  <p><strong>Tip</strong>: have a look at <code>Symfony\Component\Routing\Loader\YamlFileLoader</code>.</p>
</blockquote>

<h2 id="yaml">YAML</h2>

<p>Symfony provides a <a href="http://symfony.com/doc/current/components/yaml/introduction.html">YAML component</a>
which allows us to convert YAML configuration into PHP arrays (and vice versa).</p>

<p>For example the following YAML file:</p>

<pre><code># /tmp/routing.yml
search_articles:
    path: /api/articles
    defaults:
        _controller: 'Vendor\Project\Controller\ArticleController::search'
    methods:
        - GET
        - HEAD

edit_article:
    path: '/api/articles/{id}'
    defaults:
        _controller: 'Vendor\Project\Controller\ArticleController::edit'
    methods:
        - PUT
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Some string values must be escaped using single quotes because the YAML
  has a list of <a href="http://stackoverflow.com/a/22235064">reserved characters</a>, including:
  <code>@</code>, <code>%</code>, <code>\</code>, <code>-</code>, <code>:</code> <code>[</code>, <code>]</code>, <code>{</code> and <code>}</code>.</p>
</blockquote>

<p>Can be converted using:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\Yaml\Yaml;

$routing = Yaml::parse(file_get_contents('/tmp/routing.yml'));
</code></pre>

<p>This will result in the equivalent of the following array:</p>

<pre><code class="php">&lt;?php

$routing = array(
    'search_articles' =&gt; array(
        'path' =&gt; '/api/articles',
        'defaults' =&gt; array(
            '_controller' =&gt; 'Vendor\Project\Controller\ArticleController::search',
        ),
        'methods' =&gt; array(
            'GET',
            'HEAD',
        ),
    ),
    'edit_article' =&gt; array(
        'path' =&gt; '/api/articles/{id}',
        'defaults' =&gt; array(
            '_controller' =&gt; 'Vendor\Project\Controller\ArticleController::edit',
        ),
        'methods' =&gt; array(
            'PUT',
        ),
    ),
);
</code></pre>

<blockquote>
  <p><strong>Note</strong>: the Routing component uses another component to then build <code>RouteCollection</code>
  from this array: the <a href="http://symfony.com/doc/current/components/config/introduction.html">Config component</a>
  which is out of the scope of this guide.</p>
</blockquote>

<p>There's also <code>$yaml = Yaml::dump($array);</code> that converts a PHP array into a YAML
string.</p>

<h2 id="conclusion">Conclusion</h2>

<p>The Routing component allows us to define which Controllers should be executed
for the given Request, and the Yaml component allows us to configure it in a simple way.</p>

<p>HttpKernel provides a <code>RouterListener</code> which makes use of <code>UrlMatcher</code> when the
Request is received to find a corresponding controller.</p>

<blockquote>
  <p><strong>Note</strong>: <code>Request-&gt;attributes</code> is used to store information about the current
  Request such as the matched route, the controller, etc. It's used internally
  by Symfony but we could also store our own values in it.</p>
</blockquote>

<p>Some might be concerned with performance: reading the configuration from the
filesystem may slow down the application.</p>

<p>Don't panic! There's a <code>PhpMatcherDumper</code> class which can generate an implementation
of <code>UrlMatcherInterface</code> with all configuration in an optimized way. It might look
like this:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\Routing\Exception\MethodNotAllowedException;
use Symfony\Component\Routing\Exception\ResourceNotFoundException;
use Symfony\Component\Routing\RequestContext;

class appDevUrlMatcher extends Symfony\Bundle\FrameworkBundle\Routing\RedirectableUrlMatcher
{
    public function __construct(RequestContext $context)
    {
        $this-&gt;context = $context;
    }

    public function match($pathinfo)
    {
        $allow = array();
        $pathinfo = rawurldecode($pathinfo);
        $context = $this-&gt;context;

        // edit_article
        if (preg_match('#^/v1/articles/(?P&lt;id&gt;[^/]++)$#s', $pathinfo, $matches)) {
            if ($this-&gt;context-&gt;getMethod() != 'PUT') {
                $allow[] = 'PUT';
                goto not_edit_article;
            }

            return $this-&gt;mergeDefaults(array_replace($matches, array('_route' =&gt; 'edit_article')), array (  '_controller' =&gt; 'Vendor\Project\Controller\ArticleController::edit',));
        }
        not_edit_article:

        // search_articles
        if ($pathinfo === '/v1/articles') {
            if (!in_array($this-&gt;context-&gt;getMethod(), array('GET', 'HEAD'))) {
                $allow = array_merge($allow, array('GET', 'HEAD'));
                goto not_search_articles;
            }

            return array (  '_controller' =&gt; 'app.article_controller:search',  '_route' =&gt; 'Vendor\Project\Controller\ArticleController::search',);
        }
        not_search_articles:

        throw 0 &lt; count($allow) ? new MethodNotAllowedException(array_unique($allow)) : new ResourceNotFoundException();
    }
}
</code></pre>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[The Ultimate Developer Guide to Symfony - Event Dispatcher]]></title>
            <link href="https://gnugat.github.io/2016/02/10/ultimate-symfony-event-dispatcher.html"/>
            <updated>2016-02-10T00:00:00+00:00</updated>
            <id>https://gnugat.github.io/2016/02/10/ultimate-symfony-event-dispatcher.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Reference</strong>: This article is intended to be as complete as possible and is
  kept up to date.</p>
  
  <p><strong>TL;DR</strong>:</p>

<pre><code class="php">$eventDispatcher-&gt;addListener($eventName, $listener1, $priority);
$eventDispatcher-&gt;addListener($eventName, $listener2, $priority - 1);
$eventDispatcher-&gt;dispatch($eventName); // Calls $listener1, then $listener2
</code></pre>
</blockquote>

<p>In this guide we explore the standalone libraries (also known as "Components")
provided by <a href="http://symfony.com">Symfony</a> to help us build applications.</p>

<p>We've already seen:</p>

<ul>
<li><a href="/2016/02/03/ultimate-symfony-http-kernel.html">HTTP Kernel and HTTP Foundation</a></li>
</ul>

<p>We're now about to check Event Dispatcher, then in the next articles we'll have a look at:</p>

<ul>
<li><a href="/2016/02/17/ultimate-symfony-routing.html">Routing and YAML</a></li>
<li><a href="/2016/02/24/ultimate-symfony-dependency-injection.html">Dependency Injection</a></li>
<li><a href="/2016/03/02/ultimate-symfony-console.html">Console</a></li>
</ul>

<h2 id="event-dispatcher">Event Dispatcher</h2>

<p>Symfony provides an <a href="http://symfony.com/doc/current/components/event_dispatcher/introduction.html">EventDispatcher component</a>
which allows the execution of registered function at key points in our applications.</p>

<p>It revolves around the following interface:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\EventDispatcher;

interface EventDispatcherInterface
{
    /**
     * @param string   $eventName
     * @param callable $listener
     * @param int      $priority  High priority listeners will be executed first
     */
    public function addListener($eventName, $listener, $priority = 0);

    /**
     * @param string $eventName
     * @param Event  $event
     */
    public function dispatch($eventName, Event $event = null);
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: This snippet is a truncated version, the actual interface has methods
  to add/remove/get/check listeners and subscribers (which are "auto-configured" listeners).</p>
</blockquote>

<p>An implementation is provided out of the box and can be used as follow:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\EventDispatcher\EventDispatcher;

$eventDispatcher = new EventDispatcher();

$eventDispatcher-&gt;addListener('something_happened', function () {
    echo "Log it\n";
}, 1);
$eventDispatcher-&gt;addListener('something_happened', function () {
    echo "Save it\n";
}, 2);

$eventDispatcher-&gt;dispatch('something_happened');
</code></pre>

<p>This will output:</p>

<pre><code>Save it
Log it
</code></pre>

<p>Since the second listener had a higher priority, it got executed first.</p>

<blockquote>
  <p><strong>Note</strong>: Listeners must be a <a href="http://php.net/manual/en/language.types.callable.php">callable</a>,
  for example:</p>
  
  <ul>
  <li>an anonymous function: <code>$listener = function (Event $event) {};</code>.</li>
  <li>an array with an instance of a class and a method name:
  <code>$listener = array($service, 'method');</code>.</li>
  <li>a fully qualified classname with a static method name:
  <code>$listener = 'Vendor\Project\Service::staticMethod'</code>.</li>
  </ul>
</blockquote>

<p>If we want to provide some context to the listeners (parameters, etc) we can
create a sub-class of <code>Event</code>:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\EventDispatcher\Event;
use Symfony\Component\EventDispatcher\EventDispatcher;

class SomethingHappenedEvent extends Event
{
    private $who;
    private $what;
    private $when;

    public function __construct($who, $what)
    {
        $this-&gt;who = $who;
        $this-&gt;what = $what;
        $this-&gt;when = new \DateTime();
    }

    public function who()
    {
        return $this-&gt;who;
    }

    public function what()
    {
        return $this-&gt;what;
    }

    public function when()
    {
        return $this-&gt;when;
    }
}

$eventDispatcher = new EventDispatcher();

$eventDispatcher-&gt;addListener('something_happened', function (SomethingHappenedEvent $event) {
    echo "{$event-&gt;who()} was {$event-&gt;what()} at {$event-&gt;when()-&gt;format('Y/m/d H:i:s')}\n";
});

$eventDispatcher-&gt;dispatch('something_happened', new SomethingHappenedEvent('Arthur', 'hitchhiking'));
</code></pre>

<h2 id="httpkernel-example">HttpKernel example</h2>

<p>The HttpKernel component we've seen in <a href="/2016/02/03/ultimate-symfony-http-kernel.html">the previous article</a>
provides a <code>Kernel</code> abstract class that heavily relies on EventDispatcher.</p>

<p>For each key steps of its execution, it dispatches the following events:</p>

<ol>
<li><code>kernel.request</code>: gets a <code>Request</code></li>
<li><code>kernel.controller</code>: executes a callable (also known as "Controller")</li>
<li><code>kernel.view</code>: converts the Controller's returned value into a <code>Response</code> (if necessary)</li>
<li><code>kernel.response</code>: returns a <code>Response</code></li>
</ol>

<p>And in case of error:</p>

<ul>
<li><code>kernel.exception</code>: handles errors</li>
</ul>

<p>Just before returning the <code>Response</code>, <code>HttpKernel</code> dispatches one last event:</p>

<ul>
<li><code>kernel.finish_request</code>: clean ups, sending emails, etc</li>
</ul>

<p>After the <code>Response</code> has been displayed, we can dispatch:</p>

<ul>
<li><code>kernel.terminate</code>: same as <code>kernel.finish_request</code>, except it won't slow down
the rendering of request if FastCGI is enabled</li>
</ul>

<h3 id="kernel-request">Kernel Request</h3>

<p>Listeners that registered for <code>kernel.request</code> can modify the Request object.</p>

<p>Out of the box there's a <code>RouterListener</code> registered which sets the following
parameters in <code>Request-&gt;attributes</code>:</p>

<ul>
<li><code>_route</code>: the route name that matched the Request</li>
<li><code>_controller</code>: a callable that will handle the Request and return a Response</li>
<li><code>_route_parameters</code>: query parameters extracted from the Request</li>
</ul>

<p>An example of a custom Listener could be one that decodes JSON content and sets
it in <code>Request-&gt;request</code>:</p>

<pre><code class="php">&lt;?php

namespace AppBundle\EventListener;

use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Event\GetResponseEvent;

/**
 * PHP does not populate $_POST with the data submitted via a JSON Request,
 * causing an empty $request-&gt;request.
 *
 * This listener fixes this.
 */
class JsonRequestContentListener
{
    /**
     * @param GetResponseEvent $event
     */
    public function onKernelRequest(GetResponseEvent $event)
    {
        $request = $event-&gt;getRequest();
        $hasBeenSubmited = in_array($request-&gt;getMethod(), array('PATCH', 'POST', 'PUT'), true);
        $isJson = (1 === preg_match('#application/json#', $request-&gt;headers-&gt;get('Content-Type')));
        if (!$hasBeenSubmited || !$isJson) {
            return;
        }
        $data = json_decode($request-&gt;getContent(), true);
        if (JSON_ERROR_NONE !== json_last_error()) {
            $event-&gt;setResponse(new Response('{"error":"Invalid or malformed JSON"}', 400, array('Content-Type' =&gt; 'application/json')));
        }
        $request-&gt;request-&gt;add($data ?: array());
    }
}
</code></pre>

<p>Another example would be to start a database transaction:</p>

<pre><code class="php">&lt;?php

namespace AppBundle\EventListener;

use PommProject\Foundation\QueryManager\QueryManagerInterface;
use Symfony\Component\HttpKernel\Event\GetResponseEvent;

class StartTransactionListener
{
    /**
     * @var QueryManagerInterface
     */
    private $queryManager;

    /**
     * @param QueryManagerInterface $queryManager
     */
    public function __construct(QueryManagerInterface $queryManager)
    {
        $this-&gt;queryManager = $queryManager;
    }

    /**
     * @param GetResponseEvent $event
     */
    public function onKernelRequest(GetResponseEvent $event)
    {
        $this-&gt;queryManager-&gt;query('START TRANSACTION');
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: <a href="http://pomm-project.org">Pomm</a> is used here as an example.</p>
</blockquote>

<h3 id="kernel-controller">Kernel Controller</h3>

<p>Listeners that registered for <code>kernel.controller</code> can modify the Request object.</p>

<p>This can be useful when we'd like to change the Controller.</p>

<p>For example <code>SensioFrameworkExtraBundle</code> has a <code>ControllerListener</code> that parses
the controller annotations at this point.</p>

<h3 id="kernel-view">Kernel View</h3>

<p>Listeners that registered for <code>kernel.view</code> can modify the Response object.</p>

<p>For example <code>SensioFrameworkExtraBundle</code> has a <code>TemplateListener</code> that uses <code>@Template</code>
annotation: controllers only need to return an array and the listener will create
a response using <a href="http://twig.sensiolabs.org/">Twig</a> (it will pass the array as
Twig parameters).</p>

<h3 id="kernel-response">Kernel Response</h3>

<p>Listeners that registered for <code>kernel.response</code> can modify the Response object.</p>

<p>Out of the box there's a <code>ResponseListener</code> regitered which sets some Response
headers according to the Request's one.</p>

<h3 id="kernel-terminate">Kernel Terminate</h3>

<p>Listeners that registered for <code>kernel.terminate</code> can execute actions after the
Response has been served (if our web server uses FastCGI).</p>

<p>An example of a custom Listener could be one that rollsback a database transaction,
when running in test environment:</p>

<pre><code class="php">&lt;?php

namespace AppBundle\EventListener\Pomm;

use PommProject\Foundation\QueryManager\QueryManagerInterface;
use Symfony\Component\HttpKernel\Event\PostResponseEvent;

class RollbackListener
{
    /**
     * @var QueryManagerInterface
     */
    private $queryManager;

    /**
     * @param QueryManagerInterface $queryManager
     */
    public function __construct(QueryManagerInterface $queryManager)
    {
        $this-&gt;queryManager = $queryManager;
    }

    /**
     * @param PostResponseEvent $event
     */
    public function onKernelTerminate(PostResponseEvent $event)
    {
        $this-&gt;queryManager-&gt;query('ROLLBACK');
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: We'll se later how to register this listener only for test environment.</p>
</blockquote>

<h3 id="kernel-exception">Kernel Exception</h3>

<p>Listeners that registered for <code>kernel.exception</code> can catch an exception and generate
an appropriate Response object.</p>

<p>An example of a custom Listener could be one that logs debug information and generates
a 500 Response:</p>

<pre><code class="php">&lt;?php

namespace AppBundle\EventListener;

use Psr\Log\LoggerInterface;
use Ramsey\Uuid\Uuid;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Event\GetResponseForExceptionEvent;

class ExceptionListener
{
    /**
     * @var LoggerInterface
     */
    private $logger;

    /**
     * @param LoggerInterface $logger
     */
    public function __construct(LoggerInterface $logger)
    {
        $this-&gt;logger = $logger;
    }

    /**
     * @param GetResponseForExceptionEvent $event
     */
    public function onKernelException(GetResponseForExceptionEvent $event)
    {
        $exception = $event-&gt;getException();
        $token = Uuid::uuid4()-&gt;toString();
        $this-&gt;logger-&gt;critical(
            'Caught PHP Exception {class}: "{message}" at {file} line {line}',
            array(
                'class' =&gt; get_class($exception),
                'message' =&gt; $exception-&gt;getMessage(),
                'file' =&gt; $exception-&gt;getFile(),
                'line' =&gt; $exception-&gt;getLine()
                'exception' =&gt; $exception,
                'token' =&gt; $token
            )
        );
        $event-&gt;setResponse(new Response(
            json_encode(array(
                'error' =&gt; 'An error occured, if it keeps happening please contact an administrator and provide the following token: '.$token,
            )),
            500,
            array('Content-Type' =&gt; 'application/json'))
        );
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: <a href="https://benramsey.com/projects/ramsey-uuid/">Ramsey UUID</a> is used
  here to provide a unique token that can be referred to.</p>
</blockquote>

<h2 id="conclusion">Conclusion</h2>

<p>EventDispatcher is another example of a simple yet powerful Symfony component.
HttpKernel uses it to configure a standard "Symfony application", but also to
allow us to change its behaviour.</p>

<p>In this article we've seen the basics and how it works behind the hood when used
by HttpKernel, but we could create our own event and dispatch it to make our
own code "Open for extension, but Close to modification"
(<a href="https://blog.8thlight.com/uncle-bob/2014/05/12/TheOpenClosedPrinciple.html">Open/Close principle</a>).</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[The Ultimate Developer Guide to Symfony - HTTP Kernel]]></title>
            <link href="https://gnugat.github.io/2016/02/03/ultimate-symfony-http-kernel.html"/>
            <updated>2016-02-03T00:00:00+00:00</updated>
            <id>https://gnugat.github.io/2016/02/03/ultimate-symfony-http-kernel.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Reference</strong>: This article is intended to be as complete as possible and is
  kept up to date.</p>
  
  <p><strong>TL;DR</strong>: <code>$response = $httpKernel-&gt;handle($request);</code></p>
</blockquote>

<p><a href="http://symfony.com">Symfony</a> provides many standalone libraries (also known as
"Components") that help us build applications.</p>

<p>In this guide we'll see the main ones that allow us to build an application:</p>

<ul>
<li>HTTP Kernel and HTTP Foundation</li>
<li><a href="/2016/02/10/ultimate-symfony-event-dispatcher.html">Event Dispatcher</a></li>
<li><a href="/2016/02/17/ultimate-symfony-routing.html">Routing and YAML</a></li>
<li><a href="/2016/02/24/ultimate-symfony-dependency-injection.html">Dependency Injection</a></li>
<li><a href="/2016/03/02/ultimate-symfony-console.html">Console</a></li>
</ul>

<h2 id="http-kernel">HTTP kernel</h2>

<p>Symfony provides a <a href="http://symfony.com/doc/current/components/http_kernel/introduction.html">HttpKernel component</a>
which follows the HTTP protocol: it converts a <code>Request</code> into a <code>Response</code>.</p>

<p>It all revolves around the following interface:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\HttpKernel;

use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

interface HttpKernelInterface
{
    const MASTER_REQUEST = 1;
    const SUB_REQUEST = 2;

    /**
     * @param Request $request
     * @param int     $type
     * @param bool    $catch   Whether to catch exceptions or not
     *
     * @return Response
     */
    public function handle(Request $request, $type = self::MASTER_REQUEST, $catch = true);
}
</code></pre>

<h2 id="httpfoundation">HttpFoundation</h2>

<p>HttpKernel relies on the <a href="http://symfony.com/doc/current/components/http_foundation/introduction.html">HttpFoundation component</a>
which mainly provides:</p>

<ul>
<li><code>Request</code>: wraps <code>$_GET</code>, <code>$_POST</code>, <code>$_COOKIE</code>, <code>$_FILES</code> and <code>$_SERVER</code></li>
<li><code>Response</code>: wraps <code>header()</code> and <code>setcookie()</code>, but also displays the content</li>
</ul>

<blockquote>
  <p><strong>Note</strong>: Global variables have the drawback to be possibly accessed by many
  functions, causing their state to be unpredictable (hence bugs happen and they
  are hard to find/understand).</p>
  
  <p>With HttpFoundation, <a href="http://php.net/manual/en/language.variables.superglobals.php">PHP super globals</a>
  shouldn't be accessed directly, but rather via the objects that wraps them
  (e.g. <code>Request</code>) which are passed around (those objects are not global).</p>
</blockquote>

<p>Here's a typical usage:</p>

<pre><code class="php">$request = Request::createFromGlobals();
$response = $httpKernel-&gt;handle($request);
$reponse-&gt;send();
</code></pre>

<p>In the above example, <code>Request</code> will be initialized using PHP super globals.
Sometimes it can be useful to build it with our own provided values (e.g. for tests):</p>

<pre><code class="php">$uri = '/v1/items';
$method = 'POST';
$parameters = array(); // GET or POST parameters, usually left unused (use uri and content instead)
$cookies = array();
$files = array();
$headers = array('CONTENT_TYPE' =&gt; 'application/json');
$content = json_encode(array('name' =&gt; 'Arthur Dent'));

$request = Request::create($uri, $method, $getOrPostParameters, $cookies, $files, $headers, $content);
</code></pre>

<p>In our application, we'll mainly extract its parameters:</p>

<pre><code class="php">$getParameter = $request-&gt;query-&gt;get('description'); // e.g. from URI `/?description=hitchhicker`
$postParameter = $request-&gt;request-&gt;get('name'); // e.g. from content `name=Arthur`
$header = $request-&gt;headers-&gt;get('Content-Type'); // e.g. from headers `Content-Type: application/x-www-form-urlencoded`

$customParameter = $request-&gt;attributes-&gt;get('_route'); // We'll see more about it in the next article
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Those public properties are instances of <code>Symfony\Component\HttpFoundation\ParameterBag</code>,
  except <code>headers</code> which is an instance of <code>Symfony\Component\HttpFoundation\HeaderBag</code>.</p>
</blockquote>

<p>In our application we'll mainly build <code>Response</code>:</p>

<pre><code class="php">$content = json_encode(array('name' =&gt; 'Arthur Dent'));
$status = 201;
$headers = array('Content-Type' =&gt; 'application/json');

$response = new Reponse($content, $status, $headers);
</code></pre>

<p>HttpFoundation also wraps <code>$_SESSION</code> in a convenient <code>Session</code> object. This one
is however out of the scope of this series, to find more about it have a look at
<a href="/2014/04/23/sf2-sessions-introduction.html">Symfony Session Introduction</a>.</p>

<h2 id="example">Example</h2>

<p>Let's create a small Hello World example:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\HttpKernel\HttpKernelInterface;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class HelloWorldHttpKernel implements HttpKernelInterface
{
    public function handle(Request $request, $type = self::MASTER_REQUEST, $catch = true)
    {
        $name = $request-&gt;query-&gt;get('name', 'World');

        return new Response("Hello $name!", 200);
    }
}

$httpKernel = new HelloWorldHttpKernel();

$request = Request::createFromGlobals();
$response = $httpKernel-&gt;handle($request);
$response-&gt;send();
</code></pre>

<p>So we can get the following:</p>

<ul>
<li>for <code>/</code> URL, we get <code>Hello World!</code></li>
<li>for <code>/?name=Arthur</code> URL, we get <code>Hello Arthur!</code></li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>Symfony provides a simple yet powerful component allowing us to follow the HTTP
protocol.</p>

<p>In this article we've seen the basics and how it works behind the hood, but in
an actual application we don't necessarily need to create our own implementation
of <code>HttpKernelInterface</code>.</p>

<p>Indeed there's a <code>Symfony\Component\HttpKernel\Kernel</code> abstract class that can
be used out of the box. It provides many features that we'll explore in the next
articles:</p>

<ul>
<li><a href="/2016/02/10/ultimate-symfony-event-dispatcher.html">Event Dispatcher</a></li>
<li><a href="/2016/02/17/ultimate-symfony-routing.html">Routing and YAML</a></li>
<li><a href="/2016/02/24.ultimate-symfony-dependency-injection.html">Dependency Injection</a></li>
</ul>
]]></content>
        </entry>
    </feed>