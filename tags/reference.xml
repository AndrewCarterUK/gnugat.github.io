<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[Loïc Faugeron]]></title>
    <link href="https://gnugat.github.io/feed/atom.xml" rel="self"/>
    <link href="https://gnugat.github.io/"/>
    <updated>2016-03-09T08:32:43+00:00</updated>
    <id>http://gnugat.github.com</id>
            <author>
            <name><![CDATA[Loïc Faugeron]]></name>            <email><![CDATA[faugeron.loic@gmail.com]]></email>        </author>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[The Ultimate Developer Guide to Symfony - Bundle]]></title>
            <link href="https://gnugat.github.io/2016/03/09/ultimate-symfony-bundle.html"/>
            <updated>2016-03-09T00:00:00+00:00</updated>
            <id>https://gnugat.github.io/2016/03/09/ultimate-symfony-bundle.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Reference</strong>: This article is intended to be as complete as possible and is
  kept up to date.</p>
  
  <p><strong>TL;DR</strong>: Configure services from a third party library in a Bundle.</p>
</blockquote>

<p>In this guide we've explored the main standalone libraries (also known as "Components")
provided by <a href="http://symfony.com">Symfony</a> to help us build applications:</p>

<ul>
<li><a href="/2016/02/03/ultimate-symfony-http-kernel.html">HTTP Kernel and HTTP Foundation</a></li>
<li><a href="/2016/02/10/ultimate-symfony-event-dispatcher.html">Event Dispatcher</a></li>
<li><a href="/2016/02/17/ultimate-symfony-routing.html">Routing and YAML</a></li>
<li><a href="/2016/02/24/ultimate-symfony-dependency-injection.html">Dependency Injection</a></li>
<li><a href="/2016/03/02/ultimate-symfony-console.html">Console</a></li>
</ul>

<p>In this article, we're going to have a closer look at how HttpKernel enables reusable code.</p>

<h2 id="httpkernel-vs-kernel">HttpKernel vs Kernel</h2>

<p>The HttpKernel component provides two implementations for <code>HttpKernelInterface</code>.</p>

<p>The first one, <code>HttpKernel</code>, relies on Event Dispatcher and Routing to execute
the appropriate controller for the given Request.</p>

<p>And the second one, <code>Kernel</code>, relies on Dependency Injection and <code>HttpKernel</code>:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\HttpKernel;

use Symfony\Component\HttpFoundation\Request;

class Kernel implements HttpKernelInterface
{
    public function handle(Request $request, $type = HttpKernelInterface::MASTER_REQUEST, $catch = true)
    {
        if (false === $this-&gt;booted) {
            $this-&gt;boot();
        }

        return $this-&gt;container-&gt;get('http_kernel')-&gt;handle($request, $type, $catch);
    }

    public function boot()
    {
        // Initializes the container
    }

    abstract public function registerBundles();
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: For brevity's sake, <code>Kernel</code> has been heavily truncated.</p>
</blockquote>

<p>Initialization of the container includes:</p>

<ol>
<li>retrieving all "bundles"</li>
<li>creating a <code>ContainerBuilder</code></li>
<li>for each bundles:

<ol>
<li>registering its <code>ExtensionInterface</code> implementations in the container</li>
<li>registering its <code>CompilerPassInterface</code> implementations in the container</li>
</ol></li>
<li>dumping the container in an optimized implementation</li>
</ol>

<p>Once the container is initialized, <code>Kernel</code> expects it to contain a <code>http_kernel</code>
service to which it will delegate the actual HTTP work.</p>

<h2 id="bundle">Bundle</h2>

<p>A bundle is a package that contains <code>ExtensionInterface</code> and <code>CompilerPassInterface</code>
implementations, to configure a Dependency Injection container. It can be summed
up by this interface:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\HttpKernel\Bundle;

use Symfony\Component\DependencyInjection\ContainerBuilder;

interface BundleInterface
{
    // Adds CompilerPassInterface implementations to the container
    public function build(ContainerBuilder $container);

    // Returs an ExtensionInterface implementation, which will be registered in the container
    public function getContainerExtension();
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Once again, this interface has been truncated for brevity's sake.</p>
</blockquote>

<p>Bundles are usually created for one of the following purposes:</p>

<ul>
<li>define a third party library's classes as Dependency Injection services (e.g.
<a href="https://github.com/thephpleague/tactician-bundle">TacticianBundle</a>
for <a href="https://tactician.thephpleague.com/">Tactician</a>
which provides a <a href="http://shawnmc.cool/command-bus">CommandBus</a>,
<a href="https://github.com/symfony/monolog-bundle">MonologBundle</a>
for <a href="https://github.com/Seldaek/monolog">Monolog</a>
which provies a <a href="http://www.php-fig.org/psr/psr-3/">PSR-3</a> compliant logger,
etc)</li>
<li>define an application's classes as Dependency Injection services (usually named AppBundle)</li>
<li>create a framework (e.g.
user management with <a href="https://github.com/FriendsOfSymfony/FOSUserBundle">FOSUserBundle</a>,
admin generator with <a href="https://sonata-project.org/bundles/admin/2-3/doc/index.html">SonataAdminBundle</a>,
etc)</li>
</ul>

<blockquote>
  <p><strong>Note</strong>: regarding the last category, please read <a href="http://jolicode.com/blog/do-not-use-fosuserbundle">composer require technical-debt-bundle</a>.</p>
</blockquote>

<p>Bundles follow <a href="http://symfony.com/doc/current/cookbook/bundles/best_practices.html">by convention</a>
the following directory tree:</p>

<pre><code>.
├── Command
├── Controller
├── DependencyInjection
│   └── CompilerPass
├── EventListener
├── Resources
│   └── config
│       └── services
│           └── some_definitions.yml
├── Tests
└── VendorProjectBundle.php
</code></pre>

<h2 id="nanoframeworkbundle-example">NanoFrameworkBundle example</h2>

<p>Since HttpKernel component is a third party library, we're going to create a
bundle to provide its classes as Dependency Injection services. This is also a
good opportunity to have a look at how a Symfony application works behind the hood.</p>

<p>NanoFrameworkBundle's purpose is to provides a <code>http_kernel</code> service that can be
used by <code>Kernel</code>. First let's create a directory:</p>

<pre><code>mkdir nano-framework-bundle
cd nano-framework-bundle
</code></pre>

<p>Then we can create an implementation of <code>BundleInterface</code>:</p>

<pre><code class="php">&lt;?php
// VendorNanoFrameworkBundle.php

namespace Vendor\NanoFrameworkBundle;

use Symfony\Component\HttpKernel\Bundle\Bundle;

class VendorNanoFrameworkBundle extends Bundle
{
}
</code></pre>

<h3 id="bundle-extension">Bundle extension</h3>

<p>To be able to load Dependency Injection configuration, we'll create an
implementation of <code>ExtensionInterface</code>:</p>

<pre><code class="php">&lt;?php
// DependencyInjection/VendorNanoFrameworkExtension.php

namespace Vendor\NanoFrameworkBundle\DependencyInjection;

use Symfony\Component\Config\FileLocator;
use Symfony\Component\Config\Loader\LoaderResolver;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\DirectoryLoader;
use Symfony\Component\DependencyInjection\Loader\YamlFileLoader;
use Symfony\Component\HttpKernel\DependencyInjection\Extension;

class VendorNanoFrameworkExtension extends Extension
{
    public function load(array $configs, ContainerBuilder $container)
    {
        $fileLocator = new FileLocator(__DIR__.'/../Resources/config');
        $loader = new DirectoryLoader($container, $fileLocator);
        $loader-&gt;setResolver(new LoaderResolver(array(
            new YamlFileLoader($container, $fileLocator),
            $loader,
        )));
        $loader-&gt;load('services/');
    }
}
</code></pre>

<p>Once done, we can create the configuration:</p>

<pre><code># Resources/config/services/http_kernel.yml
services:
    http_kernel:
        class: Symfony\Component\HttpKernel\HttpKernel
        arguments:
            - "@event_dispatcher"
            - "@controller_resolver"
            - "@request_stack"

    event_dispatcher:
        class: Symfony\Component\EventDispatcher\EventDispatcher

    controller_resolver:
        class: Symfony\Component\HttpKernel\Controller\ControllerResolver
        public: false

    request_stack:
        class: Symfony\Component\HttpFoundation\RequestStack
</code></pre>

<h3 id="bundle-compiler-pass">Bundle compiler pass</h3>

<p>In order to register event listeners in EventDispatcher in a way that doesn't
require us to edit <code>Resources/config/services/http_kernel.yml</code>, we're going to
create an implementation of <code>CompilerInterface</code>:</p>

<pre><code class="php">&lt;?php
// DependencyInjection/CompilerPass/AddListenersPass.php

namespace Vendor\NanoFrameworkBundle\DependencyInjection;

use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Compiler\CompilerPassInterface;
use Symfony\Component\DependencyInjection\Reference;

class AddListenersPass implements CompilerPassInterface
{
    public function process(ContainerBuilder $container)
    {
        $eventDispatcher = $container-&gt;findDefinition('event_dispatcher');
        $eventListeners = $container-&gt;findTaggedServiceIds('kernel.event_listener');
        foreach ($eventListeners as $id =&gt; $events) {
            foreach ($events as $event) {
                $eventDispatcher-&gt;addMethodCall('addListener', array(
                    $event['event'],
                    array(new Reference($id), $event['method']),
                    isset($event['priority']) ? $event['priority'] : 0;
                ));
            }
        }
    }
}
</code></pre>

<p>With this, we only need to add a tag with:</p>

<ul>
<li>a <code>kernel.event_listener</code> name</li>
<li>an event to listen to (e.g. <code>kernel.request</code>)</li>
<li>a method to call (e.g. <code>onKernelRequest</code>)</li>
<li>optionally a priority (default to <code>0</code>, the greater the sooner it will be executed)</li>
</ul>

<p>To complete the step, we need to register it in our bundle:</p>

<pre><code class="php">&lt;?php
// VendorNanoFrameworkBundle.php

namespace Vendor\NanoFrameworkBundle;

use Symfony\Component\HttpKernel\Bundle\Bundle;
use Vendor\NanoFrameworkBundle\DependencyInjection\CompilerPass\AddListenersPass;

class VendorNanoFrameworkBundle extends Bundle
{
    public function build(ContainerBuilder $container)
    {
        parent::build($container);

        $container-&gt;addCompilerPass(new AddListenersPass());
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: While <code>CompilerPassInterface</code> implementations need to be registered
  explicitly, there is no need to do anything for <code>ExtensionInterface</code> implementations
  as <code>Bundle</code> contains a method able to locate it, based on the following conventions:</p>
  
  <ul>
  <li>it needs to be in <code>DependencyInjection</code> directory</li>
  <li>it needs to be named after the bundle name (replace <code>Bundle</code> suffix by <code>Extension</code>)</li>
  <li>it needs to implement <code>ExtensionInterface</code></li>
  </ul>
</blockquote>

<h3 id="more-configuration">More configuration</h3>

<p>HttpKernel relies on event listeners for the routing, in order to enable it we
need to add the following configuration:</p>

<pre><code># Resources/config/services/routing.yml
services:
    router_listener:
        class: Symfony\Component\HttpKernel\EventListener\RouterListener
        arguments:
            - "@router"
            - "@request_stack"
            - "@router.request_context"
        tags:
            - { name: kernel.event_listener, event: kernel.request, method: onKernelRequest, priority: 32 }

    router:
        class: Symfony\Component\Routing\Router
        public: false
        arguments:
            - "@routing.loader"
            - "%kernel.root_dir%/config/routings"
            - "%router.options%"
            - "@router.request_context"
        calls:
            - [setConfigCacheFactory, ["@config_cache_factory"]]

    routing.loader:
        class: Symfony\Component\Config\Loader\DelegatingLoader
        public: false
        arguments:
            - "@routing.resolver"

    routing.resolver:
        class: Symfony\Component\Config\Loader\LoaderResolver
        public: false
        calls:
            - [addLoader, ["@routing.loader.yml"]]

    router.request_context:
        class: Symfony\Component\Routing\RequestContext
        public: false

    config_cache_factory:
        class: Symfony\Component\Config\ResourceCheckerConfigCacheFactory
        public: false

    routing.loader.yml:
        class: Symfony\Component\Routing\Loader\YamlFileLoader
        public: false
        arguments:
            - "@file_locator"
</code></pre>

<h2 id="usage">Usage</h2>

<p>Since <code>Kernel</code> is an abstract class, we need to create an implementation (usually
called AppKernel):</p>

<pre><code class="php">&lt;?php
// Tests/app/AppKernel.php

use Symfony\Component\HttpKernel\Kernel;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        return array(
            new Vendor\NanoFrameworkBundle\VendorNanoFrameworkBundle(),
        );
    }

    public function getRootDir()
    {
        return __DIR__;
    }

    public function getCacheDir()
    {
        return dirname(__DIR__).'/var/cache/'.$this-&gt;getEnvironment();
    }

    public function getLogDir()
    {
        return dirname(__DIR__).'/var/logs';
    }
}
</code></pre>

<p>Finally we need to create a "Front Controller" (a fancy name for <code>index.php</code>):</p>

<pre><code class="php">&lt;?php
// Tests/web/index.php

&lt;?php

use Symfony\Component\HttpFoundation\Request;

$kernel = new AppKernel('prod', false);
$request = Request::createFromGlobals();
$response = $kernel-&gt;handle($request);
$response-&gt;send();
$kernel-&gt;terminate($request, $response);
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Bundles enable us to define classes as Dependency Injection services, for our
applications and third part libraries in a reusable way.</p>

<p>In the example above we've created a bundle that provides a <code>http_kernel</code> service,
which can then be used to create Symfony applications. Here are some existing
bundles that do it for us:</p>

<ul>
<li><a href="https://github.com/symfony/framework-bundle">FrameworkBundle</a>, the official one
provided by Symfony. It comes with many services out of the box, mainly targeted
at full stack applications (it follows a "solve 80% of use cases" philosohpy)</li>
<li><a href="http://gnugat.github.io/micro-framework-bundle/">MicroFrameworkBundle</a>, an unofficial
one. It comes with the bare minimum (it follows a "add what you need" philosohpy)</li>
</ul>

<p>There are many bundles available, you can find them by checking
<a href="https://packagist.org/search/?q=symfony-bundle">symfony-bundle in Packagist</a>.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[The Ultimate Developer Guide to Symfony - Console]]></title>
            <link href="https://gnugat.github.io/2016/03/02/ultimate-symfony-console.html"/>
            <updated>2016-03-02T00:00:00+00:00</updated>
            <id>https://gnugat.github.io/2016/03/02/ultimate-symfony-console.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Reference</strong>: This article is intended to be as complete as possible and is
  kept up to date.</p>
  
  <p><strong>TL;DR</strong>: <code>$statusCode = $application-&gt;run($input);</code></p>
</blockquote>

<p>In this guide we explore the standalone libraries (also known as "Components")
provided by <a href="http://symfony.com">Symfony</a> to help us build applications.</p>

<p>We've already seen:</p>

<ul>
<li><a href="/2016/02/03/ultimate-symfony-http-kernel.html">HTTP Kernel and HTTP Foundation</a></li>
<li><a href="/2016/02/10/ultimate-symfony-event-dispatcher.html">Event Dispatcher</a></li>
<li><a href="/2016/02/17/ultimate-symfony-routing.html">Routing and YAML</a></li>
<li><a href="/2016/02/24/ultimate-symfony-dependency-injection.html">Dependency Injection</a></li>
</ul>

<p>We're now about to check the last one: Console.</p>

<h2 id="application">Application</h2>

<p>Symfony provides a <a href="http://symfony.com/doc/current/components/console/introduction.html">Console component</a>
which allows us to create CLI commands. Its main class is <code>Application</code>:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\Console;

use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Command\Command;

class Application
{
    public function __construct($name = 'UNKNOWN', $version = 'UNKNOWN');

    public function add(Command $command);
    public function setDefaultCommand($commandName);
    public function run(InputInterface $input = null, OutputInterface $output = null);

    public function setAutoExit($boolean);
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: This snippet is a truncated version. Please note that <code>Application</code>
  is (unfortunately) not an interface.</p>
</blockquote>

<p>We can create it as follow:</p>

<pre><code class="php">&lt;?php
// /tmp/console.php

use Symfony\Component\Console\Application;
use Symfony\Component\Console\Input\ArgvInput;

$application = new Application('My Application', 'v4.2.3');
$application-&gt;add($command);
$application-&gt;setDefaultCommand($command-&gt;getName());

$application-&gt;run(new ArgvInput());
</code></pre>

<p>Which can then be used as follow:</p>

<pre><code>php /tmp/console.php
</code></pre>

<blockquote>
  <p><strong>Note</strong>: After running the command, <code>Application</code> will automatically stop
  using <code>exit</code>.
  As it can sometimes be inconvenient (for example in tests), we can disable it
  with this line: <code>$application-&gt;setAutoExit(false);</code></p>
</blockquote>

<p>Out of the box, <code>Application</code> has two commands:</p>

<ul>
<li><code>list</code>, list all available commands (it's the default command if <code>setDefaultCommand</code> hasn't been used)</li>
<li><code>help</code>, displays a description with available arguments and options for the current command</li>
</ul>

<h2 id="command">Command</h2>

<p>In order for <code>Application</code> to be useful, we need to create commands. This can be
done by extending <code>Command</code>:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\Console\Command;

use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;

class Command
{
    public function run(InputInterface $input, OutputInterface $output);
    // Called by run
    protected function execute(InputInterface $input, OutputInterface $output);
    protected function interact(InputInterface $input, OutputInterface $output);

    protected function configure();
    // To be called in configure
    public function setName($name);
    public function addArgument($name, $mode = null, $description = '', $default = null);
    public function addOption($name, $shortcut = null, $mode = null, $description = '', $default = null);
    public function setDescription($description);
    public function setHelp($help);
    public function setAliases($aliases);
}
</code></pre>

<p>We can configure the command (name, arguments, options, description, etc) in the
<code>configure</code> method, we can define more options to be asked interractively in
the <code>interact</code> method (e.g. <code>Are you sure? (Y/n)</code>) and finally we can write the
command logic in the <code>execute</code> method.</p>

<p>Commands are to Console what Controllers are to HttpKernel: their responsibility
is to extract input parameters, pass them to a service and then put the service's
returned value in the output.</p>

<h2 id="input">Input</h2>

<p>Input parameters are wrapped in the following interface:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\Console\Input;

interface InputInterface
{
    public function getArgument($name);
    public function getOption($name);
}
</code></pre>

<p>Out of the box we have the following implementations:</p>

<ul>
<li><code>ArgvInput</code>: wraps CLI arguments comming from <code>$_SERVER['argv']</code></li>
<li><code>ArrayInput</code>: define arguments using an array, which is useful for tests</li>
</ul>

<p><code>Application</code> will take care of validating <code>InputInterface</code> parameters against
the <code>Command</code> configuration (e.g. if required arguments present).</p>

<h2 id="output">Output</h2>

<p>While <code>InputInterface</code> can be seen as a value object, <code>OutputInterface</code> should
be seen as a service able to send informations to a stream:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\Console\Output;

abstract class Output implements OutputInterface
{
    public function writeln($messages, $type = self::OUTPUT_NORMAL);
}
</code></pre>

<p>The <code>writeln</code> method allows us to write a new line (with a newline character at
the end). If the given message is an array, it will print each elements on a new
line.</p>

<p>The given message can contain tags (e.g. <code>Arthur &lt;info&gt;Dent&lt;/info&gt;</code>), which can
be used to format it. Out of the box it will color the followings:</p>

<ul>
<li>green text for informative messages (usage example: <code>&lt;info&gt;Arthur Dent&lt;/info&gt;</code>)</li>
<li>yellow text for comments (usage example: <code>&lt;comment&gt;Tricia McMillan&lt;/comment&gt;</code>)</li>
<li>black text on a cyan background for questions (usage example: <code>&lt;question&gt;Ford Prefect&lt;/question&gt;</code>)</li>
<li>white text on a red background for errors (usage example: <code>&lt;error&gt;Marvin&lt;/error&gt;</code>)</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>The Console component allows us to create CLI applications. Its Commands are a
thin layer which gathers the input and call services. Those services can then
output messages to the user.</p>

<blockquote>
  <p><strong>Note</strong>: Since Symfony follows a <a href="https://github.com/symfony/symfony-docs/issues/4265">Console Output Formating Style Guide</a>,
  the Console component provides the following helper class:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\Console\Style;

use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Question\Question;

class SymfonyStyle
{
    public function __construct(InputInterface $input, OutputInterface $output);

    public function block($messages, $type = null, $style = null, $prefix = ' ', $padding = false);
    public function title($message);
    public function section($message);
    public function listing(array $elements);
    public function text($message);

    public function comment($message);
    public function success($message);
    public function error($message);
    public function warning($message);
    public function note($message);
    public function caution($message);

    public function table(array $headers, array $rows);

    public function ask($question, $default = null, $validator = null);
    public function askHidden($question, $validator = null);
    public function confirm($question, $default = true);
    public function choice($question, array $choices, $default = null);
    public function askQuestion(Question $question);

    public function progressStart($max = 0);
    public function progressAdvance($step = 1);
    public function progressFinish();
    public function createProgressBar($max = 0);

    public function writeln($messages, $type = self::OUTPUT_NORMAL);
    public function write($messages, $newline = false, $type = self::OUTPUT_NORMAL);
    public function newLine($count = 1);
}
</code></pre>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[The Ultimate Developer Guide to Symfony - Dependency Injection]]></title>
            <link href="https://gnugat.github.io/2016/02/24/ultimate-symfony-dependency-injection.html"/>
            <updated>2016-02-24T00:00:00+00:00</updated>
            <id>https://gnugat.github.io/2016/02/24/ultimate-symfony-dependency-injection.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Reference</strong>: This article is intended to be as complete as possible and is
  kept up to date.</p>
  
  <p><strong>TL;DR</strong>: Make Dependency Injection easy by moving class construction in
  configuration files.</p>
</blockquote>

<p>In this guide we explore the standalone libraries (also known as "Components")
provided by <a href="http://symfony.com">Symfony</a> to help us build applications.</p>

<p>We've already seen:</p>

<ul>
<li><a href="/2016/02/03/ultimate-symfony-http-kernel.html">HTTP Kernel and HTTP Foundation</a></li>
<li><a href="/2016/02/10/ultimate-symfony-event-dispatcher.html">Event Dispatcher</a></li>
<li><a href="/2016/02/17/ultimate-symfony-routing.html">Routing and YAML</a></li>
</ul>

<p>We're now about to check Dependency Injection, and finally in the next article
we'll have a look at <a href="/2016/03/02/ultimate-symfony-console.html">Console</a>.</p>

<h2 id="introduction-to-the-design-pattern">Introduction to the design pattern</h2>

<p>When first creating a class, we tend to keep it small and tidy. Then overtime it
can grow out of control and the next thing we know it became this multi thousand
line monster:</p>

<pre><code class="php">&lt;?php

class CheckApiStatus
{
    public function check($url)
    {
        $curl = curl_init();
        curl_setopt_array($curl, array(
            CUROPT_RETURNTRANSFER =&gt; true,
            CURLOPT_HEADER =&gt; true,
            CUROPT_URL =&gt; $url,
        ));
        $response = curl_exec($curl);
        $headerSize = curl_getinfo($curl, CURLINFO_HEADER_SIZE);
        $statusCode = curl_getinfo($curl, CURLINFO_HTTP_CODE);
        curl_close($curl);
        $headers = array_map(function($line) {
            return explode(': ', trim($line));
        }, explode("\n", substr($response, 0, $size)));
        array_pop($headers);array_pop($headers);array_shift($headers);
        $body = substr($response, $headerSize);

        return 200 &gt;= $statusCode &amp;&amp; $statusCode &lt; 400;
    }
}
</code></pre>

<p>A nice way to shrink it back to an acceptable level is to identify the many
"responsibilities" it bears and split those in sub classes. This process is called
refactoring:</p>

<pre><code class="php">&lt;?php

class Request
{
    private $uri;

    public function __construct($uri)
    {
        $this-&gt;uri;
    }

    public function getUri()
    {
        return $this-&gt;uri;
    }
}

class Response
{
    private $statusCode;
    private $headers;
    private $body;

    public function __construct($statusCode, $headers, $body)
    {
        $this-&gt;statusCode = $statusCode;
        $this-&gt;headers = $headers;
        $this-&gt;body = $body;
    }

    public function getStatusCode()
    {
        return $this-&gt;statusCode;
    }

    public function getHeaders()
    {
        return $this-&gt;headers;
    }

    public function getBody()
    {
        return $this-&gt;body;
    }
}

interface HttpClient
{
    /**
     * @return Response
     */
    public function sendRequest(Request $request);
}

class CurlHttpClient implements HttpClient
{
    public function sendRequest(Request $request)
    {
        $curl = curl_init();
        curl_setopt_array($curl, array(
            CUROPT_RETURNTRANSFER =&gt; true,
            CURLOPT_HEADER =&gt; true,
            CUROPT_URL =&gt; $request-&gt;getUri(),
        ));
        $response = curl_exec($curl);
        $headerSize = curl_getinfo($curl, CURLINFO_HEADER_SIZE);
        $statusCode = curl_getinfo($curl, CURLINFO_HTTP_CODE);
        curl_close($curl);
        $headers = array_map(function($line) {
            return explode(': ', trim($line));
        }, explode("\n", substr($response, 0, $size)));
        array_pop($headers);array_pop($headers);array_shift($headers);
        $body = substr($response, $headerSize);
        $body = substr($response, $headerSize);

        return new Response($statusCode, $headers, $body);
    }
}

class CheckApiStatus
{
    public function check($url)
    {
        $httpClient = new CurlHttpClient();
        $statusCode = $httpClient-&gt;sendRequest(new Request($url))-&gt;getStatusCode();

        return 200 &gt;= $statusCode &amp;&amp; $statusCode &lt; 400;
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: for more refactoring examples, check:</p>
  
  <ul>
  <li><a href="http://martinfowler.com/articles/refactoring-external-service.html">Refactoring external service</a> by Martin Fowler</li>
  <li><a href="http://verraes.net/2013/09/extract-till-you-drop/">Extract till you drop</a> by Mathias Verreas</li>
  <li>Refactoring the cat API
  <a href="http://php-and-symfony.matthiasnoback.nl/2015/07/refactoring-the-cat-api-client-part-1/">part 1</a>
  <a href="http://php-and-symfony.matthiasnoback.nl/2015/07/refactoring-the-cat-api-client-part-2/">part 2</a>
  <a href="http://php-and-symfony.matthiasnoback.nl/2015/07/refactoring-the-cat-api-client-part-3/">part 3</a>
  by Matthias Noback</li>
  </ul>
</blockquote>

<p>Our original class then has to call those sub classes to "delegate" the work. But
how does it access those sub classes? Should it instantiate them in its methods?
A better place could be the constructor, where the instances are stored in the class
properties so it can be shared between two calls.</p>

<p>Or even better we can instantiate them out of the class, and then pass them as
arguments to the original class constructor, so we can share it with other classes:</p>

<pre><code class="php">&lt;?php

class CheckApiStatus
{
    private $httpClient;

    public function __construct(HttpClient $httpClient)
    {
        $this-&gt;httpClient = $httpClient;
    }

    public function check($url)
    {
        $statusCode = $this-&gt;httpClient-&gt;sendRequest(new Request($url))-&gt;getStatusCode();

        return 200 &gt;= $statusCode &amp;&amp; $statusCode &lt; 400;
    }
}

$httpClient = new CurlHttpClient();
$checkApiStatus = new CheckApiStatus($httpClient);
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Now <code>CheckApiStatus</code> is decoupled from the remote request logic.</p>
  
  <p>The refactoring steps might seem like producing more code just for the "beauty"
  of principles, but it actually enables us to completly remove it: by using <a href="http://www.php-fig.org/psr/psr-7/">PSR-7</a>
  interfaces instead of our own we can easily switch to <a href="http://docs.guzzlephp.org/en/latest/">Guzzle</a>
  or any HTTP client library.</p>
</blockquote>

<p>And that's what <a href="http://www.martinfowler.com/articles/injection.html">Dependency Injection</a>
is all about: taking parameters (also known as dependencies) our class (also known as service)
needs and pass them as arguments (also known as injection), to allow more decoupling.</p>

<p>The downside of this design pattern is that we now have a cascade of instantiations.</p>

<blockquote>
  <p><strong>Note</strong>: Classes can be shared if they are stateless which means calling a method
  shouldn't change their attributes.</p>
</blockquote>

<h2 id="the-component">The component</h2>

<p>Symfony provides a <a href="http://symfony.com/doc/current/components/dependency-injection/introduction.html">Dependency Injection component</a>
which allows us to set up how our classes are constructed:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Reference;

$container = new ContainerBuilder();

$container
    -&gt;register('http_client','CurlHttpClient')
;
$container
    -&gt;register('check_api_status', 'CheckApiStatus')
    -&gt;addArgument(new Reference('http_client'))
;

$checkApiStatus = $container-&gt;get('check_api_status');
</code></pre>

<p>It can even be set up using configuration:</p>

<pre><code># /tmp/services/api.yml
services:
    http_client:
        class: CurlHttpClient

    check_api_status:
        class: CheckApiStatus
        arguments:
            - '@http_client'
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Some string values must be escaped using single quotes because YAML
  has a list of <a href="http://stackoverflow.com/a/22235064">reserved characters</a>, including:
  <code>@</code>, <code>%</code>, <code>\</code>, <code>-</code>, <code>:</code> <code>[</code>, <code>]</code>, <code>{</code> and <code>}</code>.</p>
</blockquote>

<p>Here's how we can load this configuration:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\Config\FileLocator;
use Symfony\Component\Config\Loader\LoaderResolver;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\DirectoryLoader;
use Symfony\Component\DependencyInjection\Loader\YamlFileLoader;

$container = new ContainerBuilder();

// Load recursively all YAML configuration files in services directories
$fileLocator = new FileLocator(__DIR__);
$loader = new DirectoryLoader($container, $fileLocator);
$loader-&gt;setResolver(new LoaderResolver(array(
    new YamlFileLoader($container, $fileLocator),
    $loader,
)));
$loader-&gt;load('/services/');

$checkApiStatus = $container-&gt;get('check_api_status');
</code></pre>

<p>Calling methods on a created service to complete its initialization is possible:</p>

<pre><code>services:
    my_event_listener:
        class: MyEventListener

    event_dispatcher:
        class: 'Symfony\Component\EventDispatcher\EventDispatcher'
        calls:
            - [ addListener, [ kernel.request, '@my_event_listener', 42 ] ]
</code></pre>

<blockquote>
  <p><strong>Note</strong>: There's a better way to add listeners to the EventDispatcher, keep
  reading to find out how.</p>
</blockquote>

<p>Finally it might be useful to create aliases:</p>

<pre><code>services:
    http_client:
        alias: curl_http_client

    curl_http_client:
        class: CurlHttpClient

    check_api_status:
        class: checkApiStatus
        arguments:
            - "@http_client"
</code></pre>

<p>In the example above <code>http_client</code> is set to be <code>curl_http_client</code>, it could be
changed later to use another implementation of <code>HttpClient</code>.</p>

<h2 id="parameters">Parameters</h2>

<p>In addition to class instances, we can also inject parameters:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Parameter;
use Symfony\Component\DependencyInjection\Reference;

$container = new ContainerBuilder();

$container-&gt;setParameter('username', 'arthur.dent@example.com');
$container-&gt;setParameter('password', 42);

$container
    -&gt;register('http_client','CurlHttpClient')
;
$container
    -&gt;register('check_api_status', 'CheckApiStatus')
    -&gt;addArgument(new Reference('http_client'))
    -&gt;addArgument(new Parameter('username'))
    -&gt;addArgument(new Parameter('password'))
;

$checkApiStatus = $container-&gt;get('check_api_status');
</code></pre>

<blockquote>
  <p><strong>Note</strong>: For the example's sake we're pretending that <code>CheckApiStatus</code>'s constructor
  now takes 3 arguments.</p>
</blockquote>

<p>Here's the equivalent in YAML:</p>

<pre><code># /tmp/services/api.yml
parameters:
    username: 'arthur.dent@example.com'
    password: 42

services:
    http_client:
        class: CurlHttpClient

    check_api_status:
        class: CheckApiStatus
        arguments:
            - '@http_client'
            - '%username%'
            - '%password%'
</code></pre>

<blockquote>
  <p><strong>Note</strong>: services are prefixed with <code>@</code>, and parameters are surrounded with <code>%</code>.</p>
</blockquote>

<p>The value of a parameter can be anything:</p>

<ul>
<li>null (<code>~</code>)</li>
<li>a boolean (<code>true</code> or <code>false</code>)</li>
<li>an integer (e.g. <code>42</code>)</li>
<li>a float (e.g. <code>44.23</code>)</li>
<li>a string (e.g. <code>hello world</code>, or escaped <code>'arthur.dent@example.com'</code>)</li>
<li>an array (e.g. <code>[ apples, oranges ]</code>)</li>
<li>an associative array (e.g. <code>{ first_name: Arthur, last_name: Dent }</code>)</li>
</ul>

<blockquote>
  <p><strong>Note</strong>: The examples above for arrays are inline ones. They could also be on many lines:</p>

<pre><code>parameters:
    fruits:
        - apples
        - oranges

    identity:
        first_name: Arthur
        last_name: Dent

    # We can even have multi dimension arrays:
    five_a_day:
        -
            - apples
            - oranges
        -
            - carrots
</code></pre>
</blockquote>

<h2 id="extension">Extension</h2>

<p>By creating a class that extends <code>Extension</code>, we can provide reusable Dependency
Injection configuration:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\Config\FileLocator;
use Symfony\Component\Config\Loader\LoaderResolver;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\DirectoryLoader;
use Symfony\Component\DependencyInjection\Loader\YamlFileLoader;
use Symfony\Component\HttpKernel\DependencyInjection\Extension;

class AppExtension extends Extension
{
    public function load(array $configs, ContainerBuilder $container)
    {
        $fileLocator = new FileLocator(__DIR__);
        $loader = new DirectoryLoader($container, $fileLocator);
        $loader-&gt;setResolver(new LoaderResolver(array(
            new YamlFileLoader($container, $fileLocator),
            $loader,
        )));
        $loader-&gt;load('/services/');
    }
}

$container = new ContainerBuilder();
$appExtension = new AppExtension();
$appExtension-&gt;load(array(), $container);

$checkApiStatus = $container-&gt;get('check_api_status');
</code></pre>

<h2 id="compilerpass-and-tags">CompilerPass and tags</h2>

<p>The <code>Container</code> implementation provides a <code>compile</code> method that resolves parameters
(replace <code>%parameter%</code> placeholders by the parameter value) and freezes them
(calling <code>setParameter</code> will result in an exception).</p>

<p>The <code>ContainerBuilder</code> implementations also has a <code>compile</code> method which is going
to execute all registered <code>CompilerPassInterface</code> implementations.</p>

<p>For example, we can retrieve all services "tagged" <code>kernel.event_listener</code> and
add them to the <code>EventDispatcher</code> with the following one:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Compiler\CompilerPassInterface;
use Symfony\Component\DependencyInjection\Reference;

class EventListenerCompilerPass implements CompilerPassInterface
{
    public function process(ContainerBuilder $container)
    {
        if (false === $container-&gt;hasDefinition('event_dispatcher')) {
            return;
        }
        $eventDispatcher = $container-&gt;getDefinition('event_dispatcher');
        $taggedServices = $container-&gt;findTaggedServiceIds('kernel.event_listener');
        foreach ($taggedServices as $id =&gt; $attributes) {
            $eventDispatcher-&gt;addMethodCall('addListener', array(
                $attributes['event'],
                array(new Reference($id), $attributes['method']),
                $attributes['priority'],
            ));
        }
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: The EventDispatcher component already provides a <code>RegisterListenersPass</code>.</p>
</blockquote>

<p>The configuration for a "tagged" service looks like this:</p>

<pre><code>services:
    my_event_listener:
        class MyEventListener
        tags:
            - { name: kernel.event_listener, event: kernel.request, method: onKernelRequest, priority: 42 }
</code></pre>

<blockquote>
  <p><strong>Note</strong>: With this, it is no longer required to call <code>addListener</code> in <code>event_dispatcher</code>'s
  configuration.</p>
</blockquote>

<h2 id="conclusion">Conclusion</h2>

<p>By providing a configurable way to define service construction, the DependencyInjection
component allows us to use the design pattern of the same name in our projects.</p>

<p>The HttpKernel component provides two <code>HttpKernelInterface</code> implementations:</p>

<ul>
<li><code>HttpKernel</code> which does the HTTP logic</li>
<li><code>Kernel</code> which sets up a DependencyInjection container and then use <code>HttpKernel</code></li>
</ul>

<p>Just like for the Routing component, there's a <code>PhpDumper</code> which can generate an
implementation of <code>ContainerInterface</code> with all configuration in an optimized way.
It might look like this:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\DependencyInjection\ContainerInterface;
use Symfony\Component\DependencyInjection\Container;
use Symfony\Component\DependencyInjection\Exception\InvalidArgumentException;
use Symfony\Component\DependencyInjection\Exception\LogicException;
use Symfony\Component\DependencyInjection\Exception\RuntimeException;
use Symfony\Component\DependencyInjection\ParameterBag\FrozenParameterBag;

class appDevDebugProjectContainer extends Container
{
    private $parameters;
    private $targetDirs = array();

    public function __construct()
    {
        $dir = __DIR__;
        for ($i = 1; $i &lt;= 5; ++$i) {
            $this-&gt;targetDirs[$i] = $dir = dirname($dir);
        }
        $this-&gt;parameters = $this-&gt;getDefaultParameters();

        $this-&gt;services = array();
        $this-&gt;methodMap = array(
            'http_client' =&gt; 'getHttpClientService',
            'check_api_status' =&gt; 'getCheckApiStatusService',
        );
        $this-&gt;aliases = array(
        );
    }

    public function compile()
    {
        throw new LogicException('You cannot compile a dumped frozen container.');
    }

    protected function getHttpClientService()
    {
        return $this-&gt;services['http_client'] = new \CurlHttpClient();
    }

    protected function getCheckApiStatusService()
    {
        return $this-&gt;services['check_api_status'] = new \CheckApiStatus($this-&gt;get('http_client'), 'arthur.dent@example.com', 42);
    }

    public function getParameter($name)
    {
        $name = strtolower($name);
        if (!(isset($this-&gt;parameters[$name]) || array_key_exists($name, $this-&gt;parameters))) {
            throw new InvalidArgumentException(sprintf('The parameter "%s" must be defined.', $name));
        }

        return $this-&gt;parameters[$name];
    }

    public function hasParameter($name)
    {
        $name = strtolower($name);

        return isset($this-&gt;parameters[$name]) || array_key_exists($name, $this-&gt;parameters);
    }

    public function setParameter($name, $value)
    {
        throw new LogicException('Impossible to call set() on a frozen ParameterBag.');
    }

    public function getParameterBag()
    {
        if (null === $this-&gt;parameterBag) {
            $this-&gt;parameterBag = new FrozenParameterBag($this-&gt;parameters);
        }

        return $this-&gt;parameterBag;
    }

    protected function getDefaultParameters()
    {
        return array(
            'username' =&gt; 'arthur.dent@example.com',
            'password' =&gt; 42,
        );
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Dependencies that are used by only one service can be marked as "private"
  they'll be hard coded in the service instantiation (but they won't be available
  anymore from <code>$container-&gt;get()</code>).</p>
  
  <p>In our example we could mark <code>http_client</code> as private, so the dumped Container
  wouldn't have a <code>getHttpClientService</code> method:</p>

<pre><code>service:
    http_client:
        class: CurlHttpClient
        public: false
</code></pre>
</blockquote>

<p>It is also worth noting that services are by default only initialized once and on demand,
so the number of services doesn't impact the performances of the application.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[The Ultimate Developer Guide to Symfony - Routing]]></title>
            <link href="https://gnugat.github.io/2016/02/17/ultimate-symfony-routing.html"/>
            <updated>2016-02-17T00:00:00+00:00</updated>
            <id>https://gnugat.github.io/2016/02/17/ultimate-symfony-routing.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Reference</strong>: This article is intended to be as complete as possible and is
  kept up to date.</p>
  
  <p><strong>TL;DR</strong>:</p>

<pre><code class="php">$parameters = $urlMatcher-&gt;match($request-&gt;getPathInfo());

$request-&gt;attributes-&gt;add(array('_controller' =&gt; $parameters['_controller']);
$request-&gt;attributes-&gt;add(array('_route' =&gt; $parameters['_route']);
unset($parameters['_controller'], $parameters['_route']);
$request-&gt;attributes-&gt;add(array('_route_params' =&gt; $parameters);
</code></pre>
</blockquote>

<p>In this guide we explore the standalone libraries (also known as "Components")
provided by <a href="http://symfony.com">Symfony</a> to help us build applications.</p>

<p>We've already seen:</p>

<ul>
<li><a href="/2016/02/03/ultimate-symfony-http-kernel.html">HTTP Kernel and HTTP Foundation</a></li>
<li><a href="/2016/02/10/ultimate-symfony-event-dispatcher.html">Event Dispatcher</a></li>
</ul>

<p>We're now about to check Routing and YAML, then in the next articles we'll have a look at:</p>

<ul>
<li><a href="/2016/02/24/ultimate-symfony-dependency-injection.html">Dependency Injection</a></li>
<li><a href="/2016/03/02/ultimate-symfony-console.html">Console</a></li>
</ul>

<h2 id="routing">Routing</h2>

<p>Symfony provides a <a href="http://symfony.com/doc/current/components/routing/introduction.html">Routing component</a>
which allows us, for a HTTP request/URL, to execute a specific function (also known as "Controller").</p>

<blockquote>
  <p><strong>Note</strong>: Controllers must be a <a href="http://php.net/manual/en/language.types.callable.php">callable</a>,
  for example:</p>
  
  <ul>
  <li>an anonymous function: <code>$controller = function (Request $request) { return new Response() };</code>.</li>
  <li>an array with an instance of a class and a method name:
  <code>$controller = array($controller, 'searchArticles');</code>.</li>
  <li>a fully qualified classname with a static method name:
  <code>$controller = 'Vendor\Project\Controller\ArticleController::searchArticles'</code>.</li>
  </ul>
  
  <p>Controllers can take a Request argument and should return a Response instance.</p>
</blockquote>

<p>It revolves around the following interface:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\Routing\Matcher;

use Symfony\Component\Routing\Exception\ResourceNotFoundException;
use Symfony\Component\Routing\Exception\MethodNotAllowedException;

interface UrlMatcherInterface
{
    /**
     * @param string $pathinfo
     *
     * @return array Route parameters (also contains `_route`)
     *
     * @throws ResourceNotFoundException
     * @throws MethodNotAllowedException
     */
    public function match($pathinfo);
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: For brevity the interface has been stripped from <code>RequestContextAwareInterface</code>.</p>
</blockquote>

<p>In actual applications we don't need to implement it as the component provides
a nice implementation that works with <code>RouteCollection</code>:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\Routing\RouteCollection;
use Symfony\Component\Routing\Route;

$collection = new RouteCollection();
$collection-&gt;add('search_articles', new Route('/v1/articles', array(
    '_controller' =&gt; 'Vendor\Project\Controller\ArticleController::search',
), array(), array(), '', array(), array('GET', 'HEAD')));

$collection-&gt;add('edit_article', new Route('/v1/articles/{id}', array(
    '_controller' =&gt; 'Vendor\Project\Controller\ArticleController::edit',
), array(), array(), '', array(), array('PUT')));
</code></pre>

<p><code>RouteCollection</code> allows us to configure which Request will match our controllers:
via URL patterns and Request method. It also allows us to specify parts of the URLs
as URI parameters (e.g. <code>id</code> in the above snippet).</p>

<p>Building route configuration by interacting with PHP code can be tedious, so the
Routing component supports alternative configuration formats: annotations, XML, YAML, etc.</p>

<blockquote>
  <p><strong>Tip</strong>: have a look at <code>Symfony\Component\Routing\Loader\YamlFileLoader</code>.</p>
</blockquote>

<h2 id="yaml">YAML</h2>

<p>Symfony provides a <a href="http://symfony.com/doc/current/components/yaml/introduction.html">YAML component</a>
which allows us to convert YAML configuration into PHP arrays (and vice versa).</p>

<p>For example the following YAML file:</p>

<pre><code># /tmp/routing.yml
search_articles:
    path: /api/articles
    defaults:
        _controller: 'Vendor\Project\Controller\ArticleController::search'
    methods:
        - GET
        - HEAD

edit_article:
    path: '/api/articles/{id}'
    defaults:
        _controller: 'Vendor\Project\Controller\ArticleController::edit'
    methods:
        - PUT
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Some string values must be escaped using single quotes because the YAML
  has a list of <a href="http://stackoverflow.com/a/22235064">reserved characters</a>, including:
  <code>@</code>, <code>%</code>, <code>\</code>, <code>-</code>, <code>:</code> <code>[</code>, <code>]</code>, <code>{</code> and <code>}</code>.</p>
</blockquote>

<p>Can be converted using:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\Yaml\Yaml;

$routing = Yaml::parse(file_get_contents('/tmp/routing.yml'));
</code></pre>

<p>This will result in the equivalent of the following array:</p>

<pre><code class="php">&lt;?php

$routing = array(
    'search_articles' =&gt; array(
        'path' =&gt; '/api/articles',
        'defaults' =&gt; array(
            '_controller' =&gt; 'Vendor\Project\Controller\ArticleController::search',
        ),
        'methods' =&gt; array(
            'GET',
            'HEAD',
        ),
    ),
    'edit_article' =&gt; array(
        'path' =&gt; '/api/articles/{id}',
        'defaults' =&gt; array(
            '_controller' =&gt; 'Vendor\Project\Controller\ArticleController::edit',
        ),
        'methods' =&gt; array(
            'PUT',
        ),
    ),
);
</code></pre>

<blockquote>
  <p><strong>Note</strong>: the Routing component uses another component to then build <code>RouteCollection</code>
  from this array: the <a href="http://symfony.com/doc/current/components/config/introduction.html">Config component</a>
  which is out of the scope of this guide.</p>
</blockquote>

<p>There's also <code>$yaml = Yaml::dump($array);</code> that converts a PHP array into a YAML
string.</p>

<h2 id="conclusion">Conclusion</h2>

<p>The Routing component allows us to define which Controllers should be executed
for the given Request, and the Yaml component allows us to configure it in a simple way.</p>

<p>HttpKernel provides a <code>RouterListener</code> which makes use of <code>UrlMatcher</code> when the
Request is received to find a corresponding controller.</p>

<blockquote>
  <p><strong>Note</strong>: <code>Request-&gt;attributes</code> is used to store information about the current
  Request such as the matched route, the controller, etc. It's used internally
  by Symfony but we could also store our own values in it.</p>
</blockquote>

<p>Some might be concerned with performance: reading the configuration from the
filesystem may slow down the application.</p>

<p>Don't panic! There's a <code>PhpMatcherDumper</code> class which can generate an implementation
of <code>UrlMatcherInterface</code> with all configuration in an optimized way. It might look
like this:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\Routing\Exception\MethodNotAllowedException;
use Symfony\Component\Routing\Exception\ResourceNotFoundException;
use Symfony\Component\Routing\RequestContext;

class appDevUrlMatcher extends Symfony\Bundle\FrameworkBundle\Routing\RedirectableUrlMatcher
{
    public function __construct(RequestContext $context)
    {
        $this-&gt;context = $context;
    }

    public function match($pathinfo)
    {
        $allow = array();
        $pathinfo = rawurldecode($pathinfo);
        $context = $this-&gt;context;

        // edit_article
        if (preg_match('#^/v1/articles/(?P&lt;id&gt;[^/]++)$#s', $pathinfo, $matches)) {
            if ($this-&gt;context-&gt;getMethod() != 'PUT') {
                $allow[] = 'PUT';
                goto not_edit_article;
            }

            return $this-&gt;mergeDefaults(array_replace($matches, array('_route' =&gt; 'edit_article')), array (  '_controller' =&gt; 'Vendor\Project\Controller\ArticleController::edit',));
        }
        not_edit_article:

        // search_articles
        if ($pathinfo === '/v1/articles') {
            if (!in_array($this-&gt;context-&gt;getMethod(), array('GET', 'HEAD'))) {
                $allow = array_merge($allow, array('GET', 'HEAD'));
                goto not_search_articles;
            }

            return array (  '_controller' =&gt; 'app.article_controller:search',  '_route' =&gt; 'Vendor\Project\Controller\ArticleController::search',);
        }
        not_search_articles:

        throw 0 &lt; count($allow) ? new MethodNotAllowedException(array_unique($allow)) : new ResourceNotFoundException();
    }
}
</code></pre>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[The Ultimate Developer Guide to Symfony - Event Dispatcher]]></title>
            <link href="https://gnugat.github.io/2016/02/10/ultimate-symfony-event-dispatcher.html"/>
            <updated>2016-02-10T00:00:00+00:00</updated>
            <id>https://gnugat.github.io/2016/02/10/ultimate-symfony-event-dispatcher.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Reference</strong>: This article is intended to be as complete as possible and is
  kept up to date.</p>
  
  <p><strong>TL;DR</strong>:</p>

<pre><code class="php">$eventDispatcher-&gt;addListener($eventName, $listener1, $priority);
$eventDispatcher-&gt;addListener($eventName, $listener2, $priority - 1);
$eventDispatcher-&gt;dispatch($eventName); // Calls $listener1, then $listener2
</code></pre>
</blockquote>

<p>In this guide we explore the standalone libraries (also known as "Components")
provided by <a href="http://symfony.com">Symfony</a> to help us build applications.</p>

<p>We've already seen:</p>

<ul>
<li><a href="/2016/02/03/ultimate-symfony-http-kernel.html">HTTP Kernel and HTTP Foundation</a></li>
</ul>

<p>We're now about to check Event Dispatcher, then in the next articles we'll have a look at:</p>

<ul>
<li><a href="/2016/02/17/ultimate-symfony-routing.html">Routing and YAML</a></li>
<li><a href="/2016/02/24/ultimate-symfony-dependency-injection.html">Dependency Injection</a></li>
<li><a href="/2016/03/02/ultimate-symfony-console.html">Console</a></li>
</ul>

<h2 id="event-dispatcher">Event Dispatcher</h2>

<p>Symfony provides an <a href="http://symfony.com/doc/current/components/event_dispatcher/introduction.html">EventDispatcher component</a>
which allows the execution of registered function at key points in our applications.</p>

<p>It revolves around the following interface:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\EventDispatcher;

interface EventDispatcherInterface
{
    /**
     * @param string   $eventName
     * @param callable $listener
     * @param int      $priority  High priority listeners will be executed first
     */
    public function addListener($eventName, $listener, $priority = 0);

    /**
     * @param string $eventName
     * @param Event  $event
     */
    public function dispatch($eventName, Event $event = null);
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: This snippet is a truncated version, the actual interface has methods
  to add/remove/get/check listeners and subscribers (which are "auto-configured" listeners).</p>
</blockquote>

<p>An implementation is provided out of the box and can be used as follow:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\EventDispatcher\EventDispatcher;

$eventDispatcher = new EventDispatcher();

$eventDispatcher-&gt;addListener('something_happened', function () {
    echo "Log it\n";
}, 1);
$eventDispatcher-&gt;addListener('something_happened', function () {
    echo "Save it\n";
}, 2);

$eventDispatcher-&gt;dispatch('something_happened');
</code></pre>

<p>This will output:</p>

<pre><code>Save it
Log it
</code></pre>

<p>Since the second listener had a higher priority, it got executed first.</p>

<blockquote>
  <p><strong>Note</strong>: Listeners must be a <a href="http://php.net/manual/en/language.types.callable.php">callable</a>,
  for example:</p>
  
  <ul>
  <li>an anonymous function: <code>$listener = function (Event $event) {};</code>.</li>
  <li>an array with an instance of a class and a method name:
  <code>$listener = array($service, 'method');</code>.</li>
  <li>a fully qualified classname with a static method name:
  <code>$listener = 'Vendor\Project\Service::staticMethod'</code>.</li>
  </ul>
</blockquote>

<p>If we want to provide some context to the listeners (parameters, etc) we can
create a sub-class of <code>Event</code>:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\EventDispatcher\Event;
use Symfony\Component\EventDispatcher\EventDispatcher;

class SomethingHappenedEvent extends Event
{
    private $who;
    private $what;
    private $when;

    public function __construct($who, $what)
    {
        $this-&gt;who = $who;
        $this-&gt;what = $what;
        $this-&gt;when = new \DateTime();
    }

    public function who()
    {
        return $this-&gt;who;
    }

    public function what()
    {
        return $this-&gt;what;
    }

    public function when()
    {
        return $this-&gt;when;
    }
}

$eventDispatcher = new EventDispatcher();

$eventDispatcher-&gt;addListener('something_happened', function (SomethingHappenedEvent $event) {
    echo "{$event-&gt;who()} was {$event-&gt;what()} at {$event-&gt;when()-&gt;format('Y/m/d H:i:s')}\n";
});

$eventDispatcher-&gt;dispatch('something_happened', new SomethingHappenedEvent('Arthur', 'hitchhiking'));
</code></pre>

<h2 id="httpkernel-example">HttpKernel example</h2>

<p>The HttpKernel component we've seen in <a href="/2016/02/03/ultimate-symfony-http-kernel.html">the previous article</a>
provides a <code>Kernel</code> abstract class that heavily relies on EventDispatcher.</p>

<p>For each key steps of its execution, it dispatches the following events:</p>

<ol>
<li><code>kernel.request</code>: gets a <code>Request</code></li>
<li><code>kernel.controller</code>: executes a callable (also known as "Controller")</li>
<li><code>kernel.view</code>: converts the Controller's returned value into a <code>Response</code> (if necessary)</li>
<li><code>kernel.response</code>: returns a <code>Response</code></li>
</ol>

<p>And in case of error:</p>

<ul>
<li><code>kernel.exception</code>: handles errors</li>
</ul>

<p>Just before returning the <code>Response</code>, <code>HttpKernel</code> dispatches one last event:</p>

<ul>
<li><code>kernel.finish_request</code>: clean ups, sending emails, etc</li>
</ul>

<p>After the <code>Response</code> has been displayed, we can dispatch:</p>

<ul>
<li><code>kernel.terminate</code>: same as <code>kernel.finish_request</code>, except it won't slow down
the rendering of request if FastCGI is enabled</li>
</ul>

<h3 id="kernel-request">Kernel Request</h3>

<p>Listeners that registered for <code>kernel.request</code> can modify the Request object.</p>

<p>Out of the box there's a <code>RouterListener</code> registered which sets the following
parameters in <code>Request-&gt;attributes</code>:</p>

<ul>
<li><code>_route</code>: the route name that matched the Request</li>
<li><code>_controller</code>: a callable that will handle the Request and return a Response</li>
<li><code>_route_parameters</code>: query parameters extracted from the Request</li>
</ul>

<p>An example of a custom Listener could be one that decodes JSON content and sets
it in <code>Request-&gt;request</code>:</p>

<pre><code class="php">&lt;?php

namespace AppBundle\EventListener;

use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Event\GetResponseEvent;

/**
 * PHP does not populate $_POST with the data submitted via a JSON Request,
 * causing an empty $request-&gt;request.
 *
 * This listener fixes this.
 */
class JsonRequestContentListener
{
    /**
     * @param GetResponseEvent $event
     */
    public function onKernelRequest(GetResponseEvent $event)
    {
        $request = $event-&gt;getRequest();
        $hasBeenSubmited = in_array($request-&gt;getMethod(), array('PATCH', 'POST', 'PUT'), true);
        $isJson = (1 === preg_match('#application/json#', $request-&gt;headers-&gt;get('Content-Type')));
        if (!$hasBeenSubmited || !$isJson) {
            return;
        }
        $data = json_decode($request-&gt;getContent(), true);
        if (JSON_ERROR_NONE !== json_last_error()) {
            $event-&gt;setResponse(new Response('{"error":"Invalid or malformed JSON"}', 400, array('Content-Type' =&gt; 'application/json')));
        }
        $request-&gt;request-&gt;add($data ?: array());
    }
}
</code></pre>

<p>Another example would be to start a database transaction:</p>

<pre><code class="php">&lt;?php

namespace AppBundle\EventListener;

use PommProject\Foundation\QueryManager\QueryManagerInterface;
use Symfony\Component\HttpKernel\Event\GetResponseEvent;

class StartTransactionListener
{
    /**
     * @var QueryManagerInterface
     */
    private $queryManager;

    /**
     * @param QueryManagerInterface $queryManager
     */
    public function __construct(QueryManagerInterface $queryManager)
    {
        $this-&gt;queryManager = $queryManager;
    }

    /**
     * @param GetResponseEvent $event
     */
    public function onKernelRequest(GetResponseEvent $event)
    {
        $this-&gt;queryManager-&gt;query('START TRANSACTION');
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: <a href="http://pomm-project.org">Pomm</a> is used here as an example.</p>
</blockquote>

<h3 id="kernel-controller">Kernel Controller</h3>

<p>Listeners that registered for <code>kernel.controller</code> can modify the Request object.</p>

<p>This can be useful when we'd like to change the Controller.</p>

<p>For example <code>SensioFrameworkExtraBundle</code> has a <code>ControllerListener</code> that parses
the controller annotations at this point.</p>

<h3 id="kernel-view">Kernel View</h3>

<p>Listeners that registered for <code>kernel.view</code> can modify the Response object.</p>

<p>For example <code>SensioFrameworkExtraBundle</code> has a <code>TemplateListener</code> that uses <code>@Template</code>
annotation: controllers only need to return an array and the listener will create
a response using <a href="http://twig.sensiolabs.org/">Twig</a> (it will pass the array as
Twig parameters).</p>

<h3 id="kernel-response">Kernel Response</h3>

<p>Listeners that registered for <code>kernel.response</code> can modify the Response object.</p>

<p>Out of the box there's a <code>ResponseListener</code> regitered which sets some Response
headers according to the Request's one.</p>

<h3 id="kernel-terminate">Kernel Terminate</h3>

<p>Listeners that registered for <code>kernel.terminate</code> can execute actions after the
Response has been served (if our web server uses FastCGI).</p>

<p>An example of a custom Listener could be one that rollsback a database transaction,
when running in test environment:</p>

<pre><code class="php">&lt;?php

namespace AppBundle\EventListener\Pomm;

use PommProject\Foundation\QueryManager\QueryManagerInterface;
use Symfony\Component\HttpKernel\Event\PostResponseEvent;

class RollbackListener
{
    /**
     * @var QueryManagerInterface
     */
    private $queryManager;

    /**
     * @param QueryManagerInterface $queryManager
     */
    public function __construct(QueryManagerInterface $queryManager)
    {
        $this-&gt;queryManager = $queryManager;
    }

    /**
     * @param PostResponseEvent $event
     */
    public function onKernelTerminate(PostResponseEvent $event)
    {
        $this-&gt;queryManager-&gt;query('ROLLBACK');
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: We'll se later how to register this listener only for test environment.</p>
</blockquote>

<h3 id="kernel-exception">Kernel Exception</h3>

<p>Listeners that registered for <code>kernel.exception</code> can catch an exception and generate
an appropriate Response object.</p>

<p>An example of a custom Listener could be one that logs debug information and generates
a 500 Response:</p>

<pre><code class="php">&lt;?php

namespace AppBundle\EventListener;

use Psr\Log\LoggerInterface;
use Ramsey\Uuid\Uuid;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Event\GetResponseForExceptionEvent;

class ExceptionListener
{
    /**
     * @var LoggerInterface
     */
    private $logger;

    /**
     * @param LoggerInterface $logger
     */
    public function __construct(LoggerInterface $logger)
    {
        $this-&gt;logger = $logger;
    }

    /**
     * @param GetResponseForExceptionEvent $event
     */
    public function onKernelException(GetResponseForExceptionEvent $event)
    {
        $exception = $event-&gt;getException();
        $token = Uuid::uuid4()-&gt;toString();
        $this-&gt;logger-&gt;critical(
            'Caught PHP Exception {class}: "{message}" at {file} line {line}',
            array(
                'class' =&gt; get_class($exception),
                'message' =&gt; $exception-&gt;getMessage(),
                'file' =&gt; $exception-&gt;getFile(),
                'line' =&gt; $exception-&gt;getLine()
                'exception' =&gt; $exception,
                'token' =&gt; $token
            )
        );
        $event-&gt;setResponse(new Response(
            json_encode(array(
                'error' =&gt; 'An error occured, if it keeps happening please contact an administrator and provide the following token: '.$token,
            )),
            500,
            array('Content-Type' =&gt; 'application/json'))
        );
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: <a href="https://benramsey.com/projects/ramsey-uuid/">Ramsey UUID</a> is used
  here to provide a unique token that can be referred to.</p>
</blockquote>

<h2 id="conclusion">Conclusion</h2>

<p>EventDispatcher is another example of a simple yet powerful Symfony component.
HttpKernel uses it to configure a standard "Symfony application", but also to
allow us to change its behaviour.</p>

<p>In this article we've seen the basics and how it works behind the hood when used
by HttpKernel, but we could create our own event and dispatch it to make our
own code "Open for extension, but Close to modification"
(<a href="https://blog.8thlight.com/uncle-bob/2014/05/12/TheOpenClosedPrinciple.html">Open/Close principle</a>).</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[The Ultimate Developer Guide to Symfony - HTTP Kernel]]></title>
            <link href="https://gnugat.github.io/2016/02/03/ultimate-symfony-http-kernel.html"/>
            <updated>2016-02-03T00:00:00+00:00</updated>
            <id>https://gnugat.github.io/2016/02/03/ultimate-symfony-http-kernel.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Reference</strong>: This article is intended to be as complete as possible and is
  kept up to date.</p>
  
  <p><strong>TL;DR</strong>: <code>$response = $httpKernel-&gt;handle($request);</code></p>
</blockquote>

<p><a href="http://symfony.com">Symfony</a> provides many standalone libraries (also known as
"Components") that help us build applications.</p>

<p>In this guide we'll see the main ones that allow us to build an application:</p>

<ul>
<li>HTTP Kernel and HTTP Foundation</li>
<li><a href="/2016/02/10/ultimate-symfony-event-dispatcher.html">Event Dispatcher</a></li>
<li><a href="/2016/02/17/ultimate-symfony-routing.html">Routing and YAML</a></li>
<li><a href="/2016/02/24/ultimate-symfony-dependency-injection.html">Dependency Injection</a></li>
<li><a href="/2016/03/02/ultimate-symfony-console.html">Console</a></li>
</ul>

<h2 id="http-kernel">HTTP kernel</h2>

<p>Symfony provides a <a href="http://symfony.com/doc/current/components/http_kernel/introduction.html">HttpKernel component</a>
which follows the HTTP protocol: it converts a <code>Request</code> into a <code>Response</code>.</p>

<p>It all revolves around the following interface:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\HttpKernel;

use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

interface HttpKernelInterface
{
    const MASTER_REQUEST = 1;
    const SUB_REQUEST = 2;

    /**
     * @param Request $request
     * @param int     $type
     * @param bool    $catch   Whether to catch exceptions or not
     *
     * @return Response
     */
    public function handle(Request $request, $type = self::MASTER_REQUEST, $catch = true);
}
</code></pre>

<h2 id="httpfoundation">HttpFoundation</h2>

<p>HttpKernel relies on the <a href="http://symfony.com/doc/current/components/http_foundation/introduction.html">HttpFoundation component</a>
which mainly provides:</p>

<ul>
<li><code>Request</code>: wraps <code>$_GET</code>, <code>$_POST</code>, <code>$_COOKIE</code>, <code>$_FILES</code> and <code>$_SERVER</code></li>
<li><code>Response</code>: wraps <code>header()</code> and <code>setcookie()</code>, but also displays the content</li>
</ul>

<blockquote>
  <p><strong>Note</strong>: Global variables have the drawback to be possibly accessed by many
  functions, causing their state to be unpredictable (hence bugs happen and they
  are hard to find/understand).</p>
  
  <p>With HttpFoundation, <a href="http://php.net/manual/en/language.variables.superglobals.php">PHP super globals</a>
  shouldn't be accessed directly, but rather via the objects that wraps them
  (e.g. <code>Request</code>) which are passed around (those objects are not global).</p>
</blockquote>

<p>Here's a typical usage:</p>

<pre><code class="php">$request = Request::createFromGlobals();
$response = $httpKernel-&gt;handle($request);
$reponse-&gt;send();
</code></pre>

<p>In the above example, <code>Request</code> will be initialized using PHP super globals.
Sometimes it can be useful to build it with our own provided values (e.g. for tests):</p>

<pre><code class="php">$uri = '/v1/items';
$method = 'POST';
$parameters = array(); // GET or POST parameters, usually left unused (use uri and content instead)
$cookies = array();
$files = array();
$headers = array('CONTENT_TYPE' =&gt; 'application/json');
$content = json_encode(array('name' =&gt; 'Arthur Dent'));

$request = Request::create($uri, $method, $getOrPostParameters, $cookies, $files, $headers, $content);
</code></pre>

<p>In our application, we'll mainly extract its parameters:</p>

<pre><code class="php">$getParameter = $request-&gt;query-&gt;get('description'); // e.g. from URI `/?description=hitchhicker`
$postParameter = $request-&gt;request-&gt;get('name'); // e.g. from content `name=Arthur`
$header = $request-&gt;headers-&gt;get('Content-Type'); // e.g. from headers `Content-Type: application/x-www-form-urlencoded`

$customParameter = $request-&gt;attributes-&gt;get('_route'); // We'll see more about it in the next article
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Those public properties are instances of <code>Symfony\Component\HttpFoundation\ParameterBag</code>,
  except <code>headers</code> which is an instance of <code>Symfony\Component\HttpFoundation\HeaderBag</code>.</p>
</blockquote>

<p>In our application we'll mainly build <code>Response</code>:</p>

<pre><code class="php">$content = json_encode(array('name' =&gt; 'Arthur Dent'));
$status = 201;
$headers = array('Content-Type' =&gt; 'application/json');

$response = new Reponse($content, $status, $headers);
</code></pre>

<p>HttpFoundation also wraps <code>$_SESSION</code> in a convenient <code>Session</code> object. This one
is however out of the scope of this series, to find more about it have a look at
<a href="/2014/04/23/sf2-sessions-introduction.html">Symfony Session Introduction</a>.</p>

<h2 id="example">Example</h2>

<p>Let's create a small Hello World example:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\HttpKernel\HttpKernelInterface;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class HelloWorldHttpKernel implements HttpKernelInterface
{
    public function handle(Request $request, $type = self::MASTER_REQUEST, $catch = true)
    {
        $name = $request-&gt;query-&gt;get('name', 'World');

        return new Response("Hello $name!", 200);
    }
}

$httpKernel = new HelloWorldHttpKernel();

$request = Request::createFromGlobals();
$response = $httpKernel-&gt;handle($request);
$response-&gt;send();
</code></pre>

<p>So we can get the following:</p>

<ul>
<li>for <code>/</code> URL, we get <code>Hello World!</code></li>
<li>for <code>/?name=Arthur</code> URL, we get <code>Hello Arthur!</code></li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>Symfony provides a simple yet powerful component allowing us to follow the HTTP
protocol.</p>

<p>In this article we've seen the basics and how it works behind the hood, but in
an actual application we don't necessarily need to create our own implementation
of <code>HttpKernelInterface</code>.</p>

<p>Indeed there's a <code>Symfony\Component\HttpKernel\Kernel</code> abstract class that can
be used out of the box. It provides many features that we'll explore in the next
articles:</p>

<ul>
<li><a href="/2016/02/10/ultimate-symfony-event-dispatcher.html">Event Dispatcher</a></li>
<li><a href="/2016/02/17/ultimate-symfony-routing.html">Routing and YAML</a></li>
<li><a href="/2016/02/24.ultimate-symfony-dependency-injection.html">Dependency Injection</a></li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[phpspec]]></title>
            <link href="https://gnugat.github.io/2015/08/03/phpspec.html"/>
            <updated>2015-08-03T00:00:00+01:00</updated>
            <id>https://gnugat.github.io/2015/08/03/phpspec.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Reference</strong>: This article is intended to be as complete as possible and is kept up to date.</p>
</blockquote>

<p><a href="http://www.phpspec.net">phpspec</a> is a highly opinionated unit test framework:
it was conceived to practice <a href="http://dannorth.net/introducing-bdd/">specBDD</a>
(test method names should be sentences) and
<a href="http://martinfowler.com/articles/mocksArentStubs.html">Mockist TDD</a>
(collaborators should always be mocked) and tries to enforce some testing practices
(see <a href="https://twitter.com/_md">Marcello Duarte</a>'s <a href="http://techportal.inviqa.com/2014/09/11/my-top-ten-favourite-phpspec-limitations/">top 10 favourite phpspec limitations</a>).</p>

<p>The <a href="http://blog.astrumfutura.com/2008/01/the-phpspec-zend-framework-app-testing-manifesto-zf-integration/">first version</a>
was created by <a href="https://twitter.com/padraicb">Pádraic Brady</a> as a port of <a href="http://rspec.info/">rspec</a>,
but Marcello Duarte and <a href="https://twitter.com/everzet">Konstantin Kudryashov</a>
took over and released a second version which added code generation.
<a href="https://twitter.com/CiaranMcNulty">Ciaran McNulty</a> then took the lead from v2.1
and added many features like collaborator generation, better exception specification
and currently for version 2.3 better constructor specification.</p>

<h2 id="usage-example">Usage example</h2>

<p>Let's have a look at how phpspec works. For this we'll need to have a project configured with
<a href="https://getcomposer.org/download">Composer</a>. Here's the <code>composer.json</code> file:</p>

<pre><code>{
    "name": "vendor/project",
    "autoload": {
        "psr-4": {
            "Vendor\\Project\\": "src/Vendor/Project"
        }
    },
    "require": {},
    "require-dev": {}
}
</code></pre>

<p>We can install phpspec with the following:</p>

<pre><code>composer require --dev phpspec/phpspec:^2.2
</code></pre>

<p>Let's say we want to create a class that edits text files. We can call this class
<code>TextEditor</code>:</p>

<pre><code>phpspec describe 'Vendor\Project\TextEditor'
</code></pre>

<blockquote>
  <p><strong>Tip</strong>: make your vendor's binaries available by adding <code>vendor/bin</code> to your <code>$PATH</code>.
  <code>export PATH="vendor/bin:$PATH"</code>.</p>
</blockquote>

<p>We should now have the <code>spec/Vendor/Project/TextEditorSpec.php</code> file, bootstraped
for us by phpspec:</p>

<pre><code class="php">&lt;?php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class TextEditorSpec extends ObjectBehavior
{
    function it_is_initializable()
    {
        $this-&gt;shouldHaveType('Vendor\Project\TextEditor');
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: this test can only be used to test the <code>TextEditor</code> class.</p>
</blockquote>

<p>Our first use case will be about creating a file if it doesn't already exist.
Those are filesystem operations, so we decide to delegate the actual logic to a
<code>Filesystem</code> class (we'll create it later).</p>

<p>So our first step will be to create a set up method (it will be executed before
every test method) that initializes our object:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/TextEditorSpec.php

namespace spec\Vendor\Project;

use Vendor\Project\Service\Filesystem;
use PhpSpec\ObjectBehavior;

class TextEditorSpec extends ObjectBehavior
{
    function let(Filesystem $filesystem)
    {
        $this-&gt;beConstructedWith($filesystem);
    }
}
</code></pre>

<p>Arguments passed to test methods are actually test doubles (phpspec uses the typehint
to know what to mock).</p>

<p>Now we can create the actual test method:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/TextEditorSpec.php

namespace spec\Vendor\Project;

use Vendor\Project\Service\Filesystem;
use Vendor\Project\File;
use PhpSpec\ObjectBehavior;

class TextEditorSpec extends ObjectBehavior
{
    const FILENAME = '/tmp/file.txt';
    const FORCE_FILE_CREATION = true;

    function let(Filesystem $filesystem)
    {
        $this-&gt;beConstructedWith($filesystem);
    }

    function it_can_force_file_creation_if_it_does_not_already_exists(File $file, Filesystem $filesystem)
    {
        $filesystem-&gt;exists(self::FILENAME)-&gt;willReturn(false);
        $filesystem-&gt;create(self::FILENAME)-&gt;willReturn($file);

        $this-&gt;open(self::FILENAME, self::FORCE_FILE_CREATION)-&gt;shouldBe($file);
    }
}
</code></pre>

<p>This is roughly the equivalent of the following with <a href="https://phpunit.de/">PHPUnit</a>:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project\Tests;

use Vendor\Project\Service\Filesystem;
use Vendor\Project\File;
use PhpSpec\ObjectBehavior;

class TextEditorTest extends PHPUnit_Framewor_TestCase
{
    const FILENAME = '/tmp/file.txt';
    const FORCE_FILE_CREATION = true;

    private $prophet;
    private $filesystem;
    private $textEditor;

    protected function setUp()
    {
        $this-&gt;prophet = new \Prophecy\Prophet();
        $this-&gt;filesystem = $this-&gt;prophet-&gt;prophesize('Vendor\Project\Service\Filesystem');
        $this-&gt;textEditor = new TextEditor($filesystem-&gt;reveal());
    }

    protected function tearDown()
    {
        $this-&gt;prophet-&gt;checkPredictions();
    }

    /**
     * @test
     */
    public function it_can_force_file_creation_if_it_does_not_already_exists()
    {
        $file = $this-&gt;prophet-&gt;prophesize('Vendor\Project\File');
        $this-&gt;filesystem-&gt;exists(self::FILENAME)-&gt;willReturn(false);
        $this-&gt;filesystem-&gt;create(self::FILENAME)-&gt;willReturn($file);

        self::assertSame($file, $this-&gt;textEditor-&gt;open(self::FILENAME, self::FORCE_FILE_CREATION));
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: We tried to make the test method as descriptive as possible (e.g. not <code>testOpen()</code>).
  This is the whole point of specBDD (specification Behavior Driven Development).</p>
</blockquote>

<p>phpspec uses the mocking library prophecy (also available in PHPUnit since version 4.4),
which tries to be as less verbose as possible: to describe interractions, test doubles
can almost be used as the actual object, except we need to add a <code>-&gt;willreturn()</code> or
<code>-&gt;shouldBeCalled()</code> call afterwards.</p>

<blockquote>
  <p><strong>Note</strong>: By mocking all collaborators, we are forced to think how our object interracts with them.
  This is the whole point of Mockist TDD (Mockist Test Driven Development).</p>
</blockquote>

<p>Now that we have a test, we are going to execute the test suite (as advocated by TDD):</p>

<pre><code>phpspec run
</code></pre>

<p>It will ask the following 7 questions:</p>

<ol>
<li>Would you like me to generate an interface <code>Vendor\Project\Service\Filesystem</code> for you?</li>
<li>Would you like me to generate an interface <code>Vendor\Project\File</code> for you?</li>
<li>Would you like me to generate a method signature <code>Vendor\Project\Service\Filesystem::exists()</code> for you?</li>
<li>Would you like me to generate a method signature <code>Vendor\Project\Service\Filesystem::create()</code> for you?</li>
<li>Do you want me to create <code>Vendor\Project\TextEditor</code> for you?</li>
<li>Do you want me to create <code>Vendor\Project\TextEditor::__construct()</code> for you?</li>
<li>Do you want me to create <code>Vendor\Project\TextEditor::open()</code> for you?</li>
</ol>

<p>By accepting everytime, phpspec will bootstrap the following
<code>src/Vendor/Project/Vendor/TextEditor.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

class TextEditor
{

    public function __construct($argument1)
    {
        // TODO: write logic here
    }

    public function open($argument1, $argument2)
    {
        // TODO: write logic here
    }
}
</code></pre>

<p>In our specification, we make use of non existing class (<code>File</code> and <code>Filesystem</code>)
but phpspec also bootstraped them for us, for example <code>src/Vendor/Project/Vendor/Filesystem.php</code>:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project\Service;

interface Filesystem
{

    public function exists($argument1);

    public function create($argument1);
}
</code></pre>

<p>This is extremely usefull to kickstart our TDD cycle!</p>

<p>Once the code is written, we'll execute the test suite again, and then we'll add more
use cases to the test class (e.g. what happens if the file already exists?).</p>

<p>For further usage example, have a look at: <a href="tags/phpspec">articles tagged with phpspec</a>.</p>

<h2 id="specgen">SpecGen</h2>

<p>phpspec's code generator is a big part of its value, but it could do more for us.
Hence the <a href="https://github.com/memio/spec-gen">SpecGen</a> extension!</p>

<p>We can install it as follow:</p>

<pre><code>composer require --dev memio/spec-gen:^0.4
echo 'extensions:' &gt; phpspec.yml
echo '  - Memio\SpecGen\MemioSpecGenExtension' &gt;&gt; phpspec.yml
</code></pre>

<p>If we remove the code generated by phpspec:</p>

<pre><code>rm src/Vendor/Project/TextEditor.php
</code></pre>

<p>And re-run the tests:</p>

<pre><code>phpspec run
</code></pre>

<p>Then the generated class will be:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

use Vendor\Project\Service\Filesystem;

class TextEditor
{
    private $filesystem;

    public function __construct(Filesystem $filesystem)
    {
        $this-&gt;filesystem = $filesystem;
    }

    public function open($argument1, $argument2)
    {
    }
}
</code></pre>

<h2 id="emergent-design">Emergent Design</h2>

<p>Test are more than simple regression checks: when a class is hard to test it indicates
that it does too many things or is too coupled.</p>

<p>They can also be used as a design tool: in our test method we can define exactly how
we would like to use the future object. We can even decide on the go that some logic
could be done by collaborators that don't exist yet and start defining how we like to
interract with them.</p>

<p>This is what Emergent Design is all about: the design emerges on the go from the tests.
Then they stop being simple tests, they become specifications: a live documentation
of your code, which never become out of date.</p>

<h2 id="tips">Tips</h2>

<p>Here are some personal tips:</p>

<ul>
<li>use <code>willReturn</code> if you need the returned value of a collaborator (official name: Mock)</li>
<li>use <code>shouldBeCalled</code> to check that a collaborator is called (official name: Stub)</li>
<li>do not chain <code>willReturn</code> and <code>shouldBeCalled</code>, you have to pick one!</li>
<li>create a <code>it_is_a_</code> test method with a <code>shouldImplement</code> check when testing implementations</li>
<li>the <code>shouldBe</code> matcher is usually the only one you need</li>
<li>if you have a lot (how many? that's your call) of test methods, maybe it's time to split your object</li>
<li>if you copy paste the same block of code in many test methods, maybe it's time extract it into an object</li>
</ul>

<p>If the tested object (official name: System Under Test, SUT) creates a value object and passes
it to a collaborator you have two choices:</p>

<ul>
<li>pass <code>Argument::type('MyValueObject')</code></li>
<li>create a factory and add it as a dependency</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>phpspec is a nice unit testing framework, with many advantages:</p>

<ul>
<li>it's fast: on average projects the test suite is run in less than a second</li>
<li>it's a good pair-programming partner: when something is hard to test, it means that there is a better diffrent way to do it</li>
<li>it's a time saver: the code bootstrapping feature is a must have!</li>
<li>it isn't verbose: tests can be read as documented code examples</li>
</ul>

<p>Give it a try!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony Sessions introduction]]></title>
            <link href="https://gnugat.github.io/2014/04/23/sf2-sessions-introduction.html"/>
            <updated>2014-04-23T00:00:00+01:00</updated>
            <id>https://gnugat.github.io/2014/04/23/sf2-sessions-introduction.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Reference</strong>: This article is intended to be as complete as possible and is
  kept up to date.</p>
  
  <p><em>Last reviewed</em>: 22/02/2016.</p>
</blockquote>

<p><a href="#conclusion">TL;DR: jump to the conclusion</a>.</p>

<p>The <a href="http://symfony.com/doc/current/components/http_foundation/introduction.html">Symfony HttpFoundation component</a>
is a library which provides an Object Oriented implementation of the HTTP
protocol: it wraps PHP's variable superglobals (<code>$_POST</code>, <code>$_GET</code>, <code>$_SERVER</code>,
etc) inside objects (<code>Request</code>, <code>Response</code>, <code>Session</code>, etc).</p>

<p>The idea behind it: web applications should receive a Request and return a
Response.</p>

<p>In this article, we'll focus on the Session management which solves many issues
(for example the <a href="https://www.google.com/search?q=php+session+already+started+error">PHP session already started error</a>
nightmare).</p>

<p>This introduction will show you how to use it in a "non-symfony" project:</p>

<ol>
<li><a href="#basics">Basics</a></li>
<li><a href="#examples">Examples</a>

<ul>
<li><a href="#simple-attributes">Simple attributes</a></li>
<li><a href="#deep-attributes">Deep attributes</a></li>
</ul></li>
<li><a href="#going-further">Going further</a>

<ul>
<li><a href="#root-attributes">Root attributes</a></li>
<li><a href="#documentation">Documentation</a></li>
<li><a href="#troubleshooting">Troubleshooting</a></li>
</ul></li>
</ol>

<h2 id="basics">Basics</h2>

<p>In almost any cases, you'll only deal with the following three methods of the
<code>Session</code> object:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\HttpFoundation\Session;

use Symfony\Component\HttpFoundation\Session\SessionBagInterface;

class Session implements SessionInterface, \IteratorAggregate, \Countable
{
    public function registerBag(SessionBagInterface $bag);
    public function start();
    public function getBag($name);
}
</code></pre>

<p>A <code>Bag</code> is a group of attributes stored in the session. Again, in most cases
you'll only deal with the following four methods of the <code>AttributeBag</code> object:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\HttpFoundation\Session\Attribute;

class AttributeBag implements AttributeBagInterface, \IteratorAggregate, \Countable
{
    public function __construct($storageKey = '_sf2_attributes');
    public function setName($name);
    public function get($name, $default = null);
    public function set($name, $value);
}
</code></pre>

<p>When using the sessions, you'll generally need to bootstrap things up as follows:</p>

<pre><code class="php">&lt;?php

$session = new Session();

$myAttributeBag = new AttributeBag('my_storage_key');
$myAttributeBag-&gt;setName('some_descriptive_name');
$session-&gt;registerBag($myAttributeBag);

$session-&gt;start();
</code></pre>

<p>The session <strong>MUST</strong> be started by Symfony, and it <em>SHOULD</em> be started after
the bag registrations.</p>

<h2 id="examples">Examples</h2>

<p>Here's some code samples to make things clear.</p>

<h3 id="simple-attributes">Simple attributes</h3>

<p>Let's assume that our session looks like this:</p>

<pre><code class="php">&lt;?php

$_SESSION = array(
    'user' =&gt; array(
        'first_name' =&gt; 'Arthur',
        'last_name' =&gt; 'Dent',
    ),
);
</code></pre>

<p>Here's the bootstrap code we need:</p>

<pre><code class="php">&lt;?php

$session = new Session();

$userAttributeBag = new AttributeBag('user');
$session-&gt;registerBag($userAttributeBag);

$session-&gt;start();
</code></pre>

<p>The equivalent to:</p>

<pre><code class="php">&lt;?php

$firstName = 'Ford';
if (isset($_SESSION['user']['first_name'])) {
    $firstName = $_SESSION['user']['first_name'];
}
$_SESSION['user']['last_name'] = 'Prefect';
</code></pre>

<p>Would be:</p>

<pre><code class="php">&lt;?php

$userAttributeBag = $session-&gt;getBag('user');

$firstName = $userAttributeBag-&gt;get('first_name', 'Ford');
$userAttributeBag-&gt;set('last_name', 'Prefect');
</code></pre>

<h3 id="deep-attributes">Deep attributes</h3>

<p>Now, let's assume we have a session which has deep attributes:</p>

<pre><code class="php">&lt;?php

$_SESSION = array(
    'authentication' =&gt; array(
        'tokens' =&gt; array(
            'github' =&gt; 'A45E96F',
            'twitter' =&gt; '11AEBC980D456E4EF',
        ),
    ),
);
</code></pre>

<p>Here's the bootstrap code we need:</p>

<pre><code class="php">&lt;?php

$session = new Session();

$authenticationAttributeBag = new NamespacedAttributeBag('authentication');
$session-&gt;registerBag($authenticationAttributeBag);

$session-&gt;start();
</code></pre>

<p>The equivalent to:</p>

<pre><code class="php">&lt;?php

$_SESSION['authentication']['tokens']['github'] = 'AEB558F02C3B346';
</code></pre>

<p>Would be:</p>

<pre><code class="php">&lt;?php

$authenticationAttributeBag = $session-&gt;getBag($authenticationAttributeBag);

$authenticationAttributeBag-&gt;set('tokens/github', 'AEB558F02C3B346');
</code></pre>

<h2 id="going-further">Going further</h2>

<p>The <code>Session</code> has been designed to contain a group of attribute bags. But when
working with legacy sessions, you might have to access attributes which are
located at the root of the session. Here's how to extend the <code>Session</code> to allow
this.</p>

<h3 id="root-attributes">Root attributes</h3>

<p>A root attribute might look like:</p>

<pre><code class="php">&lt;?php

$_SESSION = array(
    'attribute' =&gt; 'value',
);
</code></pre>

<p>You need to create your own kind of <code>Bag</code>:</p>

<pre><code class="php">&lt;?php

namespace Acme\Session;

use Symfony\Component\HttpFoundation\Session\SessionBagInterface;

class RootAttributeBag implements SessionBagInterface
{
    private $name = 'single_attribute';

    /** @var string */
    private $storageKey;

    /** @var mixed */
    private $attribute;

    public function __construct($storageKey)
    {
        $this-&gt;storageKey = $storageKey;
    }

    /** {@inheritdoc} */
    public function getName()
    {
        return $this-&gt;name;
    }

    public function setName($name)
    {
        $this-&gt;name = $name;
    }

    /** {@inheritdoc} */
    public function initialize(array &amp;$array)
    {
        $attribute = !empty($array) ? $array[0] : null;
        $this-&gt;attribute = &amp;$attribute;
    }

    /** {@inheritdoc} */
    public function getStorageKey()
    {
        return $this-&gt;storageKey;
    }

    /** {@inheritdoc} */
    public function clear()
    {
        $this-&gt;attribute = null;
    }

    public function get()
    {
        return $this-&gt;attribute;
    }

    public function set($value)
    {
        $this-&gt;attribute = $value;
    }
}
</code></pre>

<p>The <code>storage key</code> will be directly the attribute's key.</p>

<p>We also need to hack a <code>Storage</code> class which supports our <code>Bag</code>:</p>

<pre><code class="php">&lt;?php

namespace Acme\Session;

use Symfony\Component\HttpFoundation\Session\Storage\NativeSessionStorage;

class LegacySessionStorage extends NativeSessionStorage
{
    /** {@inheritdoc} */
    protected function loadSession(array &amp;$session = null)
    {
        if (null === $session) {
            $session = &amp;$_SESSION;
        }

        $bags = array_merge($this-&gt;bags, array($this-&gt;metadataBag));

        foreach ($bags as $bag) {
            $key = $bag-&gt;getStorageKey();
            // We cast $_SESSION[$key] to an array, because of the SessionBagInterface::initialize() signature
            $session[$key] = isset($session[$key]) ? (array) $session[$key] : array();
            $bag-&gt;initialize($session[$key]);
        }

        $this-&gt;started = true;
        $this-&gt;closed = false;
    }
}
</code></pre>

<p>Finally, we'll need the following bootstrap code:</p>

<pre><code class="php">&lt;?php

use Acme\Session\LegacySessionStorage;
use Acme\Session\RootAttributeBag;
use Symfony\Component\HttpFoundation\Session\Session;

$sessionStorage = new LegacySessionStorage();
$session = new Session($sessionStorage);

// before: $_SESSION['attribute']
$legacyBag = new RootAttributeBag('attribute');
$legacyBag-&gt;setName('legacy');

// after: $session-&gt;getBag('legacy')-&gt;get()
$session-&gt;registerBag($legacyBag);
</code></pre>

<h3 id="documentation">Documentation</h3>

<p><a href="http://symfony.com/doc/current/components/http_foundation/sessions.html">The official documentation</a>
provides useful information about how the session use it.
For example it explains <a href="http://symfony.com/doc/current/components/http_foundation/sessions.html#flash-messages">how to manage flash messages</a>.</p>

<p>It also explains <a href="http://symfony.com/doc/current/components/http_foundation/session_configuration.html">how the session works behind the scene</a>
with useful tips on how to write the session in a database.</p>

<p><a href="http://symfony.com/doc/current/cookbook/session/index.html">Some cookbooks</a> are
also available.
You can find for instance one describing how to use
<a href="http://symfony.com/doc/current/cookbook/session/proxy_examples.html">session proxy</a>
which is useful if you want to encrypt the session data or to make it read
only.</p>

<h3 id="troubleshooting">Troubleshooting</h3>

<p>The common cases of problems encountered are due to the fact that the session
was started before Symfony2 did.</p>

<p>To fix this, check in your <code>php.ini</code> that the <code>session.auto_start</code> option is set
to <code>0</code> (its default value).</p>

<p>If the session isn't auto started, it means that the application is starting the
session itself. If you cannot prevent this, use
<a href="https://github.com/symfony/HttpFoundation/blob/master/Session/Storage/PhpBridgeSessionStorage.php"><code>PhpBridgeSessionStorage</code></a>
with
<a href="https://github.com/symfony/HttpFoundation/blob/master/Session/Storage/Handler/NativeFileSessionHandler.php"><code>NativeFileSessionHandler</code></a>:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\HttpFoundation\Session\Session;
use Symfony\Component\HttpFoundation\Session\Storage\Handler\NativeFileSessionHandler;
use Symfony\Component\HttpFoundation\Session\Storage\PhpBridgeSessionStorage;

$sessionHandler = new NativeFileSessionHandler();
$sessionStorage = new PhpBridgeSessionStorage($sessionHandler);
$session = new Session($sessionStorage);
</code></pre>

<p>Another trouble you can encounter: you register some bags but they're always
empty, even though the <code>$_SESSION</code> contains the targeted values.
This would be because you register your bags after starting the session: if you
can't do otherwise then simply call <code>$session-&gt;migrate()</code> after your bag
registration, this will reload the values.</p>

<p>Finally when doing AJAX request you might notice slow performances, or non
persistence of the data. This might be caused by a
<a href="http://blog.alterphp.com/2012/08/how-to-deal-with-asynchronous-request.html">session locking mechanism</a>
which can be solved like this by saving manually the session:</p>

<pre><code class="php">&lt;?php

$session-&gt;save();
// session_write_close(); // Only required before Symfony 2.1
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>By wrapping <code>$_SESSION</code> and <code>session_*()</code> functions, <code>Session</code> allows you to
make your code more testable
(<a href="http://symfony.com/doc/current/components/http_foundation/session_testing.html">you can mock it</a>)
and to solve starting session issues (just make sure to be the first to start
it).</p>

<p>It's divided into <code>AttributeBag</code> which are arrays of parameters: this allows you
to organize your session by namespaces.</p>

<p>I hope you found some useful tips in this article, if you have any comments or
questions don't be shy and drop me a line on
<a href="https://twitter.com/epiloic">Twitter</a>.</p>
]]></content>
        </entry>
    </feed>