<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[Loïc Faugeron]]></title>
    <link href="https://gnugat.github.io/feed/atom.xml" rel="self"/>
    <link href="https://gnugat.github.io/"/>
    <updated>2016-02-17T07:52:59+00:00</updated>
    <id>http://gnugat.github.com</id>
            <author>
            <name><![CDATA[Loïc Faugeron]]></name>            <email><![CDATA[faugeron.loic@gmail.com]]></email>        </author>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[The Ultimate Developer Guide to Symfony - Routing]]></title>
            <link href="https://gnugat.github.io/2016/02/17/ultimate-symfony-routing.html"/>
            <updated>2016-02-17T00:00:00+00:00</updated>
            <id>https://gnugat.github.io/2016/02/17/ultimate-symfony-routing.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Reference</strong>: This article is intended to be as complete as possible and is
  kept up to date.</p>
  
  <p><strong>TL;DR</strong>:</p>

<pre><code class="php">$parameters = $urlMatcher-&gt;match($request-&gt;getPathInfo());

$request-&gt;attributes-&gt;add(array('_controller' =&gt; $parameters['_controller']);
$request-&gt;attributes-&gt;add(array('_route' =&gt; $parameters['_route']);
unset($parameters['_controller'], $parameters['_route']);
$request-&gt;attributes-&gt;add(array('_route_params' =&gt; $parameters);
</code></pre>
</blockquote>

<p>In this guide we explore the standalone libraries (also known as "Components")
provided by <a href="http://symfony.com">Symfony</a> to help us build applications.</p>

<p>We've already seen:</p>

<ul>
<li><a href="/2016/02/03/ultimate-symfony-http-kernel.html">HTTP Kernel and HTTP Foundation</a></li>
<li><a href="/2016/02/10/ultimate-symfony-event-dispatcher.html">Event Dispatcher</a></li>
</ul>

<p>We're now about to check Routing and YAML, then in the next articles we'll have a look at:</p>

<ul>
<li>Dependency Injection</li>
<li>Console</li>
</ul>

<h2 id="routing">Routing</h2>

<p>Symfony provides a <a href="http://symfony.com/doc/current/components/routing/introduction.html">Routing component</a>
which allows us, for a page, to execute a specific function (also known as "Controller").</p>

<blockquote>
  <p><strong>Note</strong>: Controllers must be a <a href="http://php.net/manual/en/language.types.callable.php">callable</a>,
  for example:</p>
  
  <ul>
  <li>an anonymous function: <code>$controller = function (Request $request) { return new Response() };</code>.</li>
  <li>an array with an instance of a class and a method name:
  <code>$controller = array($controller, 'searchArticles');</code>.</li>
  <li>a fully qualified classname with a static method name:
  <code>$controller = 'Vendor\Project\Controller\ArticleController::searchArticles'</code>.</li>
  </ul>
  
  <p>Controllers can take a Request argument and should return a Response instance.</p>
</blockquote>

<p>It revolves around the following interface:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\Routing\Matcher;

use Symfony\Component\Routing\Exception\ResourceNotFoundException;
use Symfony\Component\Routing\Exception\MethodNotAllowedException;

interface UrlMatcherInterface
{
    /**
     * @param string $pathinfo
     *
     * @return array Route parameters (also contains `_route`)
     *
     * @throws ResourceNotFoundException
     * @throws MethodNotAllowedException
     */
    public function match($pathinfo);
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: For brevity the interface has been stripped from <code>RequestContextAwareInterface</code>.</p>
</blockquote>

<p>In actual applications we don't need to implement it as the component provides
a nice implementation that works with <code>RouteCollection</code>:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\Routing\RouteCollection;
use Symfony\Component\Routing\Route;

$collection = new RouteCollection();
$collection-&gt;add('search_articles', new Route('/v1/articles', array(
    '_controller' =&gt; 'Vendor\Project\Controller\ArticleController::search',
), array(), array(), '', array(), array('GET', 'HEAD')));

$collection-&gt;add('edit_article', new Route('/v1/articles/{id}', array(
    '_controller' =&gt; 'Vendor\Project\Controller\ArticleController::edit',
), array(), array(), '', array(), array('PUT')));
</code></pre>

<p><code>RouteCollection</code> allows us to configure which Request will match our controllers:
via URL patterns and Request method. It also allows us to specify parts of the URLs
as URI parameters (e.g. <code>id</code> in the above snippet).</p>

<p>Building route configuration by interracting with PHP code can be tedious, so the
Routing component supports alternative configuration formats: annotations, XML, YAML, etc.</p>

<blockquote>
  <p><strong>Tip</strong>: have a look at <code>Symfony\Component\Routing\Loader\YamlFileLoader</code>.</p>
</blockquote>

<h2 id="yaml">YAML</h2>

<p>Symfony provides a <a href="http://symfony.com/doc/current/components/yaml/introduction.html">YAML component</a>
which allows us to convert YAML configuration into PHP arrays (and vis versa).</p>

<p>For example the following YAML file:</p>

<pre><code># /tmp/routing.yml
search_articles:
    path: /api/articles
    defaults:
        _controller: "Vendor\Project\Controller\ArticleController::search"
    methods:
        - GET
        - HEAD

edit_article:
    path: "/api/articles/{id}"
    defaults:
        _controller: "Vendor\Project\Controller\ArticleController::edit"
    methods:
        - PUT
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Some string values must be escaped using double quotes because the YAML
  has a list of <a href="http://stackoverflow.com/a/22235064">reserved characters</a>, including:
  <code>@</code>, <code>%</code>, <code>\</code>, <code>-</code>, <code>:</code> <code>[</code>, <code>]</code>, <code>{</code> and <code>}</code>.</p>
</blockquote>

<p>Can be converted using:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\Yaml\Yaml;

$routing = Yaml::parse(file_get_contents('/tmp/routing.yml'));
</code></pre>

<p>This will result in the equivalent of the following array:</p>

<pre><code class="php">&lt;?php

$routing = array(
    'search_articles' =&gt; array(
        'path' =&gt; '/api/articles',
        'defaults' =&gt; array(
            '_controller' =&gt; 'Vendor\Project\Controller\ArticleController::search',
        ),
        'methods' =&gt; array(
            'GET',
            'HEAD',
        ),
    ),
    'edit_article' =&gt; array(
        'path' =&gt; '/api/articles/{id}',
        'defaults' =&gt; array(
            '_controller' =&gt; 'Vendor\Project\Controller\ArticleController::edit',
        ),
        'methods' =&gt; array(
            'PUT',
        ),
    ),
);
</code></pre>

<blockquote>
  <p><strong>Note</strong>: the Routing component uses another component to then build <code>RouteCollection</code>
  from this array: the <a href="http://symfony.com/doc/current/components/config/introduction.html">Config component</a>
  which is out of the scope of this guide.</p>
</blockquote>

<p>There's also <code>$yaml = Yaml::dump($array);</code> that converts a PHP array into a YAML
string.</p>

<h2 id="conclusion">Conclusion</h2>

<p>The Routing component allows us to define which Controllers should be executed
for the given Request, and the Yaml component allows us to configure it in a simple way.</p>

<p>HttpKernel provides a <code>RouterListener</code> which makes use of <code>UrlMatcher</code> when the
Request is received to find a corresponding controller.</p>

<blockquote>
  <p><strong>Note</strong>: <code>Request-&gt;attributes</code> is used to store information about the current
  Request such as the matched route, the controller, etc. It's used internally
  by Symofny but we could also store our onw values in it.</p>
</blockquote>

<p>Some might be concerned with performance: reading the configuration from the
filesystem may slow down the application.</p>

<p>Don't panic! There's a <code>PhpMatcherDumper</code> class which can generate an implementation
of <code>UrlMatcherInterface</code> with all configuration in an optimized way. It might look
like this:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\Routing\Exception\MethodNotAllowedException;
use Symfony\Component\Routing\Exception\ResourceNotFoundException;
use Symfony\Component\Routing\RequestContext;

class appDevUrlMatcher extends Symfony\Bundle\FrameworkBundle\Routing\RedirectableUrlMatcher
{
    public function __construct(RequestContext $context)
    {
        $this-&gt;context = $context;
    }

    public function match($pathinfo)
    {
        $allow = array();
        $pathinfo = rawurldecode($pathinfo);
        $context = $this-&gt;context;

        // edit_article
        if (preg_match('#^/v1/articles/(?P&lt;id&gt;[^/]++)$#s', $pathinfo, $matches)) {
            if ($this-&gt;context-&gt;getMethod() != 'PUT') {
                $allow[] = 'PUT';
                goto not_edit_article;
            }

            return $this-&gt;mergeDefaults(array_replace($matches, array('_route' =&gt; 'edit_article')), array (  '_controller' =&gt; 'Vendor\Project\Controller\ArticleController::edit',));
        }
        not_edit_article:

        // search_articles
        if ($pathinfo === '/v1/articles') {
            if (!in_array($this-&gt;context-&gt;getMethod(), array('GET', 'HEAD'))) {
                $allow = array_merge($allow, array('GET', 'HEAD'));
                goto not_search_articles;
            }

            return array (  '_controller' =&gt; 'app.article_controller:search',  '_route' =&gt; 'Vendor\Project\Controller\ArticleController::search',);
        }
        not_search_articles:

        throw 0 &lt; count($allow) ? new MethodNotAllowedException(array_unique($allow)) : new ResourceNotFoundException();
    }
}
</code></pre>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[The Ultimate Developer Guide to Symfony - Event Dispatcher]]></title>
            <link href="https://gnugat.github.io/2016/02/10/ultimate-symfony-event-dispatcher.html"/>
            <updated>2016-02-10T00:00:00+00:00</updated>
            <id>https://gnugat.github.io/2016/02/10/ultimate-symfony-event-dispatcher.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Reference</strong>: This article is intended to be as complete as possible and is
  kept up to date.</p>
  
  <p><strong>TL;DR</strong>:</p>

<pre><code class="php">$eventDispatcher-&gt;addListener($eventName, $listener1, $priority);
$eventDispatcher-&gt;addListener($eventName, $listener2, $priority - 1);
$eventDispatcher-&gt;dispatch($eventName); // Calls $listener1, then $listener2
</code></pre>
</blockquote>

<p>In this guide we explore the standalone libraries (also known as "Components")
provided by <a href="http://symfony.com">Symfony</a> to help us build applications.</p>

<p>We've already seen:</p>

<ul>
<li><a href="/2016/02/03/ultimate-symfony-http-kernel.html">HTTP Kernel and HTTP Foundation</a></li>
</ul>

<p>We're now about to check Event Dispatcher, then in the next articles we'll have a look at:</p>

<ul>
<li><a href="/2016/02/17/ultimate-symfony-routing.html">Routing and YAML</a></li>
<li>Dependency Injection</li>
<li>Console</li>
</ul>

<h2 id="event-dispatcher">Event Dispatcher</h2>

<p>Symfony provides an <a href="http://symfony.com/doc/current/components/event_dispatcher/introduction.html">EventDispatcher component</a>
which allows the execution of registered function at key points in our applications.</p>

<p>It revolves around the following interface:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\EventDispatcher;

interface EventDispatcherInterface
{
    /**
     * @param string   $eventName
     * @param callable $listener
     * @param int      $priority  High priority listeners will be executed first
     */
    public function addListener($eventName, $listener, $priority = 0);

    /**
     * @param string $eventName
     * @param Event  $event
     */
    public function dispatch($eventName, Event $event = null);
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: This snippet is a truncated version, the actual interface has methods
  to add/remove/get/check listeners and subscribers (which are "auto-configured" listeners).</p>
</blockquote>

<p>An implementation is provided out of the box and can be used as follow:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\EventDispatcher\EventDispatcher;

$eventDispatcher = new EventDispatcher();

$eventDispatcher-&gt;addListener('something_happened', function () {
    echo "Log it\n";
}, 1);
$eventDispatcher-&gt;addListener('something_happened', function () {
    echo "Save it\n";
}, 2);

$eventDispatcher-&gt;dispatch('something_happened');
</code></pre>

<p>This will output:</p>

<pre><code>Save it
Log it
</code></pre>

<p>Since the second listener had a higher priority, it got executed first.</p>

<blockquote>
  <p><strong>Note</strong>: Listeners must be a <a href="http://php.net/manual/en/language.types.callable.php">callable</a>,
  for example:</p>
  
  <ul>
  <li>an anonymous function: <code>$listener = function (Event $event) {};</code>.</li>
  <li>an array with an instance of a class and a method name:
  <code>$listener = array($service, 'method');</code>.</li>
  <li>a fully qualified classname with a static method name:
  <code>$listener = 'Vendor\Project\Service::staticMethod'</code>.</li>
  </ul>
</blockquote>

<p>If we want to provide some context to the listeners (parameters, etc) we can
create a sub-class of <code>Event</code>:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\EventDispatcher\Event;
use Symfony\Component\EventDispatcher\EventDispatcher;

class SomethingHappenedEvent extends Event
{
    private $who;
    private $what;
    private $when;

    public function __construct($who, $what)
    {
        $this-&gt;who = $who;
        $this-&gt;what = $what;
        $this-&gt;when = new \DateTime();
    }

    public function who()
    {
        return $this-&gt;who;
    }

    public function what()
    {
        return $this-&gt;what;
    }

    public function when()
    {
        return $this-&gt;when;
    }
}

$eventDispatcher = new EventDispatcher();

$eventDispatcher-&gt;addListener('something_happened', function (SomethingHappenedEvent $event) {
    echo "{$event-&gt;who()} was {$event-&gt;what()} at {$event-&gt;when()-&gt;format('Y/m/d H:i:s')}\n";
});

$eventDispatcher-&gt;dispatch('something_happened', new SomethingHappenedEvent('Arthur', 'hitchhiking'));
</code></pre>

<h2 id="httpkernel-example">HttpKernel example</h2>

<p>The HttpKernel component we've seen in <a href="/2016/02/03/ultimate-symfony-http-kernel.html">the previous article</a>
provides a <code>Kernel</code> abstract class that heavily relies on EventDispatcher.</p>

<p>For each key steps of its execution, it dispatches the following events:</p>

<ol>
<li><code>kernel.request</code>: gets a <code>Request</code></li>
<li><code>kernel.controller</code>: executes a callable (also known as "Controller")</li>
<li><code>kernel.view</code>: converts the Controller's returned value into a <code>Response</code> (if necessary)</li>
<li><code>kernel.response</code>: returns a <code>Response</code></li>
</ol>

<p>And in case of error:</p>

<ul>
<li><code>kernel.exception</code>: handles errors</li>
</ul>

<p>Just before returning the <code>Response</code>, <code>HttpKernel</code> dispatches one last event:</p>

<ul>
<li><code>kernel.finish_request</code>: clean ups, sending emails, etc</li>
</ul>

<p>After the <code>Response</code> has been displayed, we can dispatch:</p>

<ul>
<li><code>kernel.terminate</code>: same as <code>kernel.finish_request</code>, except it won't slow down
the rendering of request if FastCGI is enabled</li>
</ul>

<p>Please note that <code>kernel.finish_request</code></p>

<h3 id="kernel-request">Kernel Request</h3>

<p>Listeners that registered for <code>kernel.request</code> can modify the Request object.</p>

<p>Out of the box there's a <code>RouterListener</code> registered which sets the following
parameters in <code>Request-&gt;attributes</code>:</p>

<ul>
<li><code>_route</code>: the route name that matched the Request</li>
<li><code>_controller</code>: a callable that will handle the Request and return a Response</li>
<li><code>_route_parameters</code>: query parameters extracted from the Request</li>
</ul>

<p>An example of a custom Listener could be one that decodes JSON content and sets
it in <code>Request-&gt;request</code>:</p>

<pre><code class="php">&lt;?php

namespace AppBundle\EventListener;

use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Event\GetResponseEvent;

/**
 * PHP does not populate $_POST with the data submitted via a JSON Request,
 * causing an empty $request-&gt;request.
 *
 * This listener fixes this.
 */
class JsonRequestContentListener
{
    /**
     * @param GetResponseEvent $event
     */
    public function onKernelRequest(GetResponseEvent $event)
    {
        $request = $event-&gt;getRequest();
        $hasBeenSubmited = in_array($request-&gt;getMethod(), array('PATCH', 'POST', 'PUT'), true);
        $isJson = (1 === preg_match('#application/json#', $request-&gt;headers-&gt;get('Content-Type')));
        if (!$hasBeenSubmited || !$isJson) {
            return;
        }
        $data = json_decode($request-&gt;getContent(), true);
        if (JSON_ERROR_NONE !== json_last_error()) {
            $event-&gt;setResponse(new Response('{"error":"Invalid or malformed JSON"}', 400, array('Content-Type' =&gt; 'application/json')));
        }
        $request-&gt;request-&gt;add($data ?: array());
    }
}
</code></pre>

<p>Another example would be to start a database transaction:</p>

<pre><code class="php">&lt;?php

namespace AppBundle\EventListener;

use PommProject\Foundation\QueryManager\QueryManagerInterface;
use Symfony\Component\HttpKernel\Event\GetResponseEvent;

class StartTransactionListener
{
    /**
     * @var QueryManagerInterface
     */
    private $queryManager;

    /**
     * @param QueryManagerInterface $queryManager
     */
    public function __construct(QueryManagerInterface $queryManager)
    {
        $this-&gt;queryManager = $queryManager;
    }

    /**
     * @param GetResponseEvent $event
     */
    public function onKernelRequest(GetResponseEvent $event)
    {
        $this-&gt;queryManager-&gt;query('START TRANSACTION');
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: <a href="http://pomm-project.org">Pomm</a> is used here as an example.</p>
</blockquote>

<h3 id="kernel-controller">Kernel Controller</h3>

<p>Listeners that registered for <code>kernel.controller</code> can modify the Request object.</p>

<p>This can be useful when we'd like to change the Controller.</p>

<p>For example <code>SensioFrameworkExtraBundle</code> has a <code>ControllerListener</code> that parses
the controller annotations at this point.</p>

<h3 id="kernel-view">Kernel View</h3>

<p>Listeners that registered for <code>kernel.view</code> can modify the Response object.</p>

<p>For example <code>SensioFrameworkExtraBundle</code> has a <code>TemplateListener</code> that uses <code>@Template</code>
annotation: controllers only need to return an array and the listener will create
a response using <a href="http://twig.sensiolabs.org/">Twig</a> (it will pass the array as
Twig parameters).</p>

<h3 id="kernel-response">Kernel Response</h3>

<p>Listeners that registered for <code>kernel.response</code> can modify the Response object.</p>

<p>Out of the box there's a <code>ResponseListener</code> regitered which sets some Response
headers according to the Request's one.</p>

<h3 id="kernel-terminate">Kernel Terminate</h3>

<p>Listeners that registered for <code>kernel.terminate</code> can execute actions after the
Response has been served (if our web server uses FastCGI).</p>

<p>An example of a custom Listener could be one that rollsback a database transaction,
when running in test environment:</p>

<pre><code class="php">&lt;?php

namespace AppBundle\EventListener\Pomm;

use PommProject\Foundation\QueryManager\QueryManagerInterface;
use Symfony\Component\HttpKernel\Event\PostResponseEvent;

class RollbackListener
{
    /**
     * @var QueryManagerInterface
     */
    private $queryManager;

    /**
     * @param QueryManagerInterface $queryManager
     */
    public function __construct(QueryManagerInterface $queryManager)
    {
        $this-&gt;queryManager = $queryManager;
    }

    /**
     * @param PostResponseEvent $event
     */
    public function onKernelTerminate(PostResponseEvent $event)
    {
        $this-&gt;queryManager-&gt;query('ROLLBACK');
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: We'll se later how to register this listener only for test environment.</p>
</blockquote>

<h3 id="kernel-exception">Kernel Exception</h3>

<p>Listeners that registered for <code>kernel.exception</code> can catch an exception and generate
an appropriate Response object.</p>

<p>An example of a custom Listener could be one that logs debug information and generates
a 500 Response:</p>

<pre><code class="php">&lt;?php

namespace AppBundle\EventListener;

use Psr\Log\LoggerInterface;
use Ramsey\Uuid\Uuid;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Event\GetResponseForExceptionEvent;

class ExceptionListener
{
    /**
     * @var LoggerInterface
     */
    private $logger;

    /**
     * @param LoggerInterface $logger
     */
    public function __construct(LoggerInterface $logger)
    {
        $this-&gt;logger = $logger;
    }

    /**
     * @param GetResponseForExceptionEvent $event
     */
    public function onKernelException(GetResponseForExceptionEvent $event)
    {
        $exception = $event-&gt;getException();
        $token = Uuid::uuid4()-&gt;toString();
        $this-&gt;logger-&gt;critical(
            'Caught PHP Exception {class}: "{message}" at {file} line {line}',
            array(
                'class' =&gt; get_class($exception),
                'message' =&gt; $exception-&gt;getMessage(),
                'file' =&gt; $exception-&gt;getFile(),
                'line' =&gt; $exception-&gt;getLine()
                'exception' =&gt; $exception,
                'token' =&gt; $token
            )
        );
        $event-&gt;setResponse(new Response(
            json_encode(array(
                'error' =&gt; 'An error occured, if it keeps happening please contact an administrator and provide the following token: '.$token,
            )),
            500,
            array('Content-Type' =&gt; 'application/json'))
        );
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: <a href="https://benramsey.com/projects/ramsey-uuid/">Ramsey UUID</a> is used
  here to provide a unique token that can be referred to.</p>
</blockquote>

<h2 id="conclusion">Conclusion</h2>

<p>EventDispatcher is another example of a simple yet powerful Symfony component.
HttpKernel uses it to configure a standard "Symfony application", but also to
allow us to change its behaviour.</p>

<p>In this article we've seen the basics and how it works behind the hood when used
by HttpKernel, but we could create our own event and dispatch it to make our
own code "Open for extension, but Close to modification"
(<a href="https://blog.8thlight.com/uncle-bob/2014/05/12/TheOpenClosedPrinciple.html">Open/Close principle</a>).</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[The Ultimate Developer Guide to Symfony - HTTP Kernel]]></title>
            <link href="https://gnugat.github.io/2016/02/03/ultimate-symfony-http-kernel.html"/>
            <updated>2016-02-03T00:00:00+00:00</updated>
            <id>https://gnugat.github.io/2016/02/03/ultimate-symfony-http-kernel.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Reference</strong>: This article is intended to be as complete as possible and is
  kept up to date.</p>
  
  <p><strong>TL;DR</strong>: <code>$response = $httpKernel-&gt;handle($request);</code></p>
</blockquote>

<p><a href="http://symfony.com">Symfony</a> provides many standalone libraries (also known as
"Components") that help us build applications.</p>

<p>In this guide we'll see the main ones that allow us to build an application:</p>

<ul>
<li>HTTP Kernel and HTTP Foundation</li>
<li><a href="/2016/02/10/ultimate-symfony-event-dispatcher.html">Event Dispatcher</a></li>
<li><a href="/2016/02/17/ultimate-symfony-routing.html">Routing and YAML</a></li>
<li>Dependency Injection</li>
<li>Console</li>
</ul>

<h2 id="http-kernel">HTTP kernel</h2>

<p>Symfony provides a <a href="http://symfony.com/doc/current/components/http_kernel/introduction.html">HttpKernel component</a>
which follows the HTTP protocol: it converts a <code>Request</code> into a <code>Response</code>.</p>

<p>It all revolves around the following interface:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\HttpKernel;

use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

interface HttpKernelInterface
{
    const MASTER_REQUEST = 1;
    const SUB_REQUEST = 2;

    /**
     * @param Request $request
     * @param int     $type
     * @param bool    $catch   Whether to catch exceptions or not
     *
     * @return Response
     */
    public function handle(Request $request, $type = self::MASTER_REQUEST, $catch = true);
}
</code></pre>

<h2 id="httpfoundation">HttpFoundation</h2>

<p>HttpKernel relies on the <a href="http://symfony.com/doc/current/components/http_foundation/introduction.html">HttpFoundation component</a>
which mainly provides:</p>

<ul>
<li><code>Request</code>: wraps <code>$_GET</code>, <code>$_POST</code>, <code>$_COOKIE</code>, <code>$_FILES</code> and <code>$_SERVER</code></li>
<li><code>Response</code>: wraps <code>header()</code> and <code>setcookie()</code>, but also displays the content</li>
</ul>

<blockquote>
  <p><strong>Note</strong>: Global variables have the drawback to be possibly accessed by many
  functions, causing their state to be unpredictable (hence bugs happen and they
  are hard to find/understand).</p>
  
  <p>With HttpFoundation, <a href="http://php.net/manual/en/language.variables.superglobals.php">PHP super globals</a>
  shouldn't be accessed directly, but rather via the objects that wraps them
  (e.g. <code>Request</code>) which are passed around (those objects are not global).</p>
</blockquote>

<p>Here's a typical usage:</p>

<pre><code class="php">$request = Request::createFromGlobals();
$response = $httpKernel-&gt;handle($request);
$reponse-&gt;send();
</code></pre>

<p>In the above example, <code>Request</code> will be initialized using PHP super globals.
Sometimes it can be useful to build it with our own provided values (e.g. for tests):</p>

<pre><code class="php">$uri = '/v1/items';
$method = 'POST';
$parameters = array(); // GET or POST parameters, usually left unused (use uri and content instead)
$cookies = array();
$files = array();
$headers = array('CONTENT_TYPE' =&gt; 'application/json');
$content = json_encode(array('name' =&gt; 'Arthur Dent'));

$request = Request::create($uri, $method, $getOrPostParameters, $cookies, $files, $headers, $content);
</code></pre>

<p>In our application, we'll mainly extract its parameters:</p>

<pre><code class="php">$getParameter = $request-&gt;query-&gt;get('description'); // e.g. from URI `/?description=hitchhicker`
$postParameter = $request-&gt;request-&gt;get('name'); // e.g. from content `name=Arthur`
$header = $request-&gt;headers-&gt;get('Content-Type'); // e.g. from headers `Content-Type: application/x-www-form-urlencoded`

$customParameter = $request-&gt;attributes-&gt;get('_route'); // We'll see more about it in the next article
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Those public properties are instances of <code>Symfony\Component\HttpFoundation\ParameterBag</code>,
  except <code>headers</code> which is an instance of <code>Symfony\Component\HttpFoundation\HeaderBag</code>.</p>
</blockquote>

<p>In our application we'll mainly build <code>Response</code>:</p>

<pre><code class="php">$content = json_encode(array('name' =&gt; 'Arthur Dent'));
$status = 201;
$headers = array('Content-Type' =&gt; 'application/json');

$response = new Reponse($content, $status, $headers);
</code></pre>

<h2 id="example">Example</h2>

<p>Let's create a small Hello World example:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\HttpKernel\HttpKernelInterface;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class HelloWorldHttpKernel implements HttpKernelInterface
{
    public function handle(Request $request, $type = self::MASTER_REQUEST, $catch = true)
    {
        $name = $request-&gt;query-&gt;get('name', 'World');

        return new Response("Hello $name!", 200);
    }
}

$httpKernel = new HelloWorldHttpKernel();

$request = Request::createFromGlobals();
$response = $httpKernel-&gt;handle($request);
$response-&gt;send();
</code></pre>

<p>So we can get the following:</p>

<ul>
<li>for <code>/</code> URL, we get <code>Hello World!</code></li>
<li>for <code>/?name=Arthur</code> URL, we get <code>Hello Arthur!</code></li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>Symfony provides a simple yet powerful component allowing us to follow the HTTP
protocol.</p>

<p>In this article we've seen the basics and how it works behind the hood, but in
an actual application we don't necessarily need to create our own implementation
of <code>HttpKernelInterface</code>.</p>

<p>Indeed there's a <code>Symfony\Component\HttpKernel\Kernel</code> abstract class that can
be used out of the box. It provides many features that we'll explore in the next
articles:</p>

<ul>
<li><a href="/2016/02/10/ultimate-symfony-event-dispatcher.html">Event Dispatcher</a></li>
<li>Routing and YAML</li>
<li>Dependency Injection</li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Links from 2015]]></title>
            <link href="https://gnugat.github.io/2016/01/27/links-from-2015.html"/>
            <updated>2016-01-27T00:00:00+00:00</updated>
            <id>https://gnugat.github.io/2016/01/27/links-from-2015.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: Links I tweeted during 2015</p>
</blockquote>

<p>It's funny how old principles are still useful today. In 2015, the most important
ones I've learned are the following:</p>

<ul>
<li>Command/Query Responsibility Segregation (CQRS): separate the "read" logic from
the "write" logic</li>
<li>Event Sourcing (ES): recording every action done for analytics and rollback
purpose</li>
<li>Command Bus: store and validate input in a Command object, pass it to a
Command Bus middleware that will find and execute the appropriate
Command Handler which will execture the logic</li>
<li>Framework / Library agnosticism: decouple from vendors to be able to
change/upgrade them without friction</li>
<li>microservices: reduce the scope of an API, organize them into a communicating network</li>
<li>Monolithic Repository: store related applications in the same git repository</li>
</ul>

<p>It was a year full of links, so here they are!</p>

<h2 id="articles-highlight">Articles Highlight</h2>

<ul>
<li><a href="http://blog.confluent.io/2015/05/27/using-logs-to-build-a-solid-data-infrastructure-or-why-dual-writes-are-a-bad-idea/">Using logs to build a solid data infrastructure, or why dual writes are a bad idea</a></li>
<li><a href="https://codeascraft.com/2015/07/29/targeting-broad-queries-in-search/">Targeting broad queries in search</a></li>
</ul>

<h2 id="tools-highlight">Tools Highlight</h2>

<ul>
<li><a href="http://docs.puli.io/en/latest/">Puli</a>:

<ul>
<li><a href="http://webmozarts.com/2015/01/12/puli-1-0-beta-released/">1.0-beta release</a></li>
<li>Slides: <a href="https://speakerdeck.com/webmozart/puli-phps-next-package-revolution">Pulis, PHP next package revolution</a></li>
<li><a href="http://webmozarts.com/2015/01/14/resource-discovery-with-puli/">Resource discovery</a></li>
<li><a href="http://webmozarts.com/2015/03/20/managing-web-resources-with-puli/">Managing web resources</a></li>
</ul></li>
<li>Refactoring Browser:

<ul>
<li><a href="http://martinfowler.com/articles/refactoringRubicon.html">Refactoring Rubicon</a></li>
<li><a href="https://github.com/QafooLabs/php-refactoring-browser">Qafoo PHP RefactoringBrowser</a></li>
</ul></li>
<li><a href="https://github.com/padraic/humbug">Humbug</a>:

<ul>
<li><a href="http://blog.astrumfutura.com/2015/01/lies-damned-lies-and-code-coverage-towards-mutation-testing/">Code Coverage lies, toward mutation testing</a></li>
<li><a href="http://blog.astrumfutura.com/2015/04/introduction-to-humbug-a-mutation-testing-framework-for-php/">Introduction to Humbug, a mutation testing framework for PHP</a></li>
<li><a href="http://davedevelopment.co.uk/2015/01/07/probing-test-suite-quality-with-mutation-testing.html">Probing test suite quality with mutation testing</a></li>
</ul></li>
<li><a href="https://tactician.thephpleague.com/">Tactician, the PHP Command Bus</a>:

<ul>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2015/01/a-wave-of-command-buses/">A wave of Command Buses</a></li>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2015/01/responsibilities-of-the-command-bus/">Responsibilities of the Command Bus</a></li>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2015/01/from-commands-to-events/">From Commands to Events</a></li>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2015/01/some-questions-about-the-command-bus/">Command Bus FAQ</a></li>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2015/01/collecting-events-and-the-events-aware-command-bus/">Collecting events and the EventsAware Command Bus</a></li>
<li><a href="http://verraes.net/2015/01/messaging-flavours/">Messaging Flavours</a></li>
<li><a href="http://verraes.net/2015/02/form-command-model-validation/">Form Command model validation</a></li>
<li><a href="http://boldradius.com/blog-post/VSQCySkAACcA4k5J/easy-scalability-with-akka">CQRS vs CRUD performances and scalability</a></li>
</ul></li>
<li><a href="http://lnav.org/">The log file navigator</a></li>
<li><a href="https://github.com/ramsey/uuid">UUID</a>:

<ul>
<li><a href="https://philsturgeon.uk/http/2015/09/03/auto-incrementing-to-destruction/">auto incrementing to destruction</a></li>
<li><a href="https://www.clever-cloud.com/blog/engineering/2015/05/20/Why-Auto-Increment-Is-A-Terrible-Idea">Why auto incrementing is a terrible idea</a></li>
</ul></li>
<li>Pomm:

<ul>
<li><a href="http://www.pomm-project.org/news/pomm-2-0-0-is-out.html">Pomm 2.0 is out</a></li>
<li><a href="http://www.pomm-project.org/news/a-short-focus-on-pomm-s-foundation.html">A short focus on Pomm Foundation</a></li>
</ul></li>
</ul>

<h2 id="interesting-talks">Interesting Talks</h2>

<ul>
<li>Monolithic Repository:

<ul>
<li><a href="https://qafoo.com/talks/15_08_froscon_monorepos.pdf">Monolithic Repository</a></li>
<li><a href="http://www.slideshare.net/StenHiedel/symfony-uk-meetup-21-may">How to manage multiple Composer packages within a single respository</a></li>
<li>see also article: <a href="http://sroze.io/2015/09/14/managing-monolith-repositories-with-composers-path-repository/">Managing monolith repositories with composers path repository</a></li>
</ul></li>
<li>Doctrine:

<ul>
<li><a href="https://qafoo.com/talks/15_09_symfony_live_london_doctrine2_to_use_or_not_to_use.pdf">Doctrine: to use or not to use</a></li>
<li><a href="http://ocramius.github.io/blog/doctrine-orm-optimization-hydration/">Doctrine ORM optimization hydration</a></li>
</ul></li>
<li>PHP Interoperability:

<ul>
<li><a href="https://speakerdeck.com/michaelcullum/php-fig-the-psrs-you-dont-know-about">PHP FIG, the PSRs you do not know about</a></li>
<li><a href="http://mnapoli.fr/presentations/psr-0-12/">PSR 0 to 12</a></li>
<li><a href="http://talks.ppi.io/20150513-phpsw">The PHP Interoperability Framework</a></li>
</ul></li>
<li>Desgin:

<ul>
<li><a href="http://www.slideshare.net/mobile/CiaranMcNulty/why-your-test-suite-sucks">Why your test suite sucks</a></li>
<li><a href="https://speakerdeck.com/jakzal/embracing-change">Embracing change</a></li>
<li><a href="http://www.slideshare.net/mobile/CiaranMcNulty/driving-design-through-examples">Driving design through examples</a></li>
<li><a href="http://www.slideshare.net/NicolPignatelli/brownfield-domain-driven-design-48240538">Brownfield Domain Driven Desgin</a></li>
<li><a href="http://www.slideshare.net/matthiasnoback/the-quest-for-global-design-principles">The quest for global design principles</a></li>
<li><a href="http://www.slideshare.net/matthiasnoback/hexagonal-architecture-messageoriented-software-design">Hexagonal architecture, message oriented software design</a></li>
<li><a href="http://moquet.net/talks/phptour-2015">CQRS and Event Sourcing</a></li>
</ul></li>
<li><a href="https://speakerdeck.com/odolbeau/symfony2-killed-me">Symfony killed me</a></li>
<li><a href="https://speakerdeck.com/odolbeau/logs-hunting">Logs hunting</a></li>
<li><a href="http://www.slideshare.net/cakper/2014-0821-symfony-uk-meetup-scaling-symfony2-apps-with-rabbit-mq">Scaling Symofny apps with RabbitMq</a></li>
<li><a href="http://andrewcarteruk.github.io/slides/breaking-boundaries-with-fastcgi-symfony/#/">Breaking boundaries with FastCGI Symfony</a></li>
<li>in french: <a href="https://speakerdeck.com/lyrixx/symfony-live-2015-paris-monitorer-sa-prod">Monitorer sa prod</a></li>
</ul>

<h2 id="tests%3A">Tests:</h2>

<ul>
<li>Test Driven Desing (TDD):

<ul>
<li><a href="http://codurance.com/2015/05/12/does-tdd-lead-to-good-design/">Does TDD lead to good design?</a></li>
<li><a href="https://medium.com/@davidihunt/tdd-and-complexity-1bbd5ca51ee7">TDD and complexity</a></li>
</ul></li>
<li><a href="http://verraes.net/2015/01/economy-of-tests/">Economy of tests</a></li>
<li><a href="http://blog.8thlight.com/dariusz-pasciak/2015/01/12/your-test-suite-is-useless.html">Your test suite is useless</a></li>
<li><a href="https://sites.google.com/site/unclebobconsultingllc/specs-vs-tests">Specs VS Tests</a></li>
<li><a href="http://googletesting.blogspot.co.uk/2015/04/just-say-no-to-more-end-to-end-tests.html">Just say no to more end to end tests</a></li>
<li><a href="http://elnur.pro/testing-is-not-a-choice/">Testing is not a choice</a></li>
<li><a href="http://tech.mybuilder.com/coupling-tests/">Coupling tests</a></li>
<li><a href="https://developer.atlassian.com/blog/2015/05/open-letter-from-an-ignored-test/">Open letter from an ignored test</a></li>
<li><a href="https://cucumber.io/blog/2015/03/24/single-source-of-truth">Single source of truth</a></li>
<li><a href="http://dannorth.net/introducing-bdd/">Introducing BDD</a></li>
<li><a href="http://martinfowler.com/articles/nonDeterminism.html">Eradicating Non-Determinism in Tests</a></li>
</ul>

<h2 id="php-interoperability">PHP Interoperability</h2>

<ul>
<li>PSR 7:

<ul>
<li><a href="https://mwop.net/blog/2015-01-08-on-http-middleware-and-psr-7.html">On HTTP middleware and PSR 7</a></li>
<li><a href="https://mwop.net/blog/2015-01-26-psr-7-by-example.html">PSR 7 by example</a></li>
<li><a href="http://srcmvn.com/blog/2015/02/18/psr-7-and-the-future-of-php/">PSR 7 and the future of PHP</a></li>
<li><a href="http://evertpot.com/psr-7-issues/">PSR 7 issues</a></li>
<li><a href="http://symfony.com/blog/psr-7-support-in-symfony-is-here">PSR 7 support in Symfony is here</a></li>
<li><a href="http://dunglas.fr/2015/06/using-psr-7-in-symfony">Using PSR 7 in Symfony</a></li>
<li><a href="http://blog.madewithlove.be/post/http-client-for-sdks/">HTTP client for SDKs</a></li>
</ul></li>
<li><a href="http://mouf-php.com/psr7-container-interop-equals-cross-framework-module-system">PSR 7 Container Interop = cross framework module system</a></li>
<li><a href="http://mouf-php.com/psr-11-use-cases">PSR 11 use cases</a></li>
<li><a href="http://www.thecodingmachine.com/psr-11-performance-impact-of-the-delegate-lookup-feature/">PSR 11, performance impact of the delegate look-up feature</a></li>
<li><a href="http://blog.phpdeveloper.org/2015/05/22/php-security-psr-9psr-10/">PHP Security PSR 9 and 10</a></li>
<li><a href="https://www.acquia.com/blog/psr-what-shared-standards-bright-future">PSR-What? Shared Standards for a Bright Future</a></li>
</ul>

<h2 id="pet-projects">Pet projects</h2>

<ul>
<li><a href="https://github.com/gnugat/redaktilo/releases/tag/v1.7.0">Redaktilo 1.7</a></li>
<li><a href="https://gist.github.com/gnugat/492a192f9f57c00098b1">Stack middleware to rollback database transactions</a></li>
<li><a href="http://memio.github.io/memio/">Memio</a>:

<ul>
<li><a href="https://github.com/ciaranmcnulty/phpspec-typehintedmethods">its origin</a></li>
<li><a href="https://github.com/memio/spec-gen">SpecGen</a></li>
</ul></li>
<li>Symfony Micro Framework:

<ul>
<li><a href="https://github.com/gnugat/symfony-empty-edition">Symfony Empty Edition</a></li>
<li><a href="https://github.com/gnugat/micro-framework-bundle">MicroFrameworkBundle</a></li>
</ul></li>
</ul>

<h2 id="design-patterns">Design Patterns</h2>

<ul>
<li><a href="http://shawnmc.cool/the-repository-pattern">The Repository pattern</a></li>
<li><a href="http://enterprisecraftsmanship.com/2015/04/13/dto-vs-value-object-vs-poco">DTO vs Value Object vs POCO</a></li>
<li><a href="http://engineering.peertransfer.com/blog/decoupling-logic-architecture-repositories">Decoupling architecture and domain with repositories</a></li>
<li><a href="http://rob.conery.io/2014/03/04/repositories-and-unitofwork-are-not-a-good-idea/">Repositories On Top UnitOfWork Are Not a Good Idea</a></li>
</ul>

<h2 id="microservice">microservice</h2>

<ul>
<li><a href="http://martinfowler.com/bliki/MicroservicePremium.html">Microservice Premium</a></li>
<li><a href="http://martinfowler.com/bliki/MonolithFirst.html">Monolith First</a></li>
<li><a href="http://martinfowler.com/articles/dont-start-monolith.html">Don't start with a monolith</a></li>
<li><a href="http://capgemini.github.io/architecture/is-rest-best-microservices">Is REST best microservices</a></li>
<li><a href="http://martinfowler.com/articles/microservice-trade-offs.html">Microservices trade offs</a></li>
<li><a href="http://blog.christianposta.com/microservices/youre-not-going-to-do-microservices/">You're not going to do microservices</a></li>
</ul>

<h2 id="refactoring">Refactoring</h2>

<ul>
<li><a href="http://martinfowler.com/articles/refactoring-external-service.html">Refactoring external service</a></li>
<li>Refactoring the cat API client:

<ul>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2015/07/refactoring-the-cat-api-client-part-1/">part 1</a></li>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2015/07/refactoring-the-cat-api-client-part-2/">part 2</a></li>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2015/07/refactoring-the-cat-api-client-part-3/">part 3</a></li>
</ul></li>
</ul>

<h2 id="keep-it-simple">Keep it Simple</h2>

<ul>
<li><a href="http://97things.oreilly.com/wiki/index.php/Simplicity_before_generality,_use_before_reuse">Simplicity before generality, use before reuse</a></li>
<li><a href="http://blog.ircmaxell.com/2015/03/thoughts-on-design-of-apis.html">Thoughts on design of APIs</a></li>
<li><a href="http://verraes.net/2014/08/dry-is-about-knowledge/">DRY is about knowledge</a></li>
</ul>

<h2 id="oop">OOP</h2>

<ul>
<li><a href="https://www.thoughtworks.com/insights/blog/composition-vs-inheritance-how-choose">Composition VS inheritance, how to choose</a></li>
<li><a href="http://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en">The meaning of Object Oriented Programming</a></li>
</ul>

<h2 id="git">Git</h2>

<ul>
<li><a href="https://akrabat.com/the-beginners-guide-to-rebasing-your-pr/">The beginners guide to rebasing your PR</a></li>
<li><a href="http://jeffkreeftmeijer.com/2010/the-magical-and-not-harmful-rebase/">The magical and not harmful rebase</a></li>
<li><a href="http://blog.rjkip.nl/2015/08/28/gits-interactive-patch-mode/">Git's interractive patch mode</a></li>
<li><a href="http://blog.8thlight.com/makis-otman/2015/07/08/git-disciplined.html">Git disciplined</a></li>
<li><a href="http://zachholman.com/posts/git-commit-history/">Utter Disregard for Git Commit History</a></li>
</ul>

<h2 id="security">Security</h2>

<ul>
<li><a href="http://www.antirez.com/news/96">A few things about Redis security</a></li>
<li><a href="http://blog.slaks.net/2015-10-13/web-authentication-arms-race-a-tale-of-two-security-experts/">The Web Authentication Arms Race – A Tale of Two Security Experts</a></li>
<li><a href="https://paragonie.com/blog/2015/04/secure-authentication-php-with-long-term-persistence">Secure authentication PHP with long term persistence</a></li>
</ul>

<h2 id="postgresql">PostgreSQL</h2>

<ul>
<li>What PostgreSQL has over other Open Source SQL databases:

<ul>
<li><a href="https://www.compose.io/articles/what-postgresql-has-over-other-open-source-sql-databases/">part 1</a></li>
<li><a href="https://www.compose.io/articles/what-postgresql-has-over-other-open-source-sql-databases-part-ii/">part 2</a></li>
</ul></li>
<li><a href="http://rob.conery.io/2014/05/29/a-better-id-generator-for-postgresql/">A better ID generator for PostgreSQL</a></li>
<li><a href="http://hashrocket.com/blog/posts/faster-json-generation-with-postgresql">Faster JSON generation with PostgreSQL</a></li>
<li><a href="http://developer.olery.com/blog/goodbye-mongodb-hello-postgresql/">Goodbye MongoDB, hello PostgreSQL</a></li>
</ul>

<h2 id="rest">REST</h2>

<ul>
<li><a href="http://www.nurkiewicz.com/2015/07/restful-considered-harmful.html">RESTful considered harmful</a></li>
<li><a href="http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api">Best practices for a pragmatic RESTful API</a></li>
</ul>

<h2 id="performance">Performance</h2>

<ul>
<li><a href="https://tideways.io/profiler/blog/5-doctrine-orm-performance-traps-you-should-avoid">5 Doctrine ORM performance traps you should avoid</a></li>
<li><a href="https://tideways.io/profiler/blog/essential-macro-optimizations-to-improve-php-performance">Essential macro optimizations to improve PHP performance</a></li>
<li><a href="https://tideways.io/profiler/blog/5-ways-to-optimize-symfony-baseline-performance">5 ways to optimize Symfony baseline performance</a></li>
<li><a href="http://marcjschmidt.de/blog/2014/02/08/php-high-performance.html">PHP high performance</a></li>
<li><a href="http://phpfastcgi.github.io/general/2015/11/04/introducing-phpfastcgi.html">Intproducting PHP FastCGI</a></li>
<li><a href="http://blog.kevingomez.fr/til/2015/07/26/why-is-uniqid-slow/">Why is uniqid slow?</a></li>
</ul>

<h2 id="agile">Agile</h2>

<ul>
<li><a href="http://jelrik.me/blog/2015/10/17/transform-your-standup/">Transform your stand up</a></li>
<li><a href="http://blog.8thlight.com/malcolm-newsome/2015/01/15/they-wont-be-interested.html">They won't be interrested</a></li>
<li><a href="http://blog.cleancoder.com/uncle-bob/2015/04/15/DoesOrganizationMatter.html">Does organization matter</a></li>
<li><a href="http://benjiweber.co.uk/blog/2015/04/17/modern-extreme-programming/">Modern extreme programming</a></li>
<li><a href="http://frankneff.ch/business/2015/04/21/if-pragmatism-raises-technical-debt-call-it-oversimplification/">If pragmatism raises technical debt, call it over simplification</a></li>
<li><a href="http://www.mountaingoatsoftware.com/blog/dont-blindly-follow">Don't blindly follow</a></li>
<li><a href="http://mattbriggs.net/blog/2015/06/01/the-role-of-a-senior-developer/">The role of a senior developer</a></li>
<li><a href="http://blog.toolshed.com/2015/05/the-failure-of-agile.html">The failure of agile</a></li>
<li><a href="http://mikehadlow.blogspot.fr/2014/06/heisenberg-developers.html">Heisenberg developers</a></li>
</ul>

<h2 id="ddd">DDD</h2>

<ul>
<li><a href="http://weronikalabaj.com/to-ddd-or-not-to-ddd-what-to-do-if-your-domain-is-boring/">To DDD or not to DDD, what to do if your domain is boring</a></li>
<li><a href="https://lostechies.com/gabrielschenker/2015/04/16/ddd-revisited/">DDD revisited</a></li>
<li><a href="http://codebetter.com/iancooper/2011/07/15/why-crud-might-be-what-they-want-but-may-not-be-what-they-need/">Why CRUD might be what they want but not what they need</a></li>
</ul>

<h2 id="symfony">Symfony</h2>

<ul>
<li><a href="http://jolicode.com/blog/do-not-use-fosuserbundle">Do not use FOSUserBundle</a></li>
<li><a href="http://mmoreram.github.io/blog/2015/08/20/re-thinking-event-listeners/">Re-thinking event listeners</a></li>
<li><a href="http://thorpesystems.com/blog/tagging-symfony-services">Tagging Symfony services</a></li>
<li><a href="https://www.pmg.com/blog/symfony-from-scratch/">Symfony from scratch</a></li>
<li><a href="http://programmingarehard.com/2015/03/04/structing-my-application.html">Structuring my application</a></li>
<li><a href="http://mmoreram.com/blog/2015/11/20/your-packages-dependencies/">Your package dependencies</a></li>
</ul>

<h2 id="misc">Misc</h2>

<ul>
<li><a href="http://kukuruku.co/hub/programming/do-not-learn-frameworks-learn-the-architecture">Do not learn frameworks, lean the architecture</a></li>
<li><a href="http://blog.8thlight.com/uncle-bob/2015/08/06/let-the-magic-die.html">Let the magic die</a></li>
<li><a href="http://www.levelofindirection.com/journal/2015/5/1/naming-is-hard-or-is-it.html">Naming is hard, or is it?</a></li>
<li><a href="http://www.freeklijten.nl/home/2015/06/24/Setter-anxiety">Setter anxiety</a></li>
<li><a href="http://blog.codinghorror.com/doing-terrible-things-to-your-code/">Doing terrible things to your code</a></li>
<li><a href="http://www.stilldrinking.org/programming-sucks">Programming sucks</a></li>
<li><a href="http://evertpot.com/switching-to-generators/">Switching to generators</a></li>
<li><a href="http://www.vertabelo.com/blog/technical-articles/orms-under-the-hood">ORMs under the hood</a></li>
<li><a href="http://blog.pivotal.io/pivotal-labs/labs/hexagonal-rails-and-the-ludicrous-terminal-application">Hexagonal</a></li>
<li><a href="http://burnout.io/">Burnout</a></li>
<li><a href="http://rosstuck.com/formatting-exception-messages/">Formatting exception messages</a></li>
<li><a href="http://mnapoli.fr/approaching-coding-style-rationally/">Approaching coding style rationally</a></li>
<li><a href="http://blog.frankdejonge.nl/pipelines-immutability-and-privates/">Pipelines, imutability and privates</a></li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony Micro Framework]]></title>
            <link href="https://gnugat.github.io/2015/12/23/symfony-micro-framework.html"/>
            <updated>2015-12-23T00:00:00+00:00</updated>
            <id>https://gnugat.github.io/2015/12/23/symfony-micro-framework.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TD;DR</strong>: <a href="http://symfony.com">Symfony</a> has always been able to be used as a micro
  framework.
  For more "add what you need" micro-framework like spirit, use the <a href="http://github.com/gnugat/symfony-empty-edition">Empty Edition</a>
  and the <a href="http://github.com/gnugat/micro-framework-bundle">MicroFrameworkBundle</a>.</p>
</blockquote>

<p>There are many definitions out there to qualify a framework as being "micro", among
them the following criterias often appear:</p>

<ul>
<li>small API (usage of framework's code in your application)</li>
<li>few Lines Of Code (LOC)</li>
<li>few dependencies (how many third party libraries are used)</li>
<li>small footprint (framework loading time)</li>
</ul>

<p>Is Symfony a micro framework as well? Let's find out.</p>

<blockquote>
  <p><strong>Note</strong>: To know more about how to determine if a framework is micro, read
  <a href="https://igor.io/archive.html">Igor Wiedler</a> article: <a href="https://igor.io/2013/09/02/how-heavy-is-silex.html">How heavy is Silex?</a>.</p>
</blockquote>

<h2 id="measuring">Measuring</h2>

<p>While "Hello World" examples rarely reflect real world applications, it's going
to be good enough to serve the purpose of this article: getting a good measure of
Symfony's API, LOC, dependencies and footprint.</p>

<p>Since dependencies and footprint are easy to measure, we're going to rely on it.
However, all benchmarks are relative to the computer that executes them, so we need
a point of reference: a flat PHP "Hello World" application:</p>

<pre><code class="php">&lt;?php
// index.php

echo 'Hello World';
</code></pre>

<p>Let's run the benchmark:</p>

<pre><code>php -S localhost:2501 &amp;
ab -c 10 -t 10 'http://localhost:2501/index.php'
killall php
</code></pre>

<p>Result: <strong>6 915.03</strong> Requests per second.</p>

<h2 id="standard-edition">Standard Edition</h2>

<p>To get the Standard Edition, we can use composer:</p>

<pre><code>composer create-project symfony/framework-standard-edition
cd framework-standard-edition
</code></pre>

<p>Since the standard edition follows a "solve 80% of use cases out of the box" philosohpy,
it's almost ready, we just need to tweak the given controller:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Controller/DefaultController.php

namespace AppBundle\Controller;

use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class DefaultController extends Controller
{
    /**
     * @Route("/", name="homepage")
     */
    public function indexAction(Request $request)
    {
        return new Response('Hello World');
    }
}
</code></pre>

<p>Let's run the benchmark:</p>

<pre><code>SYMFONY_ENV=prod composer update -o --no-dev
php -S localhost:2502 -t web &amp;
ab -c 10 -t 10 'http://localhost:2502/app.php'
killall php
</code></pre>

<p>Result: <strong>134.23</strong> Requests per second.</p>

<p>We're also going to list the dependencies:</p>

<pre><code>tree -d -L 2 vendor/ | grep '   ' | wc -l
tree -d -L 2 vendor/ | grep '    ' | wc -l
</code></pre>

<p>We get 28 + 1, to which we need to substitute <code>symfony</code> with all the
packages it replaces (44): 72.</p>

<p>So to sum up:</p>

<ul>
<li>API: 1 step to add a new route</li>
<li>footprint: 52x slower than flat PHP</li>
<li>size: 72 dependencies</li>
</ul>

<h2 id="empty-edition">Empty Edition</h2>

<p>As stated above the Standard Edition has a "solve 80% of use cases out of the box"
philosophy, so it comes with many dependencies that might not fit our use. Micro
framework usually follow a "add what you need philosophy", which is exactly what
the Empty Edition is all about.</p>

<p>Let's see if we can get more micro with it:</p>

<pre><code>composer create-project gnugat/symfony-empty-edition
cd symfony-empty-edition
</code></pre>

<p>The first step is to create a controller:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Controller/HelloController.php

namespace AppBundle\Controller;

use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class HelloController
{
    public function world(Request $request)
    {
        return new Response('Hello World');
    }
}
</code></pre>

<p>Then we register it as a service:</p>

<pre><code># app/config/services/controller.yml
services:
    app.hello_controller:
        class: AppBundle\Controller\HelloController
</code></pre>

<p>Finally we register the route:</p>

<pre><code># app/config/routings/app.yml
hello_world:
    path: /
    defaults:
        _controller: app.hello_controller:world
    methods:
        - GET
</code></pre>

<p>Let's run the benchmark:</p>

<pre><code>composer update -o --no-dev
php -S localhost:2503 -t web &amp;
ab -c 10 -t 10 'http://localhost:2503/app.php'
killall php
</code></pre>

<p>Result: <strong>524.53</strong> Requests per second.</p>

<p>We're also going to list the dependencies:</p>

<pre><code>tree -d -L 2 vendor/ | grep '   ' | wc -l
tree -d -L 2 vendor/ | grep '    ' | wc -l
</code></pre>

<p>We get 6 + 23 = 29.</p>

<p>So to sum up:</p>

<ul>
<li>API: 3 steps to add a new route</li>
<li>footprint: 13x slower than flat PHP</li>
<li>size: 29 dependencies</li>
</ul>

<h2 id="micro-framework-bundle">Micro Framework Bundle</h2>

<p>By reducing the number of dependencies, we also drastically reduced the framework
footprint. This is not surprising as:</p>

<ul>
<li>we've reduced the number of classes to autoload</li>
<li>we've reduced the number of configuration (parameters and service definition) to set up</li>
<li>we've reduced the bootload time of the Dependency Injection Container (less services to instantiate)</li>
<li>we've reduced the number of event listeners called</li>
</ul>

<p>Can we go further? Certainly: the FrameworkBundle also follows a
"solve 80% of use cases out of the box" (includes Forms, Security, Templating, Translation, Assets, annotations, etc).</p>

<p>By using a MicroFrameworkBundle that would provide the strict minimum and follow
the micro framework philosophy of "add what you need" we can surely reduce further
the number of dependencies. Hence <code>gnugat/micro-framework-bundle</code>:</p>

<pre><code>composer require 'gnugat/micro-framework-bundle'
composer remove 'symfony/framework-bundle'
</code></pre>

<p>Then we need to swap the bundle in the registration:</p>

<pre><code class="php">&lt;?php
// app/AppKernel.php

use Symfony\Component\HttpKernel\Kernel;
use Symfony\Component\Config\Loader\LoaderInterface;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        return array(
            new Gnugat\MicroFrameworkBundle\GnugatMicroFrameworkBundle(),
            new AppBundle\AppBundle(),
        );
    }

    public function getRootDir()
    {
        return __DIR__;
    }

    public function getCacheDir()
    {
        return dirname(__DIR__).'/var/cache/'.$this-&gt;environment;
    }

    public function getLogDir()
    {
        return dirname(__DIR__).'/var/logs';
    }

    public function registerContainerConfiguration(LoaderInterface $loader)
    {
        $loader-&gt;load($this-&gt;rootDir.'/config/config_'.$this-&gt;environment.'.yml');
    }
}
</code></pre>

<p>Finally we can get rid of some configuration:</p>

<pre><code># app/config/config.yml
imports:
    - { resource: parameters.yml }
    - { resource: services/ }
</code></pre>

<p>Let's benchmark our trimmed application:</p>

<pre><code>rm -rf var/*
composer update -o --no-dev
php -S localhost:2504 -t web &amp;
ab -c 10 -t 10 'http://localhost:2504/app.php'
killall php
</code></pre>

<p>Result: <strong>872.83</strong> Requests per second.</p>

<p>We're also going to list the dependencies:</p>

<pre><code>tree -d -L 2 vendor/ | grep '   ' | wc -l
tree -d -L 2 vendor/ | grep '    ' | wc -l
</code></pre>

<p>We get 3 + 13 = 16.</p>

<p>So to sum up:</p>

<ul>
<li>API: 3 steps to add a new route</li>
<li>footprint: 8x slower than flat PHP</li>
<li>size: 13 dependencies</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>Symfony has always been able to be used as a micro framework bundle.</p>

<p>The <a href="https://github.com/symfony/symfony-standard">Standard Edition</a> and the
<a href="https://github.com/symfony/symfony/tree/master/src/Symfony/Bundle/FrameworkBundle">FrameworkBundle</a>
follow a "solve 80% of use cases out of the box" philosohpy, which is better for new comers.</p>

<p>However for experimented developers who're looking for a "add what you need" philosophy,
which is what micro-framework usually follow, using the <a href="http://github.com/gnugat/symfony-empty-edition">Empty Edition</a>
and <a href="http://github.com/gnugat/micro-framework-bundle">MicroFrameworkBundle</a> can
be a viable alternative (they are slimer in term of dependencies and faster).</p>

<blockquote>
  <p><strong>Note</strong>: At the time of writing, MicroFrameworkBundle is still under development
  (version <code>0.1.0</code>). Use it at your own risk and contribute to it :) .</p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Decouple from Frameworks]]></title>
            <link href="https://gnugat.github.io/2015/09/30/decouple-from-frameworks.html"/>
            <updated>2015-09-30T00:00:00+01:00</updated>
            <id>https://gnugat.github.io/2015/09/30/decouple-from-frameworks.html</id>
            <content type="html"><![CDATA[<p>Frameworks solve infrastructure problems, for example how to create a HTTP or CLI application.
While necessary, those concerns don't add any value to your project: the business
need will not be fulfilled by creating an empty application.</p>

<p>As always, different responsibilities mean also different reasons to change: frameworks
have a history of Backward Compatibility (BC) breaks and they do so regardless of your
project.</p>

<p>Take for example <a href="http://symfony.com/">Symfony</a>: it only started to follow <a href="http://semver.org/">Semantic Versioning</a>
from version 2.3. The upgrade to version 3 has been made easier by allowing developers
to know what was deprecated, but the removal of those features still means a lot of
work in your application.
The arrival of the <a href="http://www.php-fig.org/psr/psr-7/">new standard PSR-7</a> brings
a lot of questions on the future of Symfony: for now it <a href="http://symfony.com/blog/psr-7-support-in-symfony-is-here">allows to choose</a>
between <code>symfony/http-foundation</code> and <code>psr/http-message</code>, but if Symfony doesn't
want to fall back behind (<a href="http://framework.zend.com/blog/announcing-the-zend-framework-3-roadmap.html">Zend 3 is fully based on PSR-7</a>)
it might have to introduce another big BC break (event listeners with the Request
and Response <a href="http://evertpot.com/psr-7-issues/">are not possible the way they are now with PSR-7</a>).</p>

<p>Migrating Symfony applications (from symfony1, from symfony 2.0, etc) is so hard
that it is a business on its own.</p>

<p>Does that mean that we shouldn't use any frameworks? Should we just don't care and
embrace fully frameworks?</p>

<p>This article will explain how to avoid both extremes, by decoupling from the framework.
It can be done by restricting the framework to its infrastructure responsibilities
(HTTP, CLI), by only using its entry points (Controller, Command) and by using
the Command Bus pattern.</p>

<h2 id="fortune%3A-our-example">Fortune: our example</h2>

<p>We're going to build part of a <a href="https://en.wikipedia.org/wiki/Fortune_%28Unix%29">fortune</a>
application for our example, more precisely we're going to build an endpoint allowing us to
submit quotes.</p>

<p>To do so, we'll bootstrap a symfony application using the <a href="https://github.com/gnugat/symfony-empty-edition">Empty Edition</a>:</p>

<pre><code>composer create-project gnugat/symfony-empty-edition fortune
cd fortune
</code></pre>

<p>We'll need to install our test frameworks:</p>

<pre><code>composer require --dev phpunit/phpunit
composer require --dev phpspec/phpspec
</code></pre>

<p>Then add them to our test script:</p>

<pre><code>#!/usr/bin/env sh

# bin/test.sh

echo ''
echo '// Building test environment'

rm -rf app/cache/test app/logs/*test.log
composer --quiet --no-interaction install --optimize-autoloader  &gt; /dev/null
php app/console --env=test --quiet cache:clear

echo ''
echo ' [OK] Test environment built'
echo ''

vendor/bin/phpspec --format=dot &amp;&amp; vendor/bin/phpunit
</code></pre>

<p>Finally we'll configure PHPUnit:</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;!-- phpunit.xml.dist --&gt;
&lt;!-- http://phpunit.de/manual/current/en/appendixes.configuration.html --&gt;
&lt;phpunit backupGlobals="false" colors="true" syntaxCheck="false" bootstrap="app/bootstrap.php"&gt;
    &lt;testsuites&gt;
        &lt;testsuite name="System Tests"&gt;
            &lt;directory&gt;tests&lt;/directory&gt;
        &lt;/testsuite&gt;
    &lt;/testsuites&gt;
&lt;/phpunit&gt;
</code></pre>

<h2 id="request-listener">Request listener</h2>

<p>Our endpoint will receive JSON encoded content. PHP does not populate <code>$_POST</code> with
this data, causing an empty <code>$request-&gt;request</code>. We can create an event listener
to fix this issue:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/EventListener/JsonRequestListener.php

namespace AppBundle\EventListener;

use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Event\GetResponseEvent;

class JsonRequestListener
{
    public function onKernelRequest(GetResponseEvent $event)
    {
        $request = $event-&gt;getRequest();
        $hasBeenSubmited = in_array($request-&gt;getMethod(), array('PATCH', 'POST', 'PUT'), true);
        $isJson = (1 === preg_match('#application/json#', $request-&gt;headers-&gt;get('Content-Type')));
        if (!$hasBeenSubmited || !$isJson) {
            return;
        }
        $data = json_decode($request-&gt;getContent(), true);
        if (JSON_ERROR_NONE !== json_last_error()) {
            $event-&gt;setResponse(new Response('{"error":"Invalid or malformed JSON"}', 400, array('Content-Type' =&gt; 'application/json')));
        }
        $request-&gt;request-&gt;add($data ?: array());
    }
}
</code></pre>

<p>This logic is infrastructure related, so it makes sense to keep it in <code>AppBundle</code>.</p>

<p>To enable it, configure it in the Dependency Injection Container:</p>

<pre><code># app/config/services/event_listener.yml

services:
    app.json_request_listener:
        class: AppBundle\EventListener\JsonRequestListener
        tags:
            - { name: kernel.event_listener, event: kernel.request, method: onKernelRequest }
</code></pre>

<p>We also need to make sure files in <code>app/config/services</code> are imported:</p>

<pre><code class="php">&lt;?php
// app/config/importer.php

use Symfony\Component\Finder\Finder;

$finder = new Finder();
$files = $finder-&gt;files()-&gt;name('*.yml')-&gt;in(__DIR__.'/services');
foreach ($files as $file) {
    $loader-&gt;import($file-&gt;getRealpath());
}
</code></pre>

<h2 id="controller">Controller</h2>

<p>Our first step will be to describe how the endpoint should work, with a test:</p>

<pre><code class="php">&lt;?php
// tests/AppBundle/Controller/QuoteControllerTest.php

namespace tests\AppBundle\Controller;

use AppKernel;
use PHPUnit_Framework_TestCase;
use Symfony\Component\HttpFoundation\Request;

class QuoteControllerTest extends PHPUnit_Framework_TestCase
{
    private $app;

    protected function setUp()
    {
        $this-&gt;app = new AppKernel('test', false);
        $this-&gt;app-&gt;boot();
    }

    /**
     * @test
     */
    public function it_submits_a_new_quote()
    {
        $headers = array('CONTENT_TYPE' =&gt; 'application/json');
        $request = Request::create('/v1/quotes', 'POST', array(), array(), array(), $headers, json_encode(array(
            'quote' =&gt; 'Nobody expects the spanish inquisition',
        )));

        $response = $this-&gt;app-&gt;handle($request);

        self::assertSame(201, $response-&gt;getStatusCode(), $response-&gt;getContent());
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Testing only the status code is called "Smoke Testing" and is a very
  efficient way to check if the application is broken.
  Testing the content would be tedious and would make our test fragile as it might change often.</p>
</blockquote>

<p>Let's run it:</p>

<pre><code>./bin/test.sh
</code></pre>

<p>The tests fail because the controller doesn't exist. Let's fix that:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Controller/QuoteController.php

namespace AppBundle\Controller;

use Acme\Fortune\Quote\SubmitNewQuote;
use Acme\Fortune\Quote\SubmitNewQuoteHandler;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class QuoteController
{
    private $submitNewQuoteHandler;

    public function __construct(SubmitNewQuoteHandler $submitNewQuoteHandler)
    {
        $this-&gt;submitNewQuoteHandler = $submitNewQuoteHandler;
    }

    public function submitNewAction(Request $request)
    {
        $sumbitNewQuote = new SubmitNewQuote(
            $request-&gt;request-&gt;get('quote')
        );
        $newQuote = $this-&gt;submitNewQuoteHandler-&gt;handle($sumbitNewQuote);

        return new Response(json_encode($newQuote), 201, array('Content-Type' =&gt; 'application/json'));
    }
}
</code></pre>

<p>Now we need to configure the controller as a service:</p>

<pre><code># app/config/services/controller.yml

services:
    app.quote_controller:
        class: AppBundle\Controller\QuoteController
        arguments:
            - "@app.submit_new_quote_handler"
</code></pre>

<p>Then we need to configure the route:</p>

<pre><code># app/config/routings/quote.yml

submit_new_quote:
    path: /v1/quotes
    defaults:
        _controller: app.quote_controller:submitNew
    methods:
        - POST
</code></pre>

<p>This file needs to be imported:</p>

<pre><code># app/config/routing.yml

quote:
    resource: routings/quote.yml
</code></pre>

<p>Finally we can run the test again:</p>

<pre><code>./bin/test.sh
</code></pre>

<p>It now fails for a different reason: <code>SubmitNewQuote</code> and its handler class don't exist.</p>

<h2 id="command-from-commandbus">Command (from CommandBus)</h2>

<p><code>SubmitNewQuote</code> is a Data Transfer Object (DTO): its responsibility is to wrap
input parameters in a well named class (in this case a class that describes the action intended).
It's also the best place to do some basic validation on the input parameters.</p>

<blockquote>
  <p><strong>Note</strong>: In the Command Bus pattern, <code>SubmitNewQuote</code> would be a Command (different from the CLI Command).</p>
</blockquote>

<p>We'll write a test for this, but first we'll bootstrap the test class:</p>

<pre><code>vendor/bin/phpspec describe 'Acme\Fortune\Quote\SubmitNewQuote'
</code></pre>

<p>Now we can decribe the different validation rules:</p>

<pre><code class="php">&lt;?php
// spec/Acme/Fortune/Quote/SubmitNewQuoteSpec.php

namespace spec\Acme\Fortune\Quote;

use PhpSpec\ObjectBehavior;

class SubmitNewQuoteSpec extends ObjectBehavior
{
    const QUOTE = 'Nobody expects the spanish inquisition';

    function it_fails_if_required_quote_parameter_is_missing()
    {
        $this-&gt;beConstructedWith(null);

        $this-&gt;shouldThrow('Acme\Fortune\Exception\ValidationFailedException')-&gt;duringInstantiation();
    }

    function it_fails_if_quote_parameter_is_empty()
    {
        $this-&gt;beConstructedWith('');

        $this-&gt;shouldThrow('Acme\Fortune\Exception\ValidationFailedException')-&gt;duringInstantiation();
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Since this class has nothing to do with Symfony, we don't put it in <code>AppBundle</code>.
  By keeping it in its own namespace, we protect it from framework directory tree changes,
  for example before <code>AppBundle</code> the norm was <code>Acme\FortuneBundle</code>. We also allow ourselves
  to move it to another framework (e.g. Laravel, Zend, etc).</p>
</blockquote>

<p>Let's run the tests:</p>

<pre><code>./bin/test.sh
</code></pre>

<p>It fails because the exception doesn't exist yet:</p>

<pre><code class="php">&lt;?php
// src/Acme/Fortune/Exception/ValidationFailedException.php

namespace Acme\Fortune\Exception;

class ValidationFailedException extends FortuneException
{
}
</code></pre>

<p>We're making it a sub type of <code>FortuneException</code>: that way we can catch all exceptions
related to our code (all other exceptions can be considered as Internal Server Errors).</p>

<pre><code class="php">&lt;?php
// src/Acme/Fortune/Exception/FortuneException.php

namespace Acme\Fortune\Exception;

use DomainException;

class FortuneException extends DomainException
{
}
</code></pre>

<p>Now we need to create the Command:</p>

<pre><code class="php">&lt;?php
// src/Acme/Fortune/Quote/SubmitNewQuote.php

namespace Acme\Fortune\Quote;

use Acme\Fortune\Exception\ValidationFailedException;

class SubmitNewQuote
{
    public function __construct($quote)
    {
        if (null === $quote) {
            throw new ValidationFailedException('Missing required "quote" parameter');
        }
        if ('' === $quote) {
            throw new ValidationFailedException('Invalid "quote" parameter: must not be empty');
        }
        $this-&gt;quote = (string) $quote;
    }
}
</code></pre>

<p>Running the tests again:</p>

<pre><code>./bin/test.sh
</code></pre>

<p>Everything seems fine.</p>

<h2 id="exception-listener">Exception listener</h2>

<p>Instead of catching exceptions in our controllers we can create an event listener:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/EventListener/FortuneExceptionListener.php

namespace AppBundle\EventListener;

use Symfony\Component\HttpKernel\Event\GetResponseForExceptionEvent;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Event\GetResponseEvent;

class FortuneExceptionListener
{
    public function onKernelException(GetResponseForExceptionEvent $event)
    {
        $exception = $event-&gt;getException();
        if (!$exception instanceof FortuneException) {
            return;
        }
        $content = json_encode(array('error' =&gt; $exception-&gt;getMessage()));
        $statusCode = Response::HTTP_UNPROCESSABLE_ENTITY;
        $event-&gt;setResponse(new Response($content, $statusCode, array('Content-Type' =&gt; 'application/json')));
    }
}
</code></pre>

<p>This lowers the risk of forgetting to catch an exception and it also keeps our controller slim.</p>

<p>Let's enable it in the DIC:</p>

<pre><code># app/config/services/event_listener.yml

services:
    app.fortune_exception_listener:
        class: AppBundle\EventListener\FortuneExceptionListener
        tags:
            - { name: kernel.event_listener, event: kernel.exception, method: onKernelException }

    app.json_request_listener:
        class: AppBundle\EventListener\JsonRequestListener
        tags:
            - { name: kernel.event_listener, event: kernel.request, method: onKernelRequest }
</code></pre>

<h2 id="command-handler">Command Handler</h2>

<p><code>SubmitNewQuoteHandler</code>'s responsibility is to validate <code>SubmitNewQuote</code> data against
business rules (e.g. no quote duplicates, author must exist, etc) and to call the
appropriate services to process it.
Reading its code feels like reading the details of a use case:</p>

<blockquote>
  <p>To handle the submission of a new quote,
  we need to generate a unique identifier
  and then we need to save the new quote.</p>
</blockquote>

<p>Let's bootstrap its test:</p>

<pre><code>vendor/bin/phpspec describe 'Acme\Fortune\Quote\SubmitNewQuoteHandler'
</code></pre>

<p>Then edit the test:</p>

<pre><code class="php">&lt;?php
// spec/Acme/Fortune/Quote/SubmitNewQuoteHandlerSpec.php

namespace spec\Acme\Fortune\Quote;

use Acme\Fortune\Quote\SubmitNewQuote;
use Acme\Fortune\Quote\Service\SaveNewQuote;
use Acme\Fortune\Quote\Service\UniqueIdentifierGenerator;
use PhpSpec\ObjectBehavior;

class SubmitNewQuoteHandlerSpec extends ObjectBehavior
{
    const ID = '921410e8-eb98-4f99-ba98-055d46980511';
    const QUOTE = 'Nobody expects the spanish inquisition!';

    function let(SaveNewQuote $saveNewQuote, UniqueIdentifierGenerator $uniqueIdentifierGenerator)
    {
        $this-&gt;beConstructedWith($saveNewQuote, $uniqueIdentifierGenerator);
    }

    function it_saves_new_quote(SaveNewQuote $saveNewQuote, UniqueIdentifierGenerator $uniqueIdentifierGenerator)
    {
        $submitNewQuote = new SubmitNewQuote(self::QUOTE);
        $quote = array(
            'id' =&gt; self::ID,
            'quote' =&gt; self::QUOTE,
        );

        $uniqueIdentifierGenerator-&gt;generate()-&gt;willReturn(self::ID);
        $saveNewQuote-&gt;save($quote)-&gt;shouldBeCalled();

        $this-&gt;handle($submitNewQuote)-&gt;shouldBe($quote);
    }
}
</code></pre>

<p>Let's run the tests:</p>

<pre><code>./bin/test.sh
</code></pre>

<p>After generating interfaces for <code>SaveNewQuote</code> and <code>UniqueIdentifierGenerator</code>
and after bootstrapping the code for <code>SubmitNewQuoteHandler</code>, the test will fail
because we need to complete it:</p>

<pre><code class="php">&lt;?php
// src/Acme/Fortune/Quote/SubmitNewQuoteHandler.php

namespace Acme\Fortune\Quote;

use Acme\Fortune\Quote\Service\SaveNewQuote;
use Acme\Fortune\Quote\Service\UniqueIdentifierGenerator;

class SubmitNewQuoteHandler
{
    private $saveNewQuote;
    private $uniqueIdentifierGenerator;

    public function __construct(SaveNewQuote $saveNewQuote, UniqueIdentifierGenerator $uniqueIdentifierGenerator)
    {
        $this-&gt;saveNewQuote = $saveNewQuote;
        $this-&gt;uniqueIdentifierGenerator = $uniqueIdentifierGenerator;
    }

    public function handle(SubmitNewQuote $sumbitNewQuote)
    {
        $quote = array(
            'id' =&gt; $this-&gt;uniqueIdentifierGenerator-&gt;generate(),
            'quote' =&gt; $sumbitNewQuote-&gt;quote,
        );
        $this-&gt;saveNewQuote-&gt;save($quote);

        return $quote;
    }
}
</code></pre>

<p>Now we can configure the service:</p>

<pre><code class="php"># app/config/services/quote.yml

services:
    app.submit_new_quote_handler:
        class: Acme\Fortune\Quote\SubmitNewQuoteHandler
        arguments:
            - "@app.save_new_quote"
            - "@app.unique_identifier_generator"
</code></pre>

<p>Finally can run the tests one last time:</p>

<pre><code>./bin/test.sh
</code></pre>

<p>Allmost green!</p>

<p>They fail because <code>app.save_new_quote</code> and <code>app.unique_identifier_generator</code> don't
exist yet. They will be the topic of another article ;) .</p>

<h2 id="conclusion">Conclusion</h2>

<p>By restricting frameworks to their entry points (Controllers, Commands, etc) and
using the Command Bus to define our project entry points (domain boundaries) we
are able to decouple from the framework, allowing us to restrict the impact of BC breaks.</p>

<p>Of course, all projects are different and this solution might not be possible everywhere.
RAD development is a robust solution for web agencies, especially if they are chosen
to bootstrap a project as fast as possible and then need to pass the project over
to their customer after a short period.</p>

<p>On the other hand some companies are creating projects they will have to maintain
for decades and those are also in need of delivering a first version early.
Decoupling from the framework isn't something that slows down development, and there
are ways to still release early (e.g. define Minimum Valuable Product and deliver
small features iterations by iterations).</p>

<blockquote>
  <p><strong>Note</strong>: There are a couple of bundles that provides Symfony with a Command Bus, among them:</p>
  
  <ul>
  <li><a href="/2015/09/09/tactician.html">Tactician</a></li>
  <li><a href="/2015/08/04/simple-bus.html">SimpleBus</a></li>
  </ul>
</blockquote>

<p>If you're interrested on the subject, here's some resources:</p>

<ul>
<li>The framework as an implementation detail
(<a href="http://www.slideshare.net/marcello.duarte/the-framework-as-an-implementation-detail">slides</a>
and <a href="https://www.youtube.com/watch?v=0L_9NutiJlc">video</a>),
by <a href="http://marcelloduarte.net/">Marcello Duarte</a>
and <a href="http://everzet.com/">Konstantin Kudryashov</a></li>
<li><a href="https://blog.8thlight.com/uncle-bob/2014/05/11/FrameworkBound.html">Framework bound</a>,
by <a href="https://sites.google.com/site/unclebobconsultingllc/">Robert Cecil Martin</a></li>
<li><a href="http://kristopherwilson.com/2013/11/27/decoupling-the-framework/">Decoupling the Framework</a>,
by <a href="https://twitter.com/mrkrstphr">Kristopher Wilson</a></li>
</ul>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
    </feed>