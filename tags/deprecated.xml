<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[Loïc Faugeron]]></title>
    <link href="https://gnugat.github.io/feed/atom.xml" rel="self"/>
    <link href="https://gnugat.github.io/"/>
    <updated>2016-03-02T07:54:15+00:00</updated>
    <id>http://gnugat.github.com</id>
            <author>
            <name><![CDATA[Loïc Faugeron]]></name>            <email><![CDATA[faugeron.loic@gmail.com]]></email>        </author>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[Lightweight console library]]></title>
            <link href="https://gnugat.github.io/2014/12/03/lightweight-console-lib.html"/>
            <updated>2014-12-03T00:00:00+00:00</updated>
            <id>https://gnugat.github.io/2014/12/03/lightweight-console-lib.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This article has been deprecated.</p>
  
  <p><strong>TL;DR</strong>: <a href="https://github.com/gnugat/konzolo">Konzolo</a> can be used to create
  minimalistic CLI applications, or to implement the command design pattern.</p>
</blockquote>

<p>After implementing a same feature in many projects, I usually have the reflex to
create a library out of it. <a href="https://github.com/gnugat/konzolo">Konzolo</a> is one
of them :) .</p>

<p>In this article we'll see its features:</p>

<ul>
<li><a href="#create-a-command">Create a command</a></li>
<li><a href="#binding-up-an-application">Binding up an application</a></li>
<li><a href="#input-constraint">Input constraint</a></li>
<li><a href="#input-validator">Input validator</a></li>
<li><a href="#exceptions">Exceptions</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="create-a-command">Create a command</h2>

<p>Let's create a "hello world" command:</p>

<pre><code class="php">&lt;?php

namespace Acme\Demo\Command;

use Gnugat\Konzolo\Command;
use Gnugat\Konzolo\Input;

class HelloWorldCommand implements Command
{
    public function execute(Input $input)
    {
        $name = $input-&gt;getArgument('name');
        echo "Hello $name\n";

        return Command::EXIT_SUCCESS;
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: If the name argument is missing, an exception will be thrown.
  Keep reading to know more about those exceptions.</p>
</blockquote>

<p>We only have to implement the <code>execute</code> method, which receives a convenient
<code>Input</code> class and returns 0 on success (actually this is optional).</p>

<h2 id="binding-up-an-application">Binding up an application</h2>

<p>Now that we have a command, let's put it in an application:</p>

<pre><code class="php">&lt;?php
// File: console.php

use Acme\Demo\Command\HelloWorldCommand;
use Gnugat\Konzolo\Application;
use Gnugat\Konzolo\Input;

require __DIR__.'/vendor/autoload.php';

$input = new Input($argv[1]); // command name (acme:hello-world)
if (isset($argv[2])) {
    $input-&gt;setArgument('name', $argv[2]);
}

$application = new Application();
$application-&gt;addCommand('acme:hello-world', new HelloWorldCommand());

$application-&gt;run($input);
</code></pre>

<p>You can then run it:</p>

<pre><code>php console.php acme:hello-world Igor
</code></pre>

<h2 id="input-constraint">Input constraint</h2>

<p>If you need to validate the input, you can create a constraint:</p>

<pre><code class="php">&lt;?php

namespace Acme\Demo\Validation;

use Gnugat\Konzolo\Exception\InvalidInputException;
use Gnugat\Konzolo\Input;
use Gnugat\Konzolo\Validation\InputConstraint;

class NoWorldNameConstraint implements InputConstraint
{
    public function throwIfInvalid(Input $input)
    {
        $name = $input-&gt;getArgument('name');
        if ('World' === $name) {
            throw new InvalidInputException($input, 'The "name" parameter must not be set to "World"');
        }
    }
}
</code></pre>

<p>This constraint can be used directly in the command, as a dependency:</p>

<pre><code class="php">&lt;?php

namespace Acme\Demo\Command;

use Acme\Demo\Validation\NoWorldNameConstraint;
use Gnugat\Konzolo\Command;
use Gnugat\Konzolo\Input;

class HelloWorldCommand implements Command
{
    private $noWorldNameConstraint;

    public function __construct(NoWorldNameConstraint $noWorldNameConstraint)
    {
        $this-&gt;noWorldNameConstraint = $noWorldNameConstraint;
    }

    public function execute(Input $input)
    {
        $this-&gt;noWorldNameConstraint-&gt;throwIfInvalid($input);
        $name = $input-&gt;getArgument('name');
        echo "Hello $name\n";

        return Command::EXIT_SUCCESS;
    }
}
</code></pre>

<p>And then inject it:</p>

<pre><code class="php">&lt;?php
// File: console.php

use Acme\Demo\Command\HelloWorldCommand;
use Acme\Demo\Validation\NoWorldNameConstraint;
use Gnugat\Konzolo\Application;
use Gnugat\Konzolo\Input;

require __DIR__.'/vendor/autoload.php';

$input = new Input($argv[1]); // command name (acme:hello-world)
if (isset($argv[2])) {
    $input-&gt;setArgument('name', $argv[2]);
}

$application = new Application();
$application-&gt;addCommand('acme:hello-world', new HelloWorldCommand(new NoWorldNameConstraint()));

$application-&gt;run($input);
</code></pre>

<h2 id="input-validator">Input validator</h2>

<p>More conveniently, the command can depend on a validator:</p>

<pre><code class="php">&lt;?php

namespace Acme\Demo\Command;

use Gnugat\Konzolo\Command;
use Gnugat\Konzolo\Input;
use Gnugat\Konzolo\Validation\InputValidator;

class HelloWorldCommand implements Command
{
    private $validator;

    public function __construct(InputValidator $validator)
    {
        $this-&gt;validator = $validator;
    }

    public function execute(Input $input)
    {
        $this-&gt;validator-&gt;throwIfInvalid($input);
        $name = $input-&gt;getArgument('name');
        echo "Hello $name\n";

        return Command::EXIT_SUCCESS;
    }
}
</code></pre>

<p>You can add many constraint in a validator, and set priorities:</p>

<pre><code class="php">&lt;?php
// File: console.php

use Acme\Demo\Command\HelloWorldCommand;
use Acme\Demo\Validation\NoWorldNameConstraint;
use Gnugat\Konzolo\Application;
use Gnugat\Konzolo\Input;
use Gnugat\Konzolo\Validation\InputValidator;

require __DIR__.'/vendor/autoload.php';

$input = new Input($argv[1]); // command name (acme:hello-world)
if (isset($argv[2])) {
    $input-&gt;setArgument('name', $argv[2]);
}

$helloWorldValidator = new InputValidator();
$helloWorldValidator-&gt;addConstraint(new NoWorldNameConstraint(), 42);

$application = new Application();
$application-&gt;addCommand('acme:hello-world', new HelloWorldCommand($helloWorldValidator));

$application-&gt;run($input);
</code></pre>

<blockquote>
  <p><strong>Note</strong>: The highest the priority, the soonest the constraint will be executed.
  For example, a constraint with priority 1337 will be executed before another
  one with priority 23 (even if this second one has been added first in the validator).</p>
</blockquote>

<h2 id="exceptions">Exceptions</h2>

<p>Konzolo's exceptions all implement the <code>Gnugat\Konzolo\Exception\Exception</code> interface.
This means you can catch every single one of them using this type. They also
extend at the standard <code>\Exception</code> class, so if you don't care about Konzolo
specific exceptions, you can catch them all!</p>

<p>This is usefull for example in <a href="https://symfony.com">Symfony2</a>: you can create
a Konzolo exception listener.</p>

<p>You can find more about the different kind of exceptions and their specific
methods in <a href="http://github.com/gnugat/konzolo/tree/master/doc/exception.md">its dedicated documentation</a>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>We have seen how to create commands and validate their inputs.</p>

<p>Our examples showed how to create a CLI application, but Konzolo is mainly aimed at being used <strong>in</strong>
applications (not only CLI ones).
For example, <a href="https://github.com/gnugat/redaktilo">Redaktilo</a> uses internally
a system of Command/CommandInvoker, using an array as input and sanitizer as a
validation mechanism. All this logic can now be externalized, thanks to Konzolo!</p>

<p>I'd like to keep Konzolo as small as possible, but here's a list of possible
features it could see in the future:</p>

<h3 id="command-finder">Command finder</h3>

<p>Currently we can find commands by their exact names. But wouldn't it be nice if
we could just provide part of a name? Or an alias?</p>

<h3 id="input-factories">Input Factories</h3>

<p>Creating input manually isn't always what we need. A factory that creates one
from an array could improve the situation.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony2 Console component, by example]]></title>
            <link href="https://gnugat.github.io/2014/04/09/sf2-console-component-by-example.html"/>
            <updated>2014-04-09T00:00:00+01:00</updated>
            <id>https://gnugat.github.io/2014/04/09/sf2-console-component-by-example.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This article has been re-written - see
  <a href="/2016/03/02/ultimate-symfony-console.html">The Ultimate Developer Guide to Symfony - Console</a></p>
</blockquote>

<p><a href="#conclusion">TL;DR: jump to the conclusion</a>.</p>

<p><a href="http://symfony.com/">Symfony2</a> is a set of libraries which help you in your
everyday tasks. You can even stack them together and create a framework with it:</p>

<ul>
<li><a href="https://github.com/symfony/symfony-standard">Symfony standard edition</a></li>
<li><a href="https://github.com/gnugat/symfony-empty">Symfony empty edition</a></li>
<li><a href="http://silex.sensiolabs.org/">Silex</a></li>
</ul>

<p>Many frameworks already use a lot of components from Symfony2:</p>

<ul>
<li><a href="http://laravel.com/">Laravel</a></li>
<li><a href="https://drupal.org/">Drupal</a></li>
<li><a href="http://ez.no/">eZ Publish</a></li>
<li><a href="http://phpunit.de/">PHPUnit</a></li>
<li><a href="https://www.phpbb.com/">phpBB</a></li>
<li><a href="https://getcomposer.org/">Composer</a></li>
</ul>

<p>In this article, we'll see the
<a href="http://symfony.com/doc/master/components/console/introduction.html">Console Component</a>,
which allows you to build Command Line Interface (CLI) applications. Symfony 2.5
will be released in may 2014, with great new features for the Console, so I'll
speak about this version here.</p>

<ul>
<li><a href="#introduction">Introduction</a>

<ul>
<li><a href="#application">Application</a></li>
<li><a href="#command">Command</a></li>
<li><a href="#input">Input</a></li>
<li><a href="#output">Output</a></li>
<li><a href="#consolelogger">ConsoleLogger</a></li>
</ul></li>
<li><a href="#standalone-example">Standalone example</a>

<ul>
<li><a href="#creating-the-application">Creating the application</a></li>
<li><a href="#creating-the-command">Creating the command</a></li>
<li><a href="#registering-the-command">Registering the command</a></li>
<li><a href="#using-the-filesystem-component">Using the Filesystem component</a></li>
<li><a href="#thin-controller-many-small-services">Thin controller, many small services</a></li>
<li><a href="#registering-the-services">Registering the services</a></li>
</ul></li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>This component allows you to focus on one thing: creating commands. It takes
care of all the coloring output, input gathering and command containing stuff.</p>

<p>The big picture is: you have an <code>Application</code> which contains a set of
<code>Command</code>s. When ran, the <code>Application</code> will create an <code>Input</code> object which
contains <code>Option</code>s and <code>Argument</code>s provided by the user, and will feed it to
the right <code>Command</code>.</p>

<p>The code being the best documentation, we'll now see the strict minimum classes
you should know, with the methods you'll likely use.</p>

<h3 id="application">Application</h3>

<p>All you need to know about the <code>Application</code> is this:</p>

<pre><code>&lt;?php

namespace Symfony\Component\Console;

use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;

class Application
{
    public function __construct($name = 'UNKNOWN', $version = 'UNKNOWN');
    public function add(Command $command);
    public function setDefaultCommand($commandName); // New in 2.5!
    public function run(InputInterface $input = null, OutputInterface $output = null);
}
</code></pre>

<p>Minimum usage:</p>

<pre><code>#!/usr/bin/env php
&lt;?php

use Symfony\Component\Console\Application;

$application = new Application();
$application-&gt;run();
</code></pre>

<p>By running this script, you should be able to see a colorful output which lists
the available commands (<code>list</code> is the default command, and a <code>help</code> is also
available).</p>

<h3 id="command">Command</h3>

<p>The <code>Command</code> class is the controller of your CLI application:</p>

<pre><code>&lt;?php

namespace Symfony\Component\Console\Command;

use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;

class Command
{
    protected function configure();
    protected function execute(InputInterface $input, OutputInterface $output);
    protected function interact(InputInterface $input, OutputInterface $output);

    // To be called in configure
    public function setName($name);
    public function addArgument($name, $mode = null, $description = '', $default = null);
    public function addOption($name, $shortcut = null, $mode = null, $description = '', $default = null);
    public function setDescription($description);
    public function setHelp($help);
    public function setAliases($aliases);
}
</code></pre>

<p>Basically you create a class which extends <code>Command</code>. You need to implement 2
methods:</p>

<ul>
<li><code>configure</code>: the configuration of the command's name, arguments, options, etc</li>
<li><code>execute</code>: where you process the input, call your services and write to the
output</li>
</ul>

<p>The <code>interact</code> method is called before the <code>execute</code> one: it allows you to ask
questions to the user to set more input arguments and options.</p>

<p>Here's my stand on arguments and options modes:</p>

<ul>
<li>an argument should always be required (<code>InputArgument::REQUIRED</code>)</li>
<li>a flag is an option without value (<code>InputOption::VALUE_NONE</code>)</li>
<li>an option should always have a required value (<code>InputOption::VALUE_REQUIRED</code>),
don't forget to provide a default one</li>
</ul>

<h3 id="input">Input</h3>

<p>The container of the arguments and options given by the user:</p>

<pre><code>&lt;?php

namespace Symfony\Component\Console\Input;

interface InputInterface
{
    public function getArgument($name);
    public function getOption($name);
}
</code></pre>

<p>The <code>Application</code> validates a part of the input: it checks if the command
actually accepts the given arguments and options (is the value required? Does
the <code>hello:world</code> command have a <code>--yell</code> option? etc), but you still need to
validate the input against your business rules (the <code>--number</code> option should
be an integer, the <code>name</code> argument should be escaped to avoid SQL injection,
etc).</p>

<h3 id="output">Output</h3>

<p>A convenient object which allows you to write on the console output:</p>

<pre><code>&lt;?php

namespace Symfony\Component\Console\Output;

abstract class Output implements OutputInterface
{
    public function writeln($messages, $type = self::OUTPUT_NORMAL);
}
</code></pre>

<p>The <code>writeln</code> method allows you to write a new line (with a newline character at
the end). If the given <code>message</code> is an array, it will print each elements on a
new line.</p>

<p>The tags allow you to color some parts:</p>

<ul>
<li>green text for informative messages (usage example: <code>&lt;info&gt;foo&lt;/info&gt;</code>)</li>
<li>yellow text for comments (usage example: <code>&lt;comment&gt;foo&lt;/comment&gt;</code>)</li>
<li>black text on a cyan background for questions (usage example: <code>&lt;question&gt;foo&lt;/question&gt;</code>)</li>
<li>white text on a red background for errors (usage example: <code>&lt;error&gt;foo&lt;/error&gt;</code>)</li>
</ul>

<h3 id="consolelogger">ConsoleLogger</h3>

<p>Another brand new class from the version 2.5:</p>

<pre><code>&lt;?php

namespace Symfony\Component\Console\Logger;

use Psr\Log\AbstractLogger;
use Symfony\Component\Console\Output\OutputInterface;

class ConsoleLogger extends AbstractLogger
{
    public function __construct(
        OutputInterface $output,
        array $verbosityLevelMap = array(),
        array $formatLevelMap = array()
    );

    public function log($level, $message, array $context = array());
}
</code></pre>

<p>As you can see, it uses the <code>OutputInterface</code> provided by the <code>Application</code>.
You should inject this logger into your services, this will allow them to write
messages on the standard output of the console while keeping them decoupled from
this component (so you can use these services in a web environment).</p>

<p>Oh, and the good news is: it colors the output and decides whether or not to
print it depending on the verbosity and level of log! An error message would
always be printed in red, an informative message would be printed in green if
you pass the <code>-vv</code> option.</p>

<h2 id="standalone-example">Standalone example</h2>

<p>Just like any other component, the Console can be used as a standalone library.</p>

<p>In this example, we'll create a tool which will create a <code>LICENSE</code> file, just
like <a href="https://github.com/gnugat/fossil">fossil</a> (the <a href="/2014/01/15/bootstrap-markdown-files-of-your-FOSS-project.html">bootstraper of markdown files for your FOSS projetcs</a>).</p>

<h3 id="creating-the-application">Creating the application</h3>

<p>To begin, let's install the component using <a href="https://getcomposer.org/">Composer</a>:</p>

<pre><code>$ curl -sS https://getcomposer.org/installer | php # Downloading composer
$ ./composer.phar require "symfony/console:~2.5@dev"
</code></pre>

<p>Then create an empty application:</p>

<pre><code>#!/usr/bin/env php
&lt;?php
// File: fossil

require __DIR__.'/vendor/autoload.php';

use Symfony\Component\Console\Application;

$application = new Application('Fossil', '2.0.0');
$application-&gt;run();
</code></pre>

<h3 id="creating-the-command">Creating the command</h3>

<p>Our command has two arguments:</p>

<ul>
<li>the name for the copyright</li>
<li>the year for the copyright</li>
</ul>

<p>It can also take the path of the project as an option (we'll provide the
current directory as default value).</p>

<p>Let's create it:</p>

<pre><code>&lt;?php
// File: src/Gnugat/Fossil/LicenseCommand.php

namespace Gnugat\Fossil;

use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;

class LicenseCommand extends Command
{
    protected function configure()
    {
        $this-&gt;setName('license');
        $this-&gt;setDescription('Bootstraps the license file of your project');

        $this-&gt;addArgument('author', InputArgument::REQUIRED);
        $this-&gt;addArgument('year', InputArgument::REQUIRED);

        $this-&gt;addOption('path', 'p', InputOption::VALUE_REQUIRED, '', getcwd());
    }

    protected function execute(InputInterface $input, OutputInterface $output)
    {
    }
}
</code></pre>

<h3 id="registering-the-command">Registering the command</h3>

<p>Our command doesn't do anything yet, but we can already register it in our
application:</p>

<pre><code>#!/usr/bin/env php
&lt;?php
// File: fossil

require __DIR__.'/vendor/autoload.php';

use Symfony\Component\Console\Application;
use Gnugat\Fossil\LicenseCommand;

$command = new LicenseCommand();

$application = new Application('Fossil', '2.0.0');
$application-&gt;add($command);
$application-&gt;run();
</code></pre>

<p>In order for it to run, you'll need to register the namespace in the autoloader
by editing the <code>composer.json</code> file at the root of the project:</p>

<pre><code>{
    "require": {
        "symfony/console": "~2.5@dev"
    },
    "autoload": {
        "psr-4": { "": "src" }
    }
}
</code></pre>

<p>Then you need to run <code>./composer.phar update</code> to update the configuration.</p>

<h3 id="using-the-filesystem-component">Using the Filesystem component</h3>

<p>In <code>fossil</code>, <a href="https://github.com/gnugat/fossil/tree/master/skeletons">templates</a>
are retrieved using the
<a href="http://symfony.com/doc/current/components/finder.html">Finder component</a>, their
values are replaced using <a href="http://twig.sensiolabs.org/">Twig</a> and written using the
<a href="http://symfony.com/doc/current/components/filesystem.html">Filesystem component</a>.</p>

<p>In order to keep this article short, we'll:</p>

<ul>
<li>use a fictive license which requires only the copyright line</li>
<li>simply store the <code>LICENSE</code> template in the command</li>
<li>inject the values using <code>implode</code></li>
</ul>

<p>This means that you have to install the new component:</p>

<pre><code>$ ./composer.phar require "symfony/filesystem:~2.4"
</code></pre>

<p>And then you need to fill the <code>execute</code> method:</p>

<pre><code>&lt;?php
// File: src/Gnugat/Fossil/LicenseCommand.php

namespace Gnugat\Fossil;

use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Filesystem\Filesystem;

class LicenseCommand extends Command
{
    // configure method...

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $path = $input-&gt;getOption('path').'/LICENSE';
        $license = implode(' ', array(
            'Copyright (c)',
            $input-&gt;getArgument('author'),
            $input-&gt;getArgument('year'),
        ));

        $filesystem = new Filesystem();
        $filesystem-&gt;dumpFile($path, $license.PHP_EOL);

        $output-&gt;writeln(sprintf('Created the file %s', $path));
    }
}
</code></pre>

<p>Now running <code>./fossil license "Loïc Chardonnet" "2013-2014" -p="/tmp"</code> will
output the message "Created the file /tmp/LICENSE", which should be what really
happened.</p>

<h3 id="thin-controller%2C-many-small-services">Thin controller, many small services</h3>

<p>I'm not a big fan of putting logic in my commands, so generally I use services
to do the actual job:</p>

<pre><code>&lt;?php
// File src/Gnugat/Fossil/DocumentationWriter.php

namespace Gnugat\Fossil;

use Symfony\Component\Filesystem\Filesystem;
use Psr\Log\LoggerInterface;

class DocumentationWriter
{
    private $filesystem;
    private $logger;

    public function __construct(Filesystem $filesystem, LoggerInterface $logger)
    {
        $this-&gt;filesystem = $filesystem;
        $this-&gt;logger = $logger;
    }

    public function write($path, $content)
    {
        $this-&gt;filesystem-&gt;dumpFile($path, $content);
        $this-&gt;logger-&gt;notice(sprintf('Created file %s', $path));
    }
}
</code></pre>

<p>As you can see, the <code>DocumentationWriter</code> isn't very big. It might seem
overkill, but now it's easy to write tests which will check if the <code>LICENSE</code>
file has been created. Also, in <code>fossil</code> the class does a bit more work: it
checks if the file already exists, and takes a "force overwrite" option into
account.</p>

<p>You'll also notice that we inject a logger to notice the user of what happens.
We need to install the PSR-3 logger interface:</p>

<pre><code>$ composer require "psr/log:~1.0"
</code></pre>

<p>Our command will now be much thinner, just like any controller should be (MVC
can also be applied in CLI):</p>

<pre><code>&lt;?php
// File: src/Gnugat/Fossil/LicenseCommand.php

namespace Gnugat\Fossil;

use Gnugat\Fossil\DocumentationWriter;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Logger\ConsoleLogger;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Filesystem\Filesystem;

class LicenseCommand extends Command
{
    // configure method...

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $path = $input-&gt;getOption('path').'/LICENSE';
        $license = implode(' ', array(
            'Copyright (c)',
            $input-&gt;getArgument('author'),
            $input-&gt;getArgument('year'),
        ));

        $filesystem = new Filesystem();
        $logger = new ConsoleLogger($output);
        $documentationWriter = new DocumentationWriter($filesystem, $logger);

        $documentationWriter-&gt;write($path, $license.PHP_EOL);
    }
}
</code></pre>

<p>To be fair, our command is longer. But it <strong>is</strong> thinner as it now has less
responsibilities:</p>

<ul>
<li>it retrieves the input</li>
<li>creates the dependencies</li>
<li>calls the services</li>
</ul>

<p>If you run again <code>./fossil license "Loïc Chardonnet" "2013-2014" -p="/tmp"</code>,
you won't see anything: <code>ConsoleLogger</code> hides informative messages by default.
You need to pass the verbose option to see the message:</p>

<pre><code>$ ./fossil license -v "Loïc Chardonnet" "2013-2014" -p="/tmp"
</code></pre>

<h3 id="registering-the-services">Registering the services</h3>

<p>The dependency creation isn't a responsibility a controller should have. We'll
delegate this to the
<a href="http://symfony.com/doc/current/components/dependency_injection/introduction.html">Dependency Injection component</a>:</p>

<pre><code>$ ./composer.phar require "symfony/dependency-injection:~2.4"
</code></pre>

<p>We'll also install the
<a href="http://symfony.com/doc/current/components/config/introduction.html">Config component</a>:</p>

<pre><code>$ ./composer.phar require "symfony/config:~2.4"
</code></pre>

<p>If you don't know yet this component, go read
<a href="/2014/01/29/sf2-di-component-by-example.html">this helpful article</a>.</p>

<p>We'll create a XML file to configure the registration of our services:</p>

<pre><code>&lt;?xml version="1.0" ?&gt;

&lt;!-- File: config/services.xml --&gt;

&lt;container xmlns="http://symfony.com/schema/dic/services"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd"&gt;
    &lt;services&gt;
        &lt;service id="symfony.application"
            class="Symfony\Component\Console\Application"&gt;
            &lt;argument key="name"&gt;Fossil&lt;/argument&gt;
            &lt;argument key="version"&gt;2.0.0&lt;/argument&gt;
            &lt;call method="add"&gt;
                 &lt;argument type="service" id="fossil.license_command" /&gt;
            &lt;/call&gt;
        &lt;/service&gt;

        &lt;service id="fossil.license_command" class="Gnugat\Fossil\LicenseCommand"&gt;
            &lt;argument type="service" id="fossil.documentation_writer" /&gt;
        &lt;/service&gt;

        &lt;service id="fossil.documentation_writer" class="Gnugat\Fossil\DocumentationWriter"&gt;
            &lt;argument type="service" id="symfony.filesystem" /&gt;
            &lt;argument type="service" id="symfony.console_logger" /&gt;
        &lt;/service&gt;

        &lt;service id="symfony.filesystem" class="Symfony\Component\Filesystem\Filesystem"&gt;
        &lt;/service&gt;

        &lt;service id="symfony.console_logger" class="Symfony\Component\Console\Logger\ConsoleLogger"&gt;
            &lt;argument type="service" id="symfony.console_output" /&gt;
        &lt;/service&gt;

        &lt;service id="symfony.console_output"
            class="Symfony\Component\Console\Output\ConsoleOutput"&gt;
        &lt;/service&gt;
    &lt;/services&gt;
&lt;/container&gt;
</code></pre>

<p>As you can see, I've delegated <strong>every</strong> construction to the DIC (Dependency
Injection Container), even the construction of the application. Now the command
looks like this:</p>

<pre><code>    &lt;?php
// File: src/Gnugat/Fossil/LicenseCommand.php

namespace Gnugat\Fossil;

use Gnugat\Fossil\DocumentationWriter;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;

class LicenseCommand extends Command
{
    private $documentationWriter;

    public function __construct(DocumentationWriter $documentationWriter)
    {
        $this-&gt;documentationWriter = $documentationWriter;

        parent::__construct();
    }

    protected function configure()
    {
        $this-&gt;setName('license');
        $this-&gt;setDescription('Bootstraps the license file of your project');

        $this-&gt;addArgument('author', InputArgument::REQUIRED);
        $this-&gt;addArgument('year', InputArgument::REQUIRED);

        $this-&gt;addOption('path', 'p', InputOption::VALUE_REQUIRED, '', getcwd());
    }

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $path = $input-&gt;getOption('path').'/LICENSE';
        $license = implode(' ', array(
            'Copyright (c)',
            $input-&gt;getArgument('author'),
            $input-&gt;getArgument('year'),
        ));

        $this-&gt;documentationWriter-&gt;write($path, $license.PHP_EOL);
    }
}
</code></pre>

<p>And the console now contains the DIC initialization:</p>

<pre><code>#!/usr/bin/env php
&lt;?php
// File: fossil

use Symfony\Component\Config\FileLocator;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;

require __DIR__.'/vendor/autoload.php';

$container = new ContainerBuilder();
$loader = new XmlFileLoader($container, new FileLocator(__DIR__.'/config'));
$loader-&gt;load('services.xml');

$output = $container-&gt;get('symfony.console_output');

$application = $container-&gt;get('symfony.application');
$application-&gt;run(null, $output);
</code></pre>

<p>And voilà! You now know how to create CLI applications :) .</p>

<h2 id="conclusion">Conclusion</h2>

<p>The Console component allows you to create CLI applications. The commands are a
thin layer which gathers the input and call services. Those services can then
output messages to the user using a special kind of logger.</p>

<p>Although this article was a bit long, I might have missed something here, so
if you have any feedbacks/questions, be sure to contact me on
<a href="https://twitter.com/epiloic">Twitter</a>.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony2 Dependency Injection component, by example]]></title>
            <link href="https://gnugat.github.io/2014/01/29/sf2-di-component-by-example.html"/>
            <updated>2014-01-29T00:00:00+00:00</updated>
            <id>https://gnugat.github.io/2014/01/29/sf2-di-component-by-example.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This article has been re-written - see
  <a href="/2016/02/24/ultimate-symfony-dependency-injection.html">The Ultimate Developer Guide to Symfony - Dependency Injection</a></p>
</blockquote>

<p>In <a href="/2014/01/22/ioc-di-and-service-locator.html">the previous article</a>
we've seen among other things the definition of Dependency Injection (DI) and of
the Dependency Injection Container (DIC).</p>

<p>In this article we'll see the Symfony2's DI component which provides a powerful
DIC. Here's the summary:</p>

<ul>
<li>putting the construction of your services into configuration</li>
<li>how to use it to wire your application</li>
</ul>

<p>You don't use Symfony2? Don't worry, this article is all about using this
component as a standalone library (you can use it in your
CakePHP/Zend/Home-made-framework application).</p>

<h2 id="construction-configuration">Construction configuration</h2>

<p>DI is all about passing arguments to the constructor of an object. Because
constructing all those object might become a burden, the DIC is here to
take this responsibility and centralize it.</p>

<p>Let's replace <a href="http://pimple.sensiolabs.org/">Pimple</a> by
<a href="http://symfony.com/doc/current/components/dependency_injection/index.html">Symfony2 DI component</a>
in the code sample from the previous article:</p>

<pre><code>&lt;?php

use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\DependencyInjection\ContainerBuilder;

$container = new ContainerBuilder();

// This is a parameter definition
$container-&gt;setParameter('verbosity_level_map', array(
    OutputInterface::VERBOSITY_NORMAL =&gt; Logger::NOTICE,
    OutputInterface::VERBOSITY_VERBOSE =&gt; Logger::INFO,
    OutputInterface::VERBOSITY_VERY_VERBOSE =&gt; Logger::DEBUG,
    OutputInterface::VERBOSITY_DEBUG =&gt; Logger::DEBUG,
);

// register takes the service name, and then its fully qualified classname as a string
$container-&gt;register(
    'console_output',
    'Symfony\Component\Console\Output\ConsoleOutput'
);
$container-&gt;register(
    'output_formatter',
    'Gnugat\Fossil\ApplicationLayer\OutputFormatter'
);

// You can inject:
// * dependencies which have been declared previously
// * arguments
// * parameters which have been declared previously
// * setter dependencies
$container
    -&gt;register('console_handler', 'Symfony\Bridge\Monolog\Handler\ConsoleHandler')
    -&gt;addArgument(new Reference('console_output'))
    -&gt;addArgument(true)
    -&gt;addArgument('%verbosity_level_map%')
    -&gt;addMethodCall('setFormatter', array(new Reference('output_formatter')));
;

$container
    -&gt;register('logger', 'Monolog\Logger')
    -&gt;addArgument('default.logger')
    -&gt;addMethodCall('pushHandler', array(new Reference('console_handler')));
;

$container-&gt;register('filesystem', 'Symfony\Component\Filesystem\Filesystem');

$container
    -&gt;register('documentation_writer', 'Gnugat\Fossil\MarkdownFile\DocumentationWriter')
    -&gt;addArgument(new Reference('filesystem'))
    -&gt;addArgument(new Reference('logger'))
;
</code></pre>

<p>If you think about it, the construction of objects is a configuration thing:
you need to define for each object their dependencies. Symfony2's DI component
allows you to put all those definition inside a configuration file:</p>

<pre><code>&lt;?xml version="1.0" ?&gt;
&lt;!-- File: dic_config.xml --&gt;

&lt;container xmlns="http://symfony.com/schema/dic/services"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd"&gt;
    &lt;parameters&gt;
        &lt;parameter key="verbosity_Level_map" type="collection"&gt;
            &lt;parameter key="Symfony\Component\Console\Output\OutputInterface::VERBOSITY_NORMAL"&gt;Monolog\Logger::NOTICE&lt;/parameter&gt;
            &lt;parameter key="Symfony\Component\Console\Output\OutputInterface::VERBOSITY_VERBOSE"&gt;Monolog\Logger::INFO&lt;/parameter&gt;
            &lt;parameter key="Symfony\Component\Console\Output\OutputInterface::VERBOSITY_VERY_VERBOSE"&gt;Monolog\Logger::DEBUG&lt;/parameter&gt;
            &lt;parameter key="Symfony\Component\Console\Output\OutputInterface::VERBOSITY_DEBUG"&gt;Monolog\Logger::DEBUG&lt;/parameter&gt;
        &lt;/parameter&gt;
    &lt;/parameters&gt;

    &lt;services&gt;
        &lt;service id="console_output"
            class="Symfony\Component\Console\Output\ConsoleOutput"&gt;
        &lt;/service&gt;

        &lt;service id="output_formatter"
            class="Gnugat\Fossil\ApplicationLayer\OutputFormatter"&gt;
        &lt;/service&gt;

        &lt;service id="console_handler"
            class="Symfony\Bridge\Monolog\Handler\ConsoleHandler"&gt;
            &lt;argument type="service" id="console.output" /&gt;
            &lt;argument key="bubble"&gt;true&lt;/argument&gt;
            &lt;argument&gt;%verbosity_Level_map%&lt;/argument&gt;
            &lt;call method="setFormatter"&gt;
                 &lt;argument type="service" id="output_formatter" /&gt;
            &lt;/call&gt;
        &lt;/service&gt;

        &lt;service id="logger" class="Monolog\Logger"&gt;
            &lt;argument&gt;default.logger&lt;/argument&gt;
            &lt;call method="pushHandler"&gt;
                 &lt;argument type="service" id="console_handler" /&gt;
            &lt;/call&gt;
        &lt;/service&gt;

        &lt;service id="filesystem"
            class="Symfony\Component\Filesystem\Filesystem"&gt;
        &lt;/service&gt;

        &lt;service id="documentation_writer"
            class="Gnugat\Fossil\MarkdownFile\DocumentationWriter"&gt;
            &lt;argument type="service" id="filesystem" /&gt;
            &lt;argument type="service" id="logger" /&gt;
        &lt;/service&gt;
    &lt;/services&gt;
&lt;/container&gt;
</code></pre>

<p>And here's the code sample allowing you to feed the DIC with this configuration:</p>

<pre><code>&lt;?php

// File: front_controller.php

use Symfony\Component\Config\FileLocator;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;

$container = new ContainerBuilder();
$configurationDirectory = new FileLocator(__DIR__);

$loader = new XmlFileLoader($container, $configurationDirectory);
$loader-&gt;load('dic_config.xml');

$documentationWriter = $container-&gt;get('documentation_writer');
$documentationWriter-&gt;write('/tmp/example.txt', 'Hello world');
</code></pre>

<p>The construction of our objects has been completely removed from the code and
has been put into a configuration file. Actually, we've replaced object
constructions by container initialization, which is way more concise.</p>

<h3 id="configuration-format">Configuration format</h3>

<p>The Symfony2's DI component <a href="http://symfony.com/doc/current/components/dependency_injection/configurators.html">allows many configuration formats</a>:</p>

<ul>
<li>plain PHP (like in our first code sample)</li>
<li>XML (like in our second code sample)</li>
<li><a href="http://www.yaml.org/">YAML</a></li>
</ul>

<p>I wouldn't advise you to use YAML format, as it needs to introduce
<a href="http://symfony.com/doc/current/components/dependency_injection/parameters.html#yaml">special formating in order to support advanced options</a>
like:</p>

<ul>
<li>prefixing services ID's with <code>@</code></li>
<li>prefixing services ID's which aren't mandatory with <code>@?</code></li>
<li>prefixing <code>@</code> with <code>@</code> in order to escape them</li>
<li><a href="http://symfony.com/doc/current/book/service_container.html#using-the-expression-language">prefixing expressions with <code>@=</code></a></li>
</ul>

<p>Not to mention the fact that it doesn't support every options (for instance
<a href="http://symfony.com/doc/current/components/dependency_injection/parameters.html#constants-as-parameters">you cannot declare constants as parameters</a>)</p>

<p>On the other hand, the only thing XML doesn't support is concatenation:</p>

<pre><code>&lt;?php

use Symfony\Component\DependencyInjection\ContainerBuilder;

$container = new ContainerBuilder();
// Needs to be done in plain PHP
$container-&gt;setParameter('skeletons_path', __DIR__.'/skeletons');
</code></pre>

<p>XML can be easily validated and it also can be read by many software like IDE's
which can use it in order to provide you with blissful autocompletion.</p>

<p>If you're concerned about performances (reading XML might be slower than
requiring directly plain PHP), Symfony2's DI component allows you to convert it
into plain PHP and dump it into a cache file which you can then include in
your application: <a href="http://symfony.com/doc/current/components/dependency_injection/compilation.html#dumping-the-configuration-for-performance">take a look at the documentation</a>.</p>

<h2 id="wiring-your-application">Wiring your application</h2>

<p>There's a fantastic conclusion we can deduce from the above section: we can
reduce the lines of codes of our projects simply by extracting object
construction and putting it into configuration files.</p>

<p>Object construction is part of the "wiring layer" of your application: it
doesn't solve your "business problem", nor does it solve your
"application problem". It simply is the boilerplate code necessary to write
those.</p>

<p>Let's explore the impact of wiring your application using Symfony2's DI
component. You might not have noticed it, but the code samples used in the
previous article as well as in this one all come from <a href="https://github.com/gnugat/fossil">fossil</a>,
a command which allows you to bootstrap markdown files of your projects
(<a href="/2014/01/15/bootstrap-markdown-files-of-your-FOSS-project.html">cf this article</a>).
It uses Symfony2's Console component which requires some boilerplate code in
order to create the application:</p>

<pre><code>&lt;?php

// This is the front controller of the application
// File: fossil

use Gnugat\Fossil\DocCommand;
use Symfony\Component\Config\FileLocator;
use Symfony\Component\Console\Application;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;

$container = new ContainerBuilder();
$configurationDirectory = new FileLocator(__DIR__);

$loader = new XmlFileLoader($container, $configurationDirectory);
$loader-&gt;load('dic_config.xml');

$documentationWriter = $container-&gt;get('documentation_writer');

$docCommand = new DocCommand($documentationWriter);

$application = new Application('Fossil', '2.0.0');
$application-&gt;add($docCommand);

$output = $container-&gt;get('console_output');

$application-&gt;run(null, $output);
</code></pre>

<p>Can you imagine what this front controller can become if we were to add more
commands? You'd rather not? Me neither, that's why I advise you to put all this
boilerplate code into a configuration file:</p>

<pre><code>&lt;?xml version="1.0" ?&gt;

&lt;!-- File: dic_config.xml --&gt;

&lt;container xmlns="http://symfony.com/schema/dic/services"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd"&gt;
    &lt;services&gt;
        &lt;service id="console_output"
            class="Symfony\Component\Console\Output\ConsoleOutput"&gt;
        &lt;/service&gt;

        &lt;service id="output_formatter"
            class="Gnugat\Fossil\ApplicationLayer\OutputFormatter"
        &lt;/service&gt;

        &lt;service id="console_handler"
            class="Symfony\Bridge\Monolog\Handler\ConsoleHandler"
            &lt;argument type="service" id="console.output" /&gt;
            &lt;argument key="bubble"&gt;true&lt;/argument&gt;
            &lt;argument&gt;%verbosity_Level_map%&lt;/argument&gt;
            &lt;call method="setFormatter"&gt;
                 &lt;argument type="service" id="output_formatter" /&gt;
            &lt;/call&gt;
        &lt;/service&gt;

        &lt;service id="logger" class="Monolog\Logger"&gt;
            &lt;argument&gt;default.logger&lt;/argument&gt;
            &lt;call method="pushHandler"&gt;
                 &lt;argument type="service" id="console_handler" /&gt;
            &lt;/call&gt;
        &lt;/service&gt;

        &lt;service id="filesystem"
            class="Symfony\Component\Filesystem\Filesystem"
        &lt;/service&gt;

        &lt;service id="documentation_writer"
            class="Gnugat\Fossil\MarkdownFile\DocumentationWriter"
            &lt;argument type="service" id="filesystem" /&gt;
            &lt;argument type="service" id="logger" /&gt;
        &lt;/service&gt;

        &lt;service id="doc_command" class="Gnugat\Fossil\DocCommand"&gt;
            &lt;argument type="service" id="documentation_writer" /&gt;
        &lt;/service&gt;

        &lt;service id="application"
            class="Symfony\Component\Console\Application"&gt;
            &lt;argument key="name"&gt;Fossil&lt;/argument&gt;
            &lt;argument key="version"&gt;2.0.0&lt;/argument&gt;
            &lt;call method="add"&gt;
                 &lt;argument type="service" id="doc_command" /&gt;
            &lt;/call&gt;
        &lt;/service&gt;
    &lt;/services&gt;
&lt;/container&gt;
</code></pre>

<p>Which allows us to reduce our front controller:</p>

<pre><code>&lt;?php

// This is the front controller of the application
// File: fossil

use Symfony\Component\Config\FileLocator;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;

$container = new ContainerBuilder();
$configurationDirectory = new FileLocator(__DIR__);

$loader = new XmlFileLoader($container, $configurationDirectory);
$loader-&gt;load('dic_config.xml');

$application = $container-&gt;get('application');

$output = $container-&gt;get('console_output');

$application-&gt;run(null, $output);
</code></pre>

<p>Now our concern is the size of the <code>dic_config.xml</code> file which will keep growing
each time we create new services. Don't panic! You can split it into many files
using the <code>imports</code> tag:</p>

<pre><code>&lt;?xml version="1.0" ?&gt;

&lt;!-- File: config/dic.xml --&gt;

&lt;container xmlns="http://symfony.com/schema/dic/services"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd"&gt;
    &lt;imports&gt;
        &lt;import resource="01-application.xml" /&gt;
        &lt;import resource="02-documentation_writer.xml" /&gt;
    &lt;/imports&gt;
&lt;/container&gt;
</code></pre>

<p>We created a <code>config</code> directory to put all those XML files, which means we
should change our front controller to:</p>

<pre><code>&lt;?php

// This is the front controller of the application
// File: fossil

use Symfony\Component\Config\FileLocator;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;

$container = new ContainerBuilder();
$configurationDirectory = new FileLocator(__DIR__.'/config');

$loader = new XmlFileLoader($container, $configurationDirectory);
$loader-&gt;load('dic.xml');

$application = $container-&gt;get('application');

$output = $container-&gt;get('console_output');

$application-&gt;run(null, $output);
</code></pre>

<p>The creation of the <code>config/01-application.xml</code> and
<code>config/02-documentation_writer.xml</code> files is left as an exercise for the
reader.</p>

<h2 id="conclusion">Conclusion</h2>

<p>The Symfony2's Dependency Injection component can be used outside of a Symfony2
application. It provides a powerful DIC which can be initialized using
configuration files. This means that boilerplate code (also called "wiring
layer") can be removed from your code and put in configuration files, hooray!</p>

<p>I hope you enjoyed this article, be sure to
<a href="https://twitter.com/epiloic">tweet me what you think about it</a> ;) .</p>

<h3 id="nota-bene">Nota bene</h3>

<p>We've used the component as a standalone library, but everything we've done
here is possible inside a Symfony2 fullstack application.</p>

<p>There's also some tips I'd like to share with you:</p>

<h3 id="doctrine-repositories-as-services">Doctrine repositories as services</h3>

<p>The construction of Doctrine repositories is fully handled by the EntityManager,
which means:</p>

<ol>
<li>you cannot inject them as dependencies in your own services</li>
<li>you cannot inject dependencies into them</li>
</ol>

<p><a href="https://gist.github.com/gnugat/8314217">Or can you?</a></p>

<h3 id="service-locator">Service locator</h3>

<p><a href="/2014/01/22/ioc-di-and-service-locator.html">The previous article</a>
spoke about service locator, which is all about using DIC as a dependency. If
you still don't see what it means, take a look at <a href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/DependencyInjection/ContainerAware.php">Symfony2 ContainerAware classes</a>.</p>

<p>For example, a <a href="https://github.com/symfony/symfony/blob/master/src/Symfony/Bundle/FrameworkBundle/Controller/Controller.php">Symfony2 controller</a>
uses the DIC as a Service Locator. In this specific case it might be justified,
as the controller shouldn't contain any logic: its purpose is to pass the
request's parameters to some services, and to feed their return values as the
response's parameters.</p>

<p>Keep in mind that in your own code, there's a 99.99% chance that using Service
Locator is a unjustified decision ;) .</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Bootstrap the markdown files of your FOSS project]]></title>
            <link href="https://gnugat.github.io/2014/01/15/bootstrap-markdown-files-of-your-FOSS-project.html"/>
            <updated>2014-01-15T00:00:00+00:00</updated>
            <id>https://gnugat.github.io/2014/01/15/bootstrap-markdown-files-of-your-FOSS-project.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: Fossil is currently unmaintained.</p>
</blockquote>

<p>The one thing that will make developers use your Free or Open Source Software
(FOSS) project is its documentation. Without it, how can they know what it does,
or how to install it?</p>

<p>Last summer <a href="http://williamdurand.fr/2013/07/04/on-open-sourcing-libraries/">William Durand wrote an article about it</a>,
describing the minimum files your FOSS project should have, and what they should
contain.</p>

<p>After reading his article, maybe you did the same thing as me: you took your
courage with both hands and wrote thoroughly a decent documentation for the
project you were working on at the time.</p>

<p>Because it was tedious, you decided to copy those markdown files into your new
projects and adapt them.</p>

<p>But this too was tedious...</p>

<p>To solve this problem once for all I created <strong><a href="https://github.com/gnugat/fossil">fossil</a></strong>:
it will bootstrap the markdown files of your FOSS projects, and it will even
create an installer for you!</p>

<p>It generates the following files out of skeletons:</p>

<ul>
<li><code>CHANGELOG.md</code></li>
<li><code>CONTRIBUTING.md</code></li>
<li><code>LICENSE</code></li>
<li><code>README.md</code></li>
<li><code>VERSIONING.md</code></li>
<li><code>bin/installer.sh</code></li>
<li><code>doc</code> (or <code>Resources/doc</code> if the project is a bundle) directory:

<ul>
<li><code>01-introduction.md</code></li>
<li><code>02-installation.md</code></li>
<li><code>03-usage.md</code></li>
<li><code>04-tests.md</code></li>
</ul></li>
</ul>

<p>The best thing about it: you can run it on your new FOSS projects as well as
with your existing ones! By default it does not replace existing files (if you
want to, simply use the <code>-f</code> option).</p>

<p><strong>Fossil</strong> supports different kind of projects: applications, libraries and
Symfony2 bundles. Here's a quick usage guide.</p>

<h2 id="applications">Applications</h2>

<p>The <code>doc</code> command allows you to generate the markdown files of your
applications, which can be a web application or a CLI tool just like <strong>fossil</strong>.</p>

<p>As you can see in the following example, it only requires 2 arguments:</p>

<pre><code>fossil doc 'acme/application' 'The ACME company'
</code></pre>

<h3 id="the-github-repository-argument">The <a href="https://github.com/">Github</a> repository argument</h3>

<p>Applications are installed by cloning the github repository, which makes it as
easy to update as to run <code>git pull</code>.</p>

<p>This argument is used in the installer script as well as in the installation
instructions.</p>

<p>You don't need to write the whole github URL, simply give the username and the
project name in the following format: <code>username/project-name</code></p>

<h3 id="the-license-author-argument">The license author argument</h3>

<p>While the copyright's date can be computed, you need to provide the author's
name to generate the <code>LICENSE</code> file.</p>

<p>For now it only generates MIT licenses, but pull requests are welcomed :) .</p>

<h3 id="the-path-option">The path option</h3>

<p>By default the files are created in the current directory, but you can target a
specific path:</p>

<pre><code>fossil doc 'acme/application' 'The ACME company' -p '/tmp/application'
</code></pre>

<h3 id="the-force-overwrite-option">The force overwrite option</h3>

<p>As mentioned earlier, <strong>fossil</strong> won't replace existing files by default: for
instance if your project already has a <code>README.md</code> and a <code>LICENSE</code> file it will
only generate the other ones.</p>

<p>But if you want to throw them away, you can use this option:</p>

<pre><code>fossil doc 'acme/project' 'The ACME company' -f
</code></pre>

<h2 id="libraries">Libraries</h2>

<p>The <code>doc:library</code> command has the exact same arguments and options as the <code>doc</code>
one:</p>

<pre><code>fossil doc:library 'acme/library' 'The ACME company'
</code></pre>

<p>You can use the shortcut <code>d:l</code>:</p>

<pre><code>fossil d:l 'acme/library' 'The ACME company'
</code></pre>

<p>The difference between an application and a library lies in its installation:
the library is installed using <a href="http://getcomposer.org/">composer</a>.</p>

<h3 id="the-composer-package-option">The composer package option</h3>

<p>By default <strong>fossil</strong> assumes the composer package's name is the same as the
Github repository name (in the example it would be <code>acme/library</code>).
If it's not your case, use the following option:</p>

<pre><code>fossil d:l 'acme/library' 'The ACME company' -c 'acme/composer-package'
</code></pre>

<h2 id="symfony2-bundles">Symfony2 Bundles</h2>

<p>The <code>doc:bundle</code> command has almost the same arguments and options as the
<code>doc:library</code> one. It has an additional argument:</p>

<pre><code>fossil doc:bundle 'acme/demo-bundle' 'The ACME company' 'Acme\DemoBundle\AcmeDemoBundle'
</code></pre>

<p>You can use the shortcut <code>d:b</code>:</p>

<pre><code>fossil d:b 'acme/demo-bundle' 'The ACME company' 'Acme\DemoBundle\AcmeDemoBundle'
</code></pre>

<p>The difference between a library and a bundle is the documentation directory,
which is in <code>Resources/doc</code> instead of <code>doc</code>.</p>

<h3 id="the-fully-qualified-classname-argument">The fully qualified classname argument</h3>

<p>Another difference is the installation: the bundle needs to be added in the
application's kernel.</p>

<p>This will be detailed in the documentation, but it will also be taken care of
by the installer.</p>

<p>That's right, you read it right: when developers will run the installer, not
only will it download the bundle using composer, but it will also add its fully
qualified classname in the <code>app/AppKernel.php</code> file! Hooray!</p>

<p>The application's kernel will look like this afterwards:</p>

<pre><code>&lt;?php
// File: app/AppKernel.php

use Symfony\Component\HttpKernel\Kernel;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        $bundles = array(
            // Other bundles...
            new Acme\DemoBundle\AcmeDemoBundle(),
        );

        if (in_array($this-&gt;getEnvironment(), array('dev', 'test'))) {
            // Other bundles...
        }

        return $bundles;
    }
}
</code></pre>

<p><em>Note</em>: because of the backslashes you should escape this argument using
quotes, just like in the example.</p>

<h3 id="the-development-tool-option">The development tool option</h3>

<p>By using this option, the bundle will be registered in the application only if
it runs in development or test environment:</p>

<pre><code>fossil d:b 'acme/demo-bundle' 'The ACME company' 'Acme\DemoBundle\AcmeDemoBundle' -d
</code></pre>

<p>The application's kernel will look like this afterwards:</p>

<pre><code>&lt;?php
// File: app/AppKernel.php

use Symfony\Component\HttpKernel\Kernel;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        $bundles = array(
            // Other bundles...
        );

        if (in_array($this-&gt;getEnvironment(), array('dev', 'test'))) {
            // Other bundles...
            $bundles[] = new Acme\DemoBundle\AcmeDemoBundle();
        }

        return $bundles;
    }
}
</code></pre>

<h2 id="you-still-need-to-write-the-documentation">You still need to write the documentation</h2>

<p>After running <strong>fossil</strong> you still need to provide some information (for
instance the elevator pitch in <code>README.md</code>) by editing those files:</p>

<ul>
<li><code>README.md</code></li>
<li><code>doc/01-introduction.md</code></li>
<li><code>doc/03-usage.md</code></li>
<li><code>doc/04-tests.md</code></li>
</ul>

<p>But is that enough? While I think <strong>fossil</strong> automates as much things as
possible, there's still some part of your project that needs specific
documentation.</p>

<p>For example you could add recipes which describe common tasks, or a glossary
defining technical or business terms used in your project.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Bootstrap the markdown files of your new and your old FOSS projects using
<strong><a href="https://github.com/gnugat/fossil">fossil</a></strong>, and then complete the
documentation so everyone can see how awesome your work is!</p>

<p>Happy hacking!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Technology scouting]]></title>
            <link href="https://gnugat.github.io/2014/01/08/technology-scouting.html"/>
            <updated>2014-01-08T00:00:00+00:00</updated>
            <id>https://gnugat.github.io/2014/01/08/technology-scouting.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This article has been re-written - see <a href="/2014/11/21/read-it-later.html">Read it Later</a></p>
</blockquote>

<p>As a curious person I'm constantly trying to learn new practices and to discover
tools which might help me, by collecting information via technology scouting and
then reading it.</p>

<p>In this article, I will present how to do so effectively.</p>

<h2 id="collecting-information">Collecting information</h2>

<p>Whenever you find an interesting link, send it to <a href="http://getpocket.com/">Pocket</a>
so you can read it later.</p>

<h3 id="blogs">Blogs</h3>

<p>To find interesting links subscribe to blog RSS feeds using
<a href="https://ifttt.com/">If This Then That</a>: it will send new entries directly to
pocket.</p>

<p>Here are some blogs I personnally follow (caution, they're not really sorted):</p>

<ul>
<li><a href="http://williamdurand.fr/">William Durand's blog</a></li>
<li><a href="http://www.mountaingoatsoftware.com/blog">Mountain Goat Software</a></li>
<li><a href="http://blog.karolsojko.com/">Karol Sójko's blog</a></li>
<li><a href="http://blog.8thlight.com/">8th light</a></li>
<li><a href="http://richardmiller.co.uk/">Richard Miller's blog</a></li>
<li><a href="http://verraes.net/#blog">Mathias Verraes's blog</a></li>
<li><a href="http://www.whitewashing.de/">Benjamin Eberlei's blog</a></li>
<li><a href="http://nedroid.com/">Nedroid</a></li>
<li><a href="https://igor.io/">Igor Wiedler's blog</a></li>
</ul>

<h3 id="twitter">Twitter</h3>

<p>You can also use <a href="https://twitter.com/">Twitter</a>:</p>

<ol>
<li>create a private list which will serve as a pool</li>
<li>add any author which might post interresting messages</li>
<li>after a week or so, add the author to a public list</li>
</ol>

<p>The lists only show messages (not retweets) and conversations between people
you follow. They also allow you to create categories.</p>

<p>If you want, you can have a look at
<a href="https://twitter.com/epiloic/lists/">my own public lists</a>.</p>

<h3 id="github">Github</h3>

<p>Last but not least, <a href="https://github.com/">Github</a> can also be a great source of
discoveries: by following someone which stars or watch a lot of projects you
will have them listed on your homepage.</p>

<p>Here's my advice: <a href="https://github.com/pborreli">Pascal Borreli</a> contributes to
many repositories, you should start to follow him.</p>

<h2 id="reading-it">Reading it</h2>

<p>Collecting resources is a thing, getting it read is another one. Just like
<a href="http://verraes.net/2012/12/how-to-read-more-books/">Mathias Verraes advised it</a>,
you should get an e-reader: you can send the pages you gathered on Pocket and
then read them everywhere.</p>

<p>Pocket allows you to remove the articles you found not so interresting after
all, it also allows you to archive the good ones and to favorite the great ones.</p>

<p>Speaking of reading and e-readers, books are another good way of discovering new
things. Do not underestimate them. Here's a list of books I'd recommend:</p>

<ul>
<li><a href="http://git-scm.com/book">Pro Git</a></li>
<li>Clean Code, by Robert C. Martin</li>
<li>Agile Software Development, Principles, Patterns, and Practices, by Robert C. Martin</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>The point is: current tools won't last and there's a lot of practices you're
not aware of. If you want to improve yourself and keep up with other developers,
you have to try your best to discover new practices (which might be rather old
actually) and new trending tools.</p>

<p>I hope you found this article enjoyable and helpful.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Carew, the static site generator]]></title>
            <link href="https://gnugat.github.io/2014/01/01/carew-static-site-generator.html"/>
            <updated>2014-01-01T00:00:00+00:00</updated>
            <id>https://gnugat.github.io/2014/01/01/carew-static-site-generator.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This article has been re-written - see <a href="/2016/01/15/sculpin.html">Scuplin</a></p>
</blockquote>

<p>Frameworks are a real help when building web applications which serve business
logic. But what about static websites?</p>

<p>Those only contain pages which could be directly written in HTML. The only
problem with this approach is that HTML isn't writter friendly compared to
Markdown.</p>

<p>Also, we could say that static websites like blogs do have some logic behind the
scenes:</p>

<ul>
<li>posts can have a state (is it published yet?)</li>
<li>posts can be tagged, in order to make them easier to find</li>
</ul>

<p>But still, a framework might be too much for this task.</p>

<p>Static site generators are a way to solve this problem:</p>

<ol>
<li>simply write your pages in markdown</li>
<li>launch a command to generate HTML from it</li>
</ol>

<p><a href="http://carew.github.io/">Carew</a> is one of them (among
  <a href="http://jekyllrb.com/">Jekyll</a>,
  <a href="http://hyde.github.io/">Hyde</a>,
  <a href="https://github.com/obensonne/poole">Poole</a>
  and <a href="https://github.com/spjwebster/lanyon">Lanyon</a>):
it is written in PHP, allows you to use the template engine
<a href="http://twig.sensiolabs.org/">Twig</a> in your markdown and it provides a theme
using <a href="http://getbootstrap.com/2.3.2/">Bootstrap</a>.</p>

<p>This blog post will focus on Carew, as
<a href="https://github.com/gnugat/gnugat.github.io">this very blog is written with it</a>.</p>

<h2 id="carew-and-github">Carew and Github</h2>

<p>A common way to quickly publish static sites is to use
<a href="http://pages.github.com/">Github Pages</a> which works as follow:</p>

<ol>
<li>create a repository, the name should follow this format: <code>&lt;username&gt;.github.io</code></li>
<li>add, commit and push the content of the <code>web</code> directory directly at the
root of your repo</li>
<li>the site is now available at this address: <code>http://&lt;username&gt;.github.io</code></li>
</ol>

<p><a href="http://carew.github.io/cookbook/hosting.html">Learn more about hosting a website built with Carew on the official website</a>.</p>

<h2 id="creation">Creation</h2>

<p>Creating your site using Carew is very simple, just follow these steps:</p>

<pre><code>$ php composer.phar create-project carew/boilerplate &lt;project&gt; -s dev
$ cd &lt;project&gt;
$ bin/carew build
</code></pre>

<p>Examples pages (which sources are located in <code>pages</code> and <code>posts</code>) are converted
from markdown to HTML in the <code>web</code> directory.</p>

<h2 id="customization">Customization</h2>

<p>Before writing any page or post, edit the configuration wich is located inside
the <code>config.yml</code> file.</p>

<p>Then edit the <code>pages/index.md</code> and <code>pages/about.md</code> pages with your own content.</p>

<p>Finally, remove the content of the <code>posts</code> folder and create your first blog
post using this command:</p>

<pre><code>$ bin/carew generate:post [--date='YYYY-MM-DD'] title
</code></pre>

<p><a href="http://carew.github.io/cookbook/configuration.html">See the configuration documentation on the official website</a>.</p>

<h2 id="front-matters">Front matters</h2>

<p>Each markdown file starts with a header:</p>

<pre><code>---
layout: post # no need for this line when writing a regular page
title: Will be used by `&lt;title&gt;&lt;/title&gt;` and `&lt;h1&gt;&lt;/h1&gt;`
tags:
    - first tag
    - carew
---
</code></pre>

<p>Carew generates a page listing all existing tags. You can create a link to this
page with the following snippet:</p>

<pre><code>{{ link('tags', 'The page with all the tags') }}.
</code></pre>

<p><a href="http://carew.github.io/documentation.html#front-matter">Learn more about Front matters on the official website</a>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Carew is really simple to use, in this article we've covered the minimum you
should know to create pages, blog posts and tags.</p>

<p>I hope you enjoyed this article and that it helped you a little.</p>

<p>If you want to learn more, for example to customize its behaviour or its theme,
please refer to <a href="http://carew.github.io/documentation.html">the official documentation</a>.</p>
]]></content>
        </entry>
    </feed>